<<<
[#insns-c_popretl,reftext="c.popretl: pop 5 to 13 registers from stack memory and return, 16-bit encoding"]
=== c.popretl

Synopsis::
Pop 5 to 13 registers from stack memory and return, 16-bit encoding

Mnemonic::
c.popret _{reg_list_5_13}, stack_adj_

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  2, name: 0x2,      attr: ['OP=C0'] },
    { bits:  3, name: 'rlist3', attr: ['reg_list'] },
    { bits:  2, name: 0x1,      attr: []},
    { bits:  3, name: 'spimm\[6:4\]',  attr: [] },
    { bits:  6, name: 0x2b,     attr: ['FUNCT6'] },
],config:{bits:16}}
....

Syntax::

[source,sail]
--
c.popret {<reg_list_5_13> | <xreg_list_5_13>}, -<stack_adj>
--

The variables used in the syntax are defined below.

[source,sail]
--
<reg_list_5_13> ::= <ra> "," <s0-sN> (where N is 3,4,5,6,7,8,9,11)

if (<reg_list_5_13>=="ra, s0-sN")  <xreg_list_5_13>="x1, x8-x9, x18-xM" (where M=N+16 and N is 3,4,5,6,7,8,9,11)
 
RV32:
if (<reg_list_5_13>=="ra, s0-sN")   <stack_adj>=[32|48|..|528] (where N is 3-6)
if (<reg_list_5_13>=="ra, s0-sN")   <stack_adj>=[48|64|..|544] (where N is 7-9)
if (<reg_list_5_13>=="ra, s0-s11")  <stack_adj>=[64|80|..|560]

RV64:
if (<reg_list_5_13>=="ra, s0-sN")   <stack_adj>=[ 48| 64|..|544] (where N is 3,4)
if (<reg_list_5_13>=="ra, s0-sN")   <stack_adj>=[ 64| 80|..|560] (where N is 5,6)
if (<reg_list_5_13>=="ra, s0-sN")   <stack_adj>=[ 80| 96|..|576] (where N is 7,8)
if (<reg_list_5_13>=="ra, s0-s9")   <stack_adj>=[ 96|112|..|576] 
if (<reg_list_5_13>=="ra, s0-s11")  <stack_adj>=[112|128|..|592]
--

<<<
Description::
This instruction pop (loads) the registers in _reg_list_5_13_ from stack memory,
 adjusts the stack pointer by _stack_adj_ and then returns.

[NOTE]

  All ABI register mapping are for the UABI. An EABI version is planned once the EABI is frozen.

For further information see <<insns-pushpop>>.

Field decoding::

The mapping from the _rlist3_ and _spimm_ fields in the encoding are as shown below.

[#c_pushla_rlist3_decode]
._rlist3_ decoding 
[options="header",width=70%]
|==================================================
|rlist3     |reg_list_5_13 2+|stack_adj_base
|           |             |RV32 | RV64 
|0          |ra, s0-s3    |32   | 48         
|1          |ra, s0-s4    |32   | 48         
|2          |ra, s0-s5    |32   | 64          
|3          |ra, s0-s6    |32   | 64          
|4          |ra, s0-s7    |48   | 80          
|5          |ra, s0-s8    |48   | 80          
|6          |ra, s0-s9    |48   | 96          
|7          |ra, s0-s11   |64   | 112         
|==================================================

_stack_adj_base_ covers enough 16-byte blocks of memory to cover the registers in _reg_list_5_13_. 

_spimm_ is used to allocate extra stack space in 16-byte blocks. 

The total stack adjustment is calculated as shown.

[source,sail]
--
stack_adj = stack_adj_base+spimm[6:4]*16
--

Prerequisites::
The C-extension must also be configured.

32-bit equivalent::
No direct equivalent encoding exists.

<<<


Operation::
[source,sail]
--
//This is not SAIL, it's pseudo-code. The SAIL hasn't been written yet.

//RV64 must have a 16-byte aligned sp
if (misa.MXL==2 && sp[3:0]) {take_illegal_instruction_exception();}
//RV32 might only need 8-byte aligned SP (EABI)
if (misa.MXL==1 && sp[2:0]) {take_illegal_instruction_exception();}

if (misa.MXL==1) bytes=4; else bytes=8;

addr=sp+stack_adjustment-bytes;
switch(bytes) {
  4:  asm("lw ra, 0(addr)");
  8:  asm("ld ra, 0(addr)");
}
for(i=31;i>=0;i--)  {
  //if register i is in xreg_list
  if (xreg_list[i]) {
    addr-=bytes;
    switch(bytes) {
      4:  asm("lw s[i], 0(addr)");
      8:  asm("ld s[i], 0(addr)");
    }
  }
}
//The sequence must be uninterruptible from this point
sp+=stack_adjustment; //increment
asm("ret");
--

<<<

RV32 Assembly examples::

[source,sail]
--
c.popret {ra, s0-s3}, 48
--

Encoding: _rlist2_=0, _spimm_=1
Equivalent sequence:

[source,sail]
--
lw   s3, 44(sp);
lw   s2, 40(sp);  
lw   s1, 36(sp);  
lw   s0, 32(sp);  
lw   ra, 32(sp);  
addi sp, sp, 48;
ret;
--

[source,sail]
--
c.popret {ra, s0-s4}, 64
--

Encoding: _rlist2_=1, _spimm_=2
Equivalent sequence:

[source,sail]
--
lw   s4, 60(sp);
lw   s3, 56(sp);
lw   s2, 52(sp);  
lw   s1, 48(sp);  
lw   s0, 44(sp);  
lw   ra, 40(sp);  
addi sp, sp, 64;
ret;
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zces (<<Zces>>)
|0.53
|Stable
|===
