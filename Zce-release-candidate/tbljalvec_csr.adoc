<<<
[#csrs-tbljalvec,reftext="tbljalvec CSR, table jump base vector and control register"]
=== TBLJALVEC CSR

Synopsis::
Table jump base vector and control register

Address::
TBD

Permissions::
URW

Format (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  6, name: 'config',    attr: ['CONFIGURATION'] },
    { bits: 26, name: 'XLEN-1:6',  attr: ['base[XLEN-1:6]'] },
],config:{bits:32}}
....

Description::

_TBLJALVEC.base_ is a virtual address, whenever virtual memory is enabled.

Using _TBLJALVEC.base[5:0]_ is implicitly zero, and is naturally aligned for all legal values of _XLEN_.

The memory pointed to by _TBLJALVEC.base_ is treated as instruction memory for the purpose of executing table jump instructions. 

[#TBLJALVEC-config-table]
._TBLJALVEC.config_ definition
[width="60%",options=header]
|=============================================================================================
| TBLJALVEC.config | Comment
| 000000 | Jump table mode
| others | *reserved for future standard use*
|=============================================================================================

_TBLJALVEC.config_ is a WARL field, so can only be programmed to modes which are implemented. Therefore the discovery mechanism is to 
attempt to program different modes and read back the values to see which are available. Jump table mode _must_ be implemented.

Architectural State::

TBLJALVEC adds architectural state to the context, therefore must be saved/restore on context switch. 

Additional architectural state requires a state enable to be allocated. 
Accesses when the state is disabled will throw an illegal instruction exception.
The state enable is not specified in this document.

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zces (<<Zces>>)
|0.53
|Stable
|===
