<<<
[#insns-push_areg_list,reftext="push: push registers to stack memory, 32-bit encoding"]
=== push

Synopsis::
Push registers to stack memory, 32-bit encoding

Mnemonic::
push _{reg_list}, {<areg_list>}, -stack_adj_

Encoding (RV32, RV64, RV128)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 'TBD',          attr: ['opcode'] },
    { bits:  5, name: 'spimm\[8:4\]', attr: [''] },
    { bits:  3, name: 'TBD',          attr: ['funct3']},
    { bits:  1, name: 'TBD',          attr: []},
    { bits:  4, name: 'rlist_0_12',   attr: ['reg_list'] },
    { bits:  1, name: 'areg',         attr: [] },
    { bits: 11, name: 'TBD',          attr: ['FUNCT6'] },
],config:{bits:32}}
....

[NOTE]

  _rlist_0_12_ is only valid for _push_ for values 0-12. Values 13-15 map onto _different_ encodings.

Syntax::

[source,sail]
--
push {<reg_list_32u> | <xreg_list_32u>}, {<areg_list>}, -<stack_adj>
--

The variables used in the syntax are defined below.

[source,sail]
--
<reg_list_32u> ::= <ra> ["," <s0>  | <s0-sN> ] (where N is 1,2,...,11)

if (<reg_list_32u>=="ra")         <xreg_list_32u>="x1"
if (<reg_list_32u>=="ra, s0")     <xreg_list_32u>="x1, x8"
if (<reg_list_32u>=="ra, s0-s1")  <xreg_list_32u>="x1, x8-x9"
if (<reg_list_32u>=="ra, s0-s2")  <xreg_list_32u>="x1, x8-x9, x18"
if (<reg_list_32u>=="ra, s0-sN")  <xreg_list_32u>="x1, x8-x9, x18-xM" (where M=N+16 and N is 3-11)

if (<reg_list_32u>=="ra")          <areg_list>=""
if (<reg_list_32u>=="ra, s0")      <areg_list>="" | "a0"
if (<reg_list_32u>=="ra, s0-sN")   <areg_list>="" | "a0-aP" (where N is 1-11; if (N<4) P=N; else P=3;)

if (<reg_list_32u>=="ra")          <stack_adj>=[16|32|..|512]
if (<reg_list_32u>=="ra, s0")      <stack_adj>=[16|32|..|512]
if (<reg_list_32u>=="ra, s0-sN")   <stack_adj>=[16|32|..|512] (where N is 1,2)
if (<reg_list_32u>=="ra, s0-sN")   <stack_adj>=[32|48|..|528] (where N is 3,4,5,6)
if (<reg_list_32u>=="ra, s0-sN")   <stack_adj>=[48|64|..|544] (where N is 7,8,9,10)
if (<reg_list_32u>=="ra, s0-s11")  <stack_adj>=[64|96|..|560]
--

Description::
This instruction pushes (stores) the registers in _reg_list_ to stack memory, and then adjusts the stack pointer by _-stack_adj_. 
For further information see <<insns-pushpop>>.

Prerequisites::
None

Field decoding::

The mapping from the _rlist_ and _spimm_ fields in the encoding are as shown below.

[#push_areg_list_rlist_decode]
._rlist_ decoding 
[options="header",width=60%]
|======================================
|rlist_0_12 |reg_list_32u |stack_adj_base 
|0          |ra           |16             
|1          |ra, s0       |16             
|2          |ra, s0-s1    |16             
|3          |ra, s0-s2    |16             
|4          |ra, s0-s3    |32             
|5          |ra, s0-s4    |32             
|6          |ra, s0-s5    |32             
|7          |ra, s0-s6    |32             
|8          |ra, s0-s7    |48             
|9          |ra, s0-s8    |48             
|10         |ra, s0-s9    |48             
|11         |ra, s0-s10   |48             
|12         |ra, s0-s11   |64             
|======================================

_stack_adj_base_ covers enough 16-byte blocks of memory to cover the registers in _reg_list_32u_. 
_spimm_ is used to allocate extra stack space in 16-byte blocks. 
The total stack adjustment is calculated as shown.

[source,sail]
--
stack_adj = stack_adj_base+spimm[8:4]*16
--

[#push_areg_list_decode]
._areg_list_ decoding 
[options="header",width=60%]
|================================================
|rlist_0_12  2+|areg_list
|        |areg=0        |areg=1
|0       |""            |""
|1       |""            |a0
|2       |""            |a0-a1
|3       |""            |a0-a2
|4-12    |""            |a0-a3
|================================================


Prerequisites::
The C-extension must also be configured.

<<<

Operation::
[source,sail]
--
//This is not SAIL, it's pseudo-code. The SAIL hasn't been written yet.

//RV64/RV128 must have a 16-byte aligned sp
if (misa.MXL>=2 && sp[3:0]) {take_illegal_instruction_exception();}
//RV32I might be using the EABI (8-byte alignment) or UABI (16-byte alignment, so in hardware we can only check for 8)
if (misa.MXL==1 && sp[2:0]) {take_illegal_instruction_exception();}

if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp-bytes;
switch(bytes) {
  4:  asm("sw ra, 0(addr)");
  8:  asm("sd ra, 0(addr)");
  16: asm("sq ra, 0(addr)");
}
for(i=31;i>=0;i--)  {
  //if register i is in xreg_list
  if (xreg_list[i]) {
    addr-=bytes;
    switch(bytes) {
      4:  asm("sw s[i], 0(addr)");
      8:  asm("sd s[i], 0(addr)");
      16: asm("sq s[i], 0(addr)");
    }
  }
}
//The sequence must be uninterruptible from this point
if (areg_list[a0]) asm("mv s0, a0");
if (areg_list[a1]) asm("mv s1, a1");
if (areg_list[a2]) asm("mv s2, a2");
if (areg_list[a3]) asm("mv s3, a3");
  
sp+=stack_adjustment; //decrement
--

<<<

Assembly examples::

[source,sail]
----
push  {ra, s0-s4}, {a0-a3}, -528
----

Encoding: _rlist_=5, _spimm0_5[8:4]_=0x1f, _areg_=1

Equivalent sequence:

[source,sail]
----
sw  s4, -4(sp);
sw  s3, -8(sp); 
sw  s2, -12(sp);
sw  s1, -16(sp); 
sw  s0, -20(sp);
sw  ra, -24(sp); 
mv  s0, a0
mv  s1, a1
mv  s2, a2
mv  s3, a3
addi sp, sp, -528;
----

[source,sail]
----
push {ra, s0-s3}, {}, -32
----

Encoding: _rlist3_=2, _spimm[8:4]_=1, _areg_=0

Equivalent sequence:

[source,sail]
----
sw  s3, -4(sp);
sw  s2, -8(sp);
sw  s1, -12(sp);
sw  s0, -16(sp); 
sw  ra, -20(sp);
addi sp, sp, -32;
----

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zces (<<Zces>>)
|0.52
|Plan
|===
