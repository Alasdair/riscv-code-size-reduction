= RISC-V 16-bit code-size reduction extension proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16-bit instructions proposed to help reduce code-size.

. Instructions proposed for v1.0 are in normal text
. Instructions proposed for the `future` are in _italics_

== Issues for v1.0

. we can probably squeeze `pop` into unused `rcount` values of `popret` as it's only used ~ 1/4 of the time and has fewer common argument lists
. there are probably too many instructions listed, so we need to reduce the list
. confirm immediate bits for `c.sb, c.lbu, c.sh, c.lhu`
. whether we need signed byte/half load versions

== Issues for the `future` proposals

. Need to resolve whether to have C.LWPC or L.LI / C.CALL or L.JAL
. Maybe add table index instruction - table index offset into a jump table specified by a CSR similar to MTVEC instead of C.CALL

== C-extension subsets

https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/C-extension%20subsets.xlsx[This spreadsheet has a proposal for how to divide the C-extension into subsets, and how to select code-size reduction instructons for all relevant base architectures and extensions]

== Rationale

16-bit instructions are highly valuable for code-size reduction. The proposal is split into two phases
. v1.0 to be ratified in 2021
. `future` to be ratified later

The most useful instructions will be ratified in v1.0, whilst also limiting the complexity to adding multi-step instructions.

== v1.0 proposal

=== v1.0 Opcode Assignment and Semantics

Discussion should be mainly focussed on the proposals for v1.0 

[#proposed-16bit-encodings-1]
.proposed 16-bit encodings-1 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|PUSH/POP/POPRET specifications are mature
17+|`rcount` must be in the range 0 to 10 to decode as these instructions
3+|  100       | 1  | 1  4+|rcount (0,10) | 0  | 0  3+| spimm   2+| 00  | C.POP[.E]
3+|  100       | 1  | 1  4+|rcount (0,10) | 0  | 1  3+| spimm   2+| 00  | C.POPRET[.E]
3+|  100       | 1  | 1  4+|rcount (0,10) | 1  | 0  3+| spimm   2+| 00  | C.PUSH[.E]
17+|PUSHZERO spec is less mature than PUSH/POP/POPRET and the benefit is lower
3+|  100       | 1  | 1  4+|rcount (0,10) | 1  | 1  3+| spimm   2+| 00  | *reserved*
3+|  100       | 1  | 1  4+| 1011       5+|                     2+| 00  | *reserved*
3+|  100       | 1  | 1  2+| 11 7+|                             2+| 00  | *reserved*
|=============================================================================================

[#proposed-16bit-encodings-2]
.proposed 16-bit encodings-2 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|Single source/dest with room for 3 more encodings
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 0  | 0  3+| 000     2+| 00  | C.ZEXT.B
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 0  | 1  3+| 001     2+| 00  | C.ZEXT.H
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 1  | 0  3+| 010     2+| 00  | C.SEXT.B
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 1  | 1  3+| 011     2+| 00  | C.SEXT.H
3+|  100       | 1  | 0  | 0 3+| rs1'/rd' | 1  | 1  3+| 100     2+| 00  | C.LSBNOT
3+|  100       | 1  | 0  | 0 3+|          | 1  | 1  3+| >=101   2+| 00  | *reserved*
3+|  100       | 1  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| rs2'    2+| 00  | C.MUL
3+|  100       | 1  | 0  | 1 3+|        2+| not 00  3+|         2+| 00  | *reserved*
|=============================================================================================

[#proposed-16bit-encodings-3]
.proposed 16-bit encodings-3 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 0  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 0  |uimm[3] 3+|     rd' 3+|uimm[2:1，4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 0  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 0  |uimm[3] 3+|    rs2' 3+|uimm[2:1，4] 2+|11 2+|00 | C.SHSP
17+|two-step execution, load PC relative value and then jump to the loaded value
3+|  100       | 0  | 1 2+| 00     7+| uimm[8:2]                    2+|00 | *reserved*
|=============================================================================================

[#proposed-16bit-encodings-4]
.proposed 16-bit encodings-4 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|This encoding space is also available for RV32 only
3+|  000       | 1  2+| uimm[8:7] 3+| rd' 5+| uimm[6:2]         2+| 10  | *reserved*
17+|This encoding space is also available for RV32 only
3+|  100       | 1  | 0  9+|                                    2+| 01  | *reserved*
|=============================================================================================

[#b-extension 16-bit encodings]
.B-extension proposed 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|These are taken fromthe B-extension draft specification and are subject to change
3+|  011       |0 2+|00     3+| rs1'/rd'  5+| 00000             2+| 00  | C.NOT
3+|  011       |0 2+|01     3+| rs1'/rd'  5+| 00000             2+| 00  | C.NEG
3+|  011       |0 2+|10     3+| rs1'/rd'  5+| 00000             2+| 00  | *reserved*
3+|  011       |0 2+|11     3+| rs1'/rd'  5+| 00000             2+| 00  | *reserved*
|=============================================================================================

[#doubleprecisionreuse]
.Reuse of double precision encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|D-extension load/stores, reallocated if D is not implemented
3+|  101     3+|uimm[0,4:3] 3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 00  | C.SB  (behind C.FSD)
3+|  001     3+|uimm[0,4:3] 3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 00  | C.LBU (behind C.FLD)
3+|  101     3+|uimm[0,4:3] 3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 10  | C.SH  (behind C.FSDSP)
3+|  001     3+|uimm[0,4:3] 3+| rs1'      2+| uimm[2:1] 3+|rs2' 2+| 10  | C.LHU (behind C.FLDSP)
17+|F-extension load/stores for reference, will *not* be reallocated
3+|  111    11+|                                                2+| 00  | *reserved* (behind C.FSW)
3+|  011    11+|                                                2+| 00  | *reserved* (behind C.FLW)
3+|  111    11+|                                                2+| 10  | *reserved* (behind C.FSWSP)
3+|  011    11+|                                                2+| 10  | *reserved* (behind C.FLWSP)
|=============================================================================================

[#v1.0semantics]
.v1.0 semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.POP[.E]     | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[POP registers]
| C.POPRET[.E]  | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[POP registers and return]
| C.PUSH[.E]    | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[PUSH registers]
| C.ZEXT.B      | rd' = zero_ext(rs1'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rs1'[15:0])
| C.SEXT.B      | rd' = sign_ext(rs1'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rs1'[15:0])
| C.LSBNOT      | rd' = rs1' XOR 1
| C.MUL         | rd' = rs1' * rs2'
| C.LBUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | Memory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | Memory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
| C.NOT         | rd' = ~rs1'
| C.NEG         | rd' = -rs1'
| C.SB          | rd' = Memory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = Memory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
| C.LBU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][15:0])
|=======================================================================

=== v1.0 Assembly Examples

[source,sourceCode,text]
----
zext.b a5;      # a5 = zero_ext(a5[7:0])
zext.h a5;      # a5 = zero_ext(a5[15:0])
sext.b a5;      # a5 = sign_ext(a5[7:0])
sext.h a5;      # a5 = sign_ext(a5[15:0])

lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0]), for 16-bit encoding immediate must be in range, the registers must be x8-x15
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0]), for 16-bit encoding immediate must be in range, the registers must be x8-x15
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0],     for 16-bit encoding immediate must be in range, the registers must be x8-x15
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0],     for 16-bit encoding immediate must be in range, the registers must be x8-x15

mul a5, a5, a6; # a5 = a5 * a6, for 16-bit encoding rd==rs1 and all registers are x8-x15      

not a5          # a5 = ~a5 bitwise inversion
neg a5          # a5 = -a5 two's complement inversion

lbu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[ 7:0]), for 16-bit encoding immediate must be in range, the registers must be x8-x15
lhu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[15:0]), for 16-bit encoding immediate must be in range, the registers must be x8-x15
sb  a5,20(a4)   # Memory(a4+20)[ 7:0] = a5[ 7:0],     for 16-bit encoding immediate must be in range, the registers must be x8-x15
sh  a5,20(a4)   # Memory(a4+20)[15:0] = a5[15:0],     for 16-bit encoding immediate must be in range, the registers must be x8-x15
----

=== 32-bit encodings for v1.0

Note that the B-extension is required for 32-bit versions of the following instructions:

* `C.ZEXT.H`
* `C.SEXT.B`
* `C.SEXT.H`

=== v1.0 Benchmarking results on the Huawei IoT code

[#analysis_results]
.Analysis results
[width="100%",options=header]
|=======================================================================================================
| Instruction             | saving | status 
| C.SB, C.LBU, C.SH, C.LHU| 3.68%  | implemented in HCC and measured
| C.PUSH, C.POP, C.POPRET | 3.46%  | implemented in HCC and measured
| C.ZEXT.B, C.ZEXT.H      | 0.34%  | implemented in HCC and measured
| C.LBUSP, C.SBSP         | 0.25%  | estimated based on 32-bit encoding
| C.LHUSP, C.SHSP         | 0.23%  | estimated based on 32-bit encoding
| C.MUL                   | 0.03%  | estimated based on 32-bit encoding
| C.LSBNOT                | 0.02%  | estimated based on 32-bit encoding "XORI 1"
| C.NOT                   | -      | no estimate - should search for "XORI -1"
| C.SEXT.B, C.SEXT.H      | -      | no estimate - should search for shift left/shift right?
| C.NEG                   | -      | no estimate - should search for 0-A?
|=======================================================================================================


== `Future` Proposals

=== `Future` Opcode Assignment and Semantics

[#future-proposed-16bit-encodings]
.`Future 16-bit encodings 
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|PUSHZERO spec is less mature than PUSH/POP/POPRET and the benefit is lower
3+|  100       | 1  | 1  4+|rcount (0,10) | 1  | 1  3+| spimm   2+| 00  | _C.PUSHZERO[.E]_
17+|two-step execution, load PC relative value and then jump to the loaded value
3+|  100       | 0  | 1 2+| 00     7+| uimm[8:2]                2+| 00  | _C.CALL_
17+|PC relative load, only available for RV32 as this encoding is C.SLLI with an out of range shift
3+|  000       | 1  2+| uimm[8:7] 3+| rd' 5+| uimm[6:2]         2+| 10  | _C.LWPC_
17+|From the B-extension
3+|  011       |0 2+|10     3+| rs1'/rd'  5+| 00000             2+| 00  | _C.ZEXT.W (RV64+)_
3+|  011       |0 2+|11     3+| rs1'/rd'  5+| 00000             2+| 00  | _C.ZEXT.D (RV128)_
|=============================================================================================

[#futuresemantics]
.`Future` semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| _C.PUSHZERO[.E]_| https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[PUSH registers and ZERO the allocated memory]
| _C.LSBNOT_      | rd' = rs1' XOR 1
| _C.CALL_        | ra  = sign_ext(Memory[pc_offset(PC, zero_ext(uimm))][31:0])); JAL(ra);
| _C.LWPC_        | rd' = sign_ext(Memory[pc_offset(PC, zero_ext(uimm))][31:0])
|=======================================================================

The `pc_offset` function is defined to always allow a word offset to be encoded without encoding bit 1
of the immediate. Therefore if the result is a 16-bit aligned PC offset, increment by 2 to point to the next
word aligned address. This means that the final address is *always* word aligned.
[source,sourceCode,text]
----

//PC=0x18, offset=0x4, pc_offset=0x24 - non-word aligned PC adds uimm+2
//PC=0x20, offset=0x4, pc_offset=0x24 - word aligned PC adds uimm
//PC=0x22, offset=0x4, pc_offset=0x28 - non-word aligned PC adds uimm+2
//PC=0x24, offset=0x4, pc_offset=0x28 - word aligned PC adds uimm

int pc_offset(int PC,  int uimm){
        pc_offset = (PC + uimm + 2) & sign_ext(0xc)
}

----


The idea of `C.LWPC` is to load constant values from the end of the current function, which is why the immediate is unsigned. 

`C.CALL` was suggested by Guo Ren from Alibaba - it's similar to LOADPC on ARM - PC relative load and then `JAL ra` to the loaded value. It may take any load related exception (PMP fault, page fault etc.) although
alignment faults are not possible as the result of `pc_offset()` is always word aligned. 

_Both `C.LWPC` and `C.CALL` require the instruction memory to have PMP read permission as well as execute permission, which allows searching for ROP gadgets. Therefore I think we should implement the 48-bit encodings instead (`L.LI` and `L.JAL`) for better security, less chance of cache fragmentation (loading instruction memory into the D-cache) and saving 16-bit encoding space._

=== `Future` Assembly Examples

[source,sourceCode,text]
----

lw  a5, 16(pc); # a5 = zero_extend(Memory[PC + 16<<2)[31:0]), for 16-bit encoding offset must be in range and rd=x8-x15
jal ra, 16(pc); # jump to Memory(pc_16), ra=PC+2, for 16-bit encoding offset must be in range, the link register must be ra
----

=== `Future` Benchmarking results on the Huawei IoT code

[#analysis_results]
.Analysis results
[width="100%",options=header]
|=======================================================================================================
| Instruction             | saving | status 
| _C.PUSHZERO_            | 0.2%   | estimated - see email dated 2020/10/12 PUSHZERO
|=======================================================================================================


== Rejected instructions

Jim Wilson pointed at that we should fix `-mno-strict-align` and mandate that cores which need `C.ORSLL[8|16|24]` support unaligned load/store, so that we don't need to assemble bytes into words

`C.RORI` is only useful under limited circumstances

