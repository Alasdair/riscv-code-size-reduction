= RISC-V Push/Pop Extension
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 32-bit and 16-bit encodings for `[C.]PUSH`,
`[C.]POP` and `[C.]POPRET` instructions for RV32 and RV64,
architectures, I and E variants. 

`PUSHINT/POPINT` are included for fast interrupt handler context save/restore.

32-bit or 64-bit `f` registers may also be saved/restored.

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

* whether to support PUSHZERO which also zeroes the additional stack memory, need a 16-bit encoding for good code size saving 
  but latency could be long so what about restart after interrupts?
** estimate additional 0.2% code size saving for IoT: 0.1% for sw zero, offset(sp) and 0.05% for sh, sb
* need to review usage of register lists, and make sure the proposal matches load/store multiple requirements
* it would be simpler to specificy the number of registers to save/restore, but if load/store multiple allows arbitrary registers then we need to support a list


== Rationale

`[C.]PUSH[.E]/[C.]POP[.E]/[C.]POPRET[.E]` are designed to replace the
most commonly called functions generated by the compiler using
_–m-save-restore_. When the _–msave-restore_ option is used the compiler
replaces the sequence of stores plus `sp` decrement operation required
to spill/push registers to the stack with a call to a shared co-routine
that performs this operation. In addition the equivalent fill/pop
sequence is replaced with a jump to a shared co-routine (which then
performs the return to the caller of the function). The code savings can
be significant (provided that the co-routine jump/calls can be encoded
in a single 32-bit instruction) but the run-time overhead is high as an
additional 3 jumps are required for each push/pop sequence; in addition
the shared save/restore routines include redundant memory operations
when the number of registers to spill is not a multiple of 4.

The most useful forms of these instructions are the 16-bit encodings, as
these give the largest code size reduction, whilst covering the vast
majority of useful cases.

== 16-bit encodings

=== `C.PUSH[.E]` instruction

`C.PUSH[.E]` which allows most spill sequences to only take 16-bits of
code space instead of 32-bits for the call to the save routine (or in
some cases 64-bits if the target function is too far away).

=== `C.POP[.E]` instruction

`CPOP[.E]` which allows most fill sequences to be performed with two
16-bit instructions (`C.POP+RET` ) which matches the cost of the
co-routine jump (for jumps <1Mbyte) but with significantly better
performance.

=== `C.POPRET[.E]` instructions

`C.POPRET[.E]` which allows both the `CPOP[.E]` and `RET` to be
performed in a single instruction saving 16-bits of code with respect to
a `C.POP+RET` or a jump to a restore co-routine.

=== Opcode Assignment

.proposed encoding
[width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction

17+|*These replace reserved encodings, use the .E suffix for EABI

3+|100|1|0 4+|rcount|0|0 3+|spimm 2+|00|C.POP[.E]
3+|100|1|0 4+|rcount|0|1 3+|spimm 2+|00|C.POPRET[.E]
3+|100|1|0 4+|rcount|1|0 3+|spimm 2+|00|C.PUSH[.E]
|=======================================================================

Notes

* The `spimm` field is an unsigned immediate that indicates the number
of additional _n_-byte blocks to adjust the stack pointer by. See <<spimm-table>>
and <<rcount-table>>
* the instructions are designed to support the UABI and EABI (`.E` suffix) for RV32 and for RV64
* RV64E is not currently in the RISC-V standard, but may be included in
the future so it is fully included in this specification
* For UABI documentation see Chapter 20 of
http://riscv.org/specifications/isa-spec-pdf[The RISC-V ISA
specification]
* For the EABI, see this
https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc[proposal]


[#spimm-table]
.`spimm` and register holes for different architectures and ABIs
[options="header"]
|=======================================================================
|arch+ABI |spimm _n_ |total stack adjustment for _r_ registers |register holes to skip
|RV32[IE] EABI |8 |adjust = 8*((r+1)/2+spimm) |holes = r mod 2

|RV32I UABI |16 |adjust = 16*((r+3)/4+spimm) |holes = 3-((r+3) mod 4)

|RV64I UABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2

|RV64[IE] EABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2
|=======================================================================

The purpose of `spimm` is to allow a function to allocate additional
space on the stack for automatic variables without having to perform an
additional stack adjustment (and therefore save more code size).

The encodings contain no explicit register index fields as the memory
accesses and pointer increments are all based on the stack pointer
register as defined in the standard RISC-V ABIs `sp` and the registers
to be loaded/stored are specified using the `rcount` field (see
<<rcount-table>>)

The behaviour of each value of `rcount` and `spimm` is shown in
<<rcount-table>>, where:

* x = `spimm`
* y = `spimm`, but the encoding should have `spimm[0]=1` for legal stack alignment for the UABI
* z = `spimm`, but the encoding should have `spimm[0]=0` for legal stack alignment for the UABI

[#rcount-table]
.`rcount` values for different architectures
[options="header",width=100%]
|===================================================================================================================================
|rcount| ABI names            6+|Stack pointer adjustment                                      5+|reg holes to skip          
|      |                      6+|x=spimm -for C.PUSH[.E], +for C.POP[.E]                       5+|                           
|      |                        |RV32I UABI|RV32I EABI|RV64I UABI|RV64I EABI  |RV32E     |RV64E  |RV32I UABI|RV32I EABI|RV64I  |RV32E|RV64E    
13+| `rcount` 0-2 for RV32I UABI requires restricted `spimm` values to avoid SP misalignment so the formulae use *y* or *z* instead of x
13+| `C.PUSH/C.POP/C.POPRET` and `C.PUSH.E/C.POP.E/C.POPRET.E` are synonymous for these
|0     |ra                      | 8(1+*y*) | 8(1+x)   |16(1+x)   |16(1+x)     | 8(1+x)   |16(1+x)| 3        | 1        | 1   2+| 1  
|1     |ra, s0                  | 8(1+*y*) | 8(1+x)   |16(1+x)   |16(1+x)     | 8(1+x)   |16(1+x)| 2        | 0        | 0   2+| 0  
|2     |ra, s0-s1               | 8(2+*z*) | 8(2+x)   |16(2+x)   |16(2+x)     | 8(2+x)   |16(2+x)| 1        | 1        | 1   2+| 1  
13+| `rcount` 3-7 are UABI only. Mnemonics are `C.PUSH/C.POP/C.POPRET`
|3     |ra, s0-s2               |16(1+x)   |N/A       |16(2+x)   |N/A       2+|*reserved*        | 0        | N/A      | 0   2+|*reserved*    
|4     |ra, s0-s3               |16(2+x)   |N/A       |16(3+x)   |N/A       2+|*reserved*        | 3        | N/A      | 1   2+|*reserved*    
|5     |ra, s0-s5               |16(2+x)   |N/A       |16(4+x)   |N/A       2+|*reserved*        | 1        | N/A      | 0   2+|*reserved*    
|6     |ra, s0-s8               |16(3+x)   |N/A       |16(5+x)   |N/A       2+|*reserved*        | 2        | N/A      | 1   2+|*reserved*    
|7     |ra, s0-s11              |16(4+x)   |N/A       |16(7+x)   |N/A       2+|*reserved*        | 3        | N/A      | 0   2+|*reserved*    
13+| `rcount` 8-10 are EABI only. Mnemonics are `C.PUSH.E/C.POP.E/C.POPRET.E`
|8     |ra, s0-s2               |N/A       |8(2+x)    |N/A       |16(2+x)     |8(2+x) |16(2+x)   | 0        | N/A      | 0   2+| 0
|9     |ra, s0-s3               |N/A       |8(3+x)    |N/A       |16(3+x)     |8(3+x) |16(3+x)   | 1        | N/A      | 1   2+| 1
|10    |ra, s0-s4               |N/A       |8(3+x)    |N/A       |16(4+x)     |8(3+x) |16(4+x)   | 0        | N/A      | 0   2+| 0
|11-15 12+|*reserved*
|===================================================================================================================================

[NOTE]
  Because the UABI and EABI define different registers for `s2-s5` different encodings are needed, so `C.PUSH` is used for the UABI and `C.PUSH.E` for the EABI.

=== `C.PUSH[.E]` Operation

A `C.PUSH[.E]` instruction writes the set of registers selected by `rcount` to memory, the registers are written to the memory immediately
below the current stack pointer. The last register in the list is stored to the lowest memory location to be written by the `C.PUSH[.E]`

[source,sourceCode,text]
----
sp-(XLEN/8)*r
----

where `r` is the number registers to store

The selected registers are written to contiguous incrementing
(XLEN/8)-byte words starting with the register in the reverse of the
order shown in <<rcount-table>> above (ra is always stored last).

Once all stores have completed the stack pointer register `sp` is
decremented by the stack adjustment value from <<spimm-table>> and
<<rcount-table>>.

Note that `spimm` allows additional bytes of stack to be
allocated for automatic variables without having to issue additional
stack manipulation instructions.

.push 1 to 5 registers
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/push_1to5_regs_170pc_zoom.png[push example]

=== `C.POP[.E]/C.POPRET[.E]` Operation

A `C.POP[.E]/C.POPRET[.E]` instruction loads the set of registers selected by `rcount` from the memory. The loads start with the last register in the list from <<rcount-table>>
at the lowest memory location to be read by the `C.POP[.E]/C.POPRET[.E]`, which is at the current stack pointer incremented by the number of holes, also from <<rcount-table>>.

The selected registers are loaded from contiguous incrementing (XLEN/8)-byte words in the reverse of the order shown in  <<rcount-table>>
above ( `ra` is always loaded last).

Once all loads have completed the stack pointer register `sp` is incremented by the stack adjustment value from <<spimm-table>> and
<<rcount-table>>, placing it immediately above the block of memory read by the `C.POP[.E]/C.POPRET[.E]` instruction.

`C.POPRET[.E]` executes a `RET` as the final step in the sequence

.pop 1 to 5 registers
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/pop_1to5_regs_170pc_zoom.png[pop example]

[#instruction-sequences]
=== Instruction sequences

The behaviour of these instructions is specified using instruction sequences.

All loads and stores in the sequences can be executed multiple times, and in any order. They can be merged into wider loads or stores, 
or broken down into smaller loads and stores.

The `ADDI` at the end of the sequences (`ADDI, RET` for `C.POPRET[.E]`) only executes if all other steps have completed without causing an exception 
(such as load or store access fault, load or store page fault, breakpoint), taking an interrupt or entering into debug mode (breakpoint or external 
debug halt). It is possible to interrupt the sequence between the final load or store and the `ADDI` instruction. It is _not_ possible to interrupt 
`C.POPRET[.E]` between the `ADDI` and the `RET`.

When execution resumes any number of the loads or stores in the sequences may be re-executed, including partial loads or stores if they have been broken 
down into smaller memory accesses.

It is implementation defined whether to detect cases such as page faults, PMP faults and watchpoint triggers before the sequences
start executing, or on a step-by-step basis. For exceptions, `mepc` will always be the PC of the `PUSH/POP/POPRET` and `mtval` will 
always have the address of the load/store which caused the fault, regardless of whether any of the steps of the sequence have 
actually been issued.

The same argument is true for watchpoint triggers causing entry into debug mode, these can be detected before issuing the sequence or part way through the sequence.
If the same instruction causes more than one watchpoint trigger, then the one triggered by the lowest numbered step is taken.

Additionally, it is implementation defined whether to take interrupts or external debug halts at all during the sequence. An implementation may choose
to only take them before or after the sequence executes.

In the tables:

* `N` is the stack pointer adjustment value from <<rcount-table>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV64

[#cpush_sequence]
.`C.PUSH` sequence
[options="header",width=50%]
|===============================================================================
| `C.PUSH` step                             |Execute if
| sw x27,  (-13*M)(x2)                      |rcount==7
| sw x26,  (-12*M)(x2)                      |rcount==7
| sw x25,  (-11*M)(x2)                      |rcount==7
| sw x24,  (-10*M)(x2)                      |rcount>5 && rcount<8
| sw x23,  ( -9*M)(x2)                      |rcount>5 && rcount<8
| sw x22,  ( -8*M)(x2)                      |rcount>5 && rcount<8
| sw x21,  ( -7*M)(x2)                      |rcount>4 && rcount<8
| sw x20,  ( -6*M)(x2)                      |rcount>4 && rcount<8
| sw x19,  ( -5*M)(x2)                      |rcount>3 && rcount<8
| sw x18,  ( -4*M)(x2)                      |rcount>2 && rcount<8
| sw x9,   ( -3*M)(x2)                      |rcount>1 && rcount<8
| sw x8,   ( -2*M)(x2)                      |rcount>0 && rcount<8
| sw x1,   ( -1*M)(x2)                      |1 
| addi x2, x2,  -N                          |1 
|===============================================================================

[#cpush_sequence]
.`C.PUSH.E` sequence
[options="header",width=50%]
|===============================================================================
| `C.PUSH.E` step                           |Execute if
| sw x7,   ( -5*M)(x2)                      |rcount>9
| sw x6,   ( -4*M)(x2)                      |rcount>8
| sw x14,  ( -3*M)(x2)                      |rcount>7
| sw x9,   ( -2*M)(x2)                      |(rcount==2) {vbar}{vbar} (rcount>=8 && rcount<11)
| sw x8,   ( -2*M)(x2)                      |(rcount==1 && rcount==2) {vbar}{vbar} (rcount>7 && rcount<11)
| sw x1,   ( -1*M)(x2)                      |1 
| addi x2, x2,  -N                          |1 
|===============================================================================

.`C.POP/C.POPRET` sequence
[options="header",width=50%]
|===============================================================================
| `C.POP/C.POPRET` step                    |Execute if
| lw x27,  (-13*M+N)(x2)                   |rcount==7
| lw x26,  (-12*M+N)(x2)                   |rcount==7
| lw x25,  (-11*M+N)(x2)                   |rcount==7
| lw x24,  (-10*M+N)(x2)                   |rcount>5
| lw x23,  (-9*M+N)(x2)                    |rcount>5 && rcount<8
| lw x22,  (-8*M+N)(x2)                    |rcount>5 && rcount<8
| lw x21,  (-7*M+N)(x2)                    |rcount>4 && rcount<8
| lw x20,  (-6*M+N)(x2)                    |rcount>4 && rcount<8
| lw x19,  (-5*M+N)(x2)                    |rcount>3 && rcount<8
| lw x18,  (-4*M+N)(x2)                    |rcount>2 && rcount<8
| lw x9,   (-3*M+N)(x2)                    |rcount>1 && rcount<8
| lw x8,   (-2*M+N)(x2)                    |rcount>0 && rcount<8
| lw x1,   (-1*M+N)(x2)                    |1
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================

.`C.POP.E/C.POPRET.E` sequence
[options="header",width=50%]
|===============================================================================
| `C.POP.E/C.POPRET.E` step                |Execute if
| lw x7,   (-5*M+N)(x2)                    |rcount>9
| lw x6,   (-4*M+N)(x2)                    |rcount>8
| lw x14,  (-3*M+N)(x2)                    |rcount>7
| lw x9,   (-2*M+N)(x2)                    |(rcount==2) {vbar}{vbar} (rcount>7 && rcount<11)
| lw x8,   (-2*M+N)(x2)                    |(rcount==1 && rcount==2) {vbar}{vbar} (rcount>7 && rcount<11)
| lw x1,   (-1*M+N)(x2)                    |1 
| addi x2, x2,  N                          |1 
| ret                                      |C.POPRET.E
|===============================================================================

=== Exceptions

[#sp-misalign]
==== Stack pointer misalignment

Stack pointer misalignment causes a Store Access Fault for `C.PUSH[.E]` or a Load Access Fault for `C.POP[.E]/C.POPRET[.E]`.

Take an exception if:

* RV64: The stack pointer is not 16-byte aligned
* RV32: The stack pointer is not 8-byte aligned and `rcount < 2 || rcount > 7`, otherwise if the stack pointer is not 16-byte aligned

==== Illegal instructions

RV32E and RV64E take an illegal instruction exception if `rcount > 2 && rcount < 8`.
All architectures take an illegal instruction exception if `rcount > 10`.

==== Load/store exceptions

The instructions require loads or stores to be issued, as shown in <<instruction-sequences>>.
Therefore any exceptional behaviour caused by issuing the loads or stores from the sequences can be caused by using these instructions.

=== Assembler Syntax

The `C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]` instructions are represented in assembler as the mnemonic followed by a braced and comma separated list
of registers, followed by the total size of the stack adjustment expressed in bytes. The stack adjustment should include an appropriate
sign bit and the space needed to accommodate the registers in the register list. Register ranges are also permitted and indicated using a
hyphen (-). The register list may only contain registers supported by `C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]` instructions but these can be listed
in any order and use the ABI or "x plus index register" representation.

To be legal the stack adjustment must:

1.  Be negative for a `C.PUSH[.E]` and positive for a `CPOP[.E]/C.POPRET[.E]`
2.  Match the value range in <<rcount-table>> for the current architecture

To use the 16-bit encoding of `C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]` then the registers specified in the encoding must match one of the sets of
entries in <<rcount-table>> above, and the value of `spimm` must fit the available range. Otherwise the assembler will attempt to use the 32-bit encoding,
if it is suitable. If not then this will cause an `illegal operands` error from the assembler.

=== RV32 Assembler Examples

==== C.PUSH RV32 UABI

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  s5, -28(sp);
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra, -4(sp);
addi sp, sp, -64;
----

==== C.PUSH.E RV32I EABI (8-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -24
----

Encoding: rcount=2, spimm=1

Equivalent sequence:

[source,sourceCode,text]
----
sw  s1, -12(sp);
sw  s0,  -8(sp); 
sw  ra,  -4(sp);
addi sp, sp, -24;
----

==== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -32
----

Encoding: rcount=2, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  s1, -12(sp);
sw  s0,  -8(sp); 
sw  ra,  -4(sp);
addi sp, sp, -32;
----

==== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {x1, x8-x9, x18-x24}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw  x24, 120(sp);  lw  x23, 124(sp);  
lw  x22, 128(sp);  lw  x21, 132(sp);  
lw  x20, 136(sp);  lw  x19, 140(sp);  
lw  x18, 144(sp);  lw   x9, 148(sp);  
lw   x8, 152(sp);  lw   x1, 156(sp);
addi sp, sp, 160
----

==== C.POPRET.E RV32I EABI (8-byte aligned stack)

[source,sourceCode,text]
----
c.popret   {x1, x8}, 48
----

Encoding: rcount=1, spimm=5 

Equivalent sequence:

[source,sourceCode,text]
----
lw   x8, 40(sp);
lw   x1, 44(sp);
addi sp, sp, 48; 
ret
----

[#varargs-support]
==== Varargs Support

Functions using varargs also spill the argument registers to the stack,
which requires a `SWM` custom instruction (store-word-multiple).

HCC produces this prologue:

[source,sourceCode,text]
----
16: addi sp,sp,-64 
16: sw   ra,28(sp)
16: sw   s0,24(sp)

16: sw   a7,60(sp)
16: sw   a6,56(sp)
16: sw   a5,52(sp)
16: sw   a4,48(sp)
16: sw   a3,44(sp)
16: sw   a2,40(sp)
16: sw   a1,36(sp)
----

This can be optimised to be:

[source,sourceCode,text]
----
16: addi sp,sp,-32
16: push {ra, s0},-32
16: addi sp,sp,(-32+36)
16: swm  {a1-a7},sp
16: addi sp,sp,-36 
----

saving 3x16-bit encodings, but the stack pointer adjustments are awkward
assuming that `SWM` doesn't have an immediate offset

HCC produces this epilogue

[source,sourceCode,text]
----
16: lw   ra,28(sp)
16: lw   s0,24(sp)
16: addi sp,sp,64
16: ret
----

which could become:

[source,sourceCode,text]
----
16: addi sp,sp,32
16: popret {ra,s0},32
----

saving 2x16-bit encodings.

So in total 14 instructions can be reduced to 9.

== 32-bit encodings

The 32-bit versions of the instructions allow greater flexibility in
specifying the list of registers by allowing floating point registers to
be saved/restored, and also give the option of excluding `ra`. 
Therefore the register list syntax also allows floating
point registers to be included. They can included in any order, but will
always be accessed in the same order by the instruction. 

The 32-bit encodings also allow
a larger range of `spimm` values. Otherwise the semantics are identical
to the 16-bit versions and so the specification is not repeated here.
The instructions are called `PUSH[.E]/POP[.E]/POPRET[.E]`.

`PUSHINT/POPINT` are also specified which allow for context save/restore for interrupt handlers.

These instructions will _not_ cover all possible push/pop scenarios,
they are designed to cover the common cases without using excessive
encoding space.

[NOTE]
  This specification includes cases where the `x` and `f` registers are different widths.
  Presumably the `f` registers need to remain aligned, so will require padding within the stack frame.
  This padding is not currently included.

A C-function using varargs will also spill the argument registers to the
stack. They can be achieved by a store-multiple command after the `PUSH`
instruction and vararg support is not directly implemented by `PUSH` (see <<varargs-support>>)

=== Opcode Assignment

.32-bit encodings for the UABI
[options="header",width="100%"]
|============================================================================
|31:29  | 28   | 27 |26:24   |23:20  |19:15 |14:12 |11:7  |6:0     |name
10+|Certain `rcount` values cause this to decode as either PUSH or PUSHINT
|xxxxxx | 0    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |PUSH
|xxxxxx | 0    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |PUSHINT
10+|Certain `rcount` values cause this to decode as either POP or POPINT
|xxxxxx | 0    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POP
|xxxxxx | 0    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POPINT
|xxxxxx | 0    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POPRET
|============================================================================

.32-bit encodings for the EABI
[options="header",width="100%"]
|============================================================================
|31:29  | 28   | 27 |26:24   |23:20  |19:15 |14:12 |11:7  |6:0     |name
10+|Certain `rcount` values cause this to decode as either PUSH.E or PUSHINT.E
|xxxxxx | 1    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |PUSH.E
|xxxxxx | 1    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |PUSHINT.E
10+|Certain `rcount` values cause this to decode as either POP.E or POPINT.E
|xxxxxx | 1    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POP.E
|xxxxxx | 1    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POPINT.E
|xxxxxx | 1    | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POPRET.E
|============================================================================

The register list is specified by a concentenating the registers specified of the `ra`, `rcount` and `frcount` fields. The meaning of `rcount` varies dpending upon bit 28 `eabi`.
as shown in <<32bit-ra>>, <<32bit-rcount>>, and <<32bit-frcount>>.

[#32bit-eabi]
.`eabi` field, bit 28 of the encoding
[options="header",width="50%"]
|====================================
|eabi    | Comment             
| 0      |rcount field uses UABI                     
| 1      |rcount field uses EABI
|====================================

[#32bit-ra]
.`ra` field
[options="header",width="50%"]
|====================================
|ra      | ABI names               
| 0      |none                     
| 1      |ra
|====================================

The `x` registers are specified by <<32bit-rcount>>. Compared to the 16-bit encodings there is finer control of how many `x` registers are accessed.
There is no semantic difference in the specification.
The addition field `frcount` allows callee save `f` registers to be
saved/restored as well. The `f` registers are always appended to the
list of `x` registers.

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|================================================================
|rcount  |#regs|instruction    | ABI names | `x` register numbers       
5+|`eabi`=0
| 0      | 0   |PUSH/POP/POPRET|none       | none               
| 1      | 1   |PUSH/POP/POPRET|s0         | x8         
| 2      | 2   |PUSH/POP/POPRET|s0-s1      | x8-x9             
| 3      | 3   |PUSH/POP/POPRET|s0-s2      | x8-x9,x18             
| 4      | 4   |PUSH/POP/POPRET|s0-s3      | x8-x9,x18-x19             
| 5      | 5   |PUSH/POP/POPRET|s0-s4      | x8-x9,x18-x20             
| 6      | 6   |PUSH/POP/POPRET|s0-s5      | x8-x9,x18-x21             
| 7      | 7   |PUSH/POP/POPRET|s0-s6      | x8-x9,x18-x22             
| 8      | 8   |PUSH/POP/POPRET|s0-s7      | x8-x9,x18-x23             
| 9      | 9   |PUSH/POP/POPRET|s0-s8      | x8-x9,x18-x24             
| 10     | 10  |PUSH/POP/POPRET|s0-s9      | x8-x9,x18-x25             
| 11     | 11  |PUSH/POP/POPRET|s0-s10     | x8-x9,x18-x26             
| 12     | 12  |PUSH/POP/POPRET|s0-s11     | x8-x9,x18-x27             
| 13   4+| *reserved*               
5+|UABI caller save registers and CSRs to save/restore on interrupt handler entry/exit
| 15     | 18  |PUSHINT/POPINT |t0-t6,a0-a7,mcause,mtval,mepc |x5-x7,x28-x31,x10-x17,mcause,mtval,mepc
5+|`eabi`=1
| 0      | 0   |PUSH.E/POP.E/POPRET.E|none       | none              
| 1      | 1   |PUSH.E/POP.E/POPRET.E|s0         | x8            
| 2      | 2   |PUSH.E/POP.E/POPRET.E|s0-s1      | x8-x9            
| 3      | 3   |PUSH.E/POP.E/POPRET.E|s0-s2      | x8-x9,x14            
| 4      | 4   |PUSH.E/POP.E/POPRET.E|s0-s3      | x8-x9,x14,x6            
| 5      | 5   |PUSH.E/POP.E/POPRET.E|s0-s4      | x8-x9,x14,x6-x7            
| 6-13 4+| *reserved*
5+|EABI caller save registers and CSRs to save/restore on interrupt handler entry/exit
| 15     | 18  |PUSHINT.E/POPINT.E   |t0-t1,a0-a3,mcause,mtval,mepc |x5,x15,x10-x13,mcause,mtval,mepc
|================================================================

[#32bit-frcount]
.`frcount` values for the 32-bit encodings
[options="header"]
|====================================
|frcount |#regs|instruction    | ABI names               
| 0      | 0   |PUSH/POP/POPRET|none                     
| 1      | 1   |PUSH/POP/POPRET|fs0                      
| 2      | 2   |PUSH/POP/POPRET|fs0-fs1                  
| 3      | 3   |PUSH/POP/POPRET|fs0-fs2                  
| 4      | 4   |PUSH/POP/POPRET|fs0-fs3                  
| 5      | 5   |PUSH/POP/POPRET|fs0-fs4                  
| 6      | 6   |PUSH/POP/POPRET|fs0-fs5                  
| 7      | 7   |PUSH/POP/POPRET|fs0-fs6                  
| 8      | 8   |PUSH/POP/POPRET|fs0-fs7                  
| 9      | 9   |PUSH/POP/POPRET|fs0-fs8                  
| 10     | 10  |PUSH/POP/POPRET|fs0-fs9                  
| 11     | 11  |PUSH/POP/POPRET|fs0-fs10                 
| 12     | 12  |PUSH/POP/POPRET|fs0-fs11                 
| 13-14  | N/A |N/A            |*reserved*               
4+|caller save registers to save on interrupt handler entry/exit for all architectures, if `rcount > 13`
| 15     | 20  |PUSHINT/POPINT |ft0-11, fa0-7
|====================================

The `spimm` field decodes as either a multiple of 8-bytes or 16-bytes depending upon the value of `eabi` and the architecture. 

* RV32: If `eabi == 1` then `spimm` is a multiple of 8-bytes otherwise 16-bytes
* RV64: `spimm` is always a multiple of 16-bytes

=== Decoding `spimm` for 8 or 16-byte alignment

For the EABI `rcount` values of < 3 are valid. For RV32I/RV64I, higher `rcount` values can be used as the selection of an ABI is a software choice.
For RV32E/RV64E the EABI must be used, so the encodings are reserved if `rcount > 2` for `PUSH/POP/POPRET`

If `rcount < 3` and the UABI is in use and `spimm` represents 8-byte alignment. Therefore the values of `spimm` should be chosen so that the stack pointer remains 16-byte aligned. 
Examples of this are shown in <<rcount-table>> for the 16-bit encoding.

[#32bit-8byte-rcount]
.Register count mapping for `PUSH/POP/POPRET` for RV32 if `eabi == 1` (8-byte alignment)
[options="header",width="50%"]
|==============================================
|total    |SP adjustment     |reg holes  
|# regs   |x=spimm,          |to skip    
|         |-for PUSH,        |           
|         |+for POP/POPRET   |           
|         |RV32              |RV32  
|1        | 8(1+x)           | 1    
|2        | 8(1+x)           | 0    
|3        | 8(2+x)           | 1    
|4        | 8(2+x)           | 0    
|5        | 8(3+x)           | 1    
|6        | 8(3+x)           | 0    
|7        | 8(4+x)           | 1    
|8        | 8(4+x)           | 0    
|9        | 8(5+x)           | 1    
|10       | 8(5+x)           | 0    
|11       | 8(6+x)           | 1    
|12       | 8(6+x)           | 0    
|13       | 8(7+x)           | 1    
|14       | 8(7+x)           | 0    
|15       | 8(8+x)           | 1    
|16       | 8(8+x)           | 0    
|17       | 8(9+x)           | 1    
|==============================================

[#32bit-16byte-rcount]
.Register count mapping for `PUSH/POP/POPRET` for RV32 if `eabi == 0` or for RV64 (16-byte alignment)
[options="header",width="50%"]
|==============================================
  |total  2+|SP adjustment     2+|reg holes  
  |# regs 2+|x=spimm,          2+|to skip    
  |       2+|-for PUSH,        2+|           
  |       2+|+for POP/POPRET   2+|           
  |         |RV32I    |RV64I     |RV32I|RV64I
  |1        |16(1+x)  |16(1+x)   | 3   | 1   
  |2        |16(1+x)  |16(1+x)   | 2   | 0   
  |3        |16(1+x)  |16(2+x)   | 1   | 1   
  |4        |16(1+x)  |16(2+x)   | 0   | 0   
  |5        |16(2+x)  |16(3+x)   | 3   | 1   
  |6        |16(2+x)  |16(3+x)   | 2   | 0   
  |7        |16(2+x)  |16(4+x)   | 1   | 1   
  |8        |16(2+x)  |16(4+x)   | 0   | 0   
  |9        |16(3+x)  |16(5+x)   | 3   | 1   
  |10       |16(3+x)  |16(5+x)   | 2   | 0   
  |11       |16(3+x)  |16(6+x)   | 1   | 1   
  |12       |16(3+x)  |16(6+x)   | 0   | 0   
  |13       |16(4+x)  |16(7+x)   | 3   | 1   
  |14       |16(4+x)  |16(7+x)   | 2   | 0   
  |15       |16(4+x)  |16(8+x)   | 1   | 1   
  |16       |16(4+x)  |16(8+x)   | 0   | 0   
  |17       |16(5+x)  |16(9+x)   | 3   | 1   
  |18       |16(5+x)  |16(9+x)   | 2   | 0   
  |19       |16(5+x)  |16(10+x)  | 1   | 1   
  |20       |16(5+x)  |16(10+x)  | 0   | 0   
  |21       |16(6+x)  |16(11+x)  | 3   | 1   
  |22       |16(6+x)  |16(11+x)  | 2   | 0   
  |23       |16(6+x)  |16(12+x)  | 1   | 1   
  |24       |16(6+x)  |16(12+x)  | 0   | 0   
  |25       |16(7+x)  |16(13+x)  | 3   | 1   
|==============================================

=== Register lists and assembly syntax

==== `PUSH.[E]/POP.[E]/POPRET.[E]`

The register list is a concatenation of the values from <<32bit-ra>>, <<32bit-rcount>>, <<32bit-frcount>>.
In all cases the head of the list must be one of

* `ra`
* `s0`
* `fs0`

If no registers are specified (`ra, rcount, frcount` are all zero) then take an illegal instruction exception.

This pseudo-code is valid for `PUSH/POP/POPRET`

[source,sourceCode,text]
----
reg_list = {}; //empty list
if (ra) reg_list = {ra};
if (rcount>0) {
    for (i=1; i<=rcount; i++)  reglist += {s[i-1]};  //add s registers, X numbers vary depending on ABI
}
if (frcount>0) {
    for (i=1; i<=frcount; i++) reglist += {fs[i-1]}; //add fs registers
}
----

`PUSH[.E]/POP.[E]/POPRET.[E]` have identical assembly syntax to the 16-bit encodings. The assembler will automatically choose the 16-bit encoding if possible, if not then the 32-bit encoding.

==== `PUSHINT[.E]/POPINT.[E]`

This pseudo-code is only valid for `PUSHINT/POPINT`

[source,sourceCode,text]
----
reg_list = {}; //empty list
if (ra) reg_list = {ra};
if (eabi==1) reglist += {t0-t1,a0-a3,mcause,mtval,mepc};  
else         reglist += {t0-t6,a0-a7,mcause,mtval,mepc};  
if (frcount==15) reglist += {ft0-11, fa0-7};
----
==== Assembly syntax

`PUSHINT[.E]/POPINT[.E]` take a comma separated list of arguments in braces, representing the list of registers to save/restore in a simplified form and a total stack adjustment value.
The requirements of the stack adjustment value are the same as for `PUSH[.E]/POP[.E]/POPRET[.E]` and must be enough to include the total number of registers which are saved/restored.

* optional: `ra` - whether to save/restore `ra`
* required: `m` - whether to save/restore `mcause/mtval/mepc` (not currently optional, not must always be listed)
* optional: `f` - whether to save/restore the `f` registers, the width can be 32/64-bit depending on whether D is implemented in addition to F

For example

[source,sourceCode,text]
----
pushint   {ra,m}, -160
popint    {ra,m},  160
pushint.e {ra,m}, -160
popint.e  {ra,m},  160
----

.`PUSHINT[.E]/POPINT[.E]` register list mapping for all legal argument lists
[options="header"]
|======================================================================================
| syntax                        | register list                                          
|                               |                                                        
4+|UABI 
| `PUSHINT/POPINT     {ra,m,f}` | ra, t0-t2,a0-a7,t3-t6, mcause,mtval,mepc, ft0-11,fa0-7 
| `PUSHINT/POPINT     {ra,m}`   | ra, t0-t2,a0-a7,t3-t6, mcause,mtval,mepc               
| `PUSHINT/POPINT     {m,f}`    |     t0-t2,a0-a7,t3-t6, mcause,mtval,mepc, ft0-11,fa0-7 
| `PUSHINT/POPINT     {m}`      |     t0-t2,a0-a7,t3-t6, mcause,mtval,mepc               
4+|EABI 
| `PUSHINT.E/POPINT.E {ra,m,f}` | ra, t0,a0-a3,t1,       mcause,mtval,mepc, ft0-11,fa0-7 
| `PUSHINT.E/POPINT.E {ra,m}`   | ra, t0,a0-a3,t1,       mcause,mtval,mepc               
| `PUSHINT.E/POPINT.E {m,f}`    |     t0,a0-a3,t1,       mcause,mtval,mepc, ft0-11,fa0-7 
| `PUSHINT.E/POPINT.E {m}`      |     t0,a0-a3,t1,       mcause,mtval,mepc               
|======================================================================================

.`PUSHINT/POPINT` register counts for all legal argument lists
[options="header"]
|==============================================================================================
| syntax                        | total registers 2+| total bytes  2+| minimum stack adjustment
|                               |                   | RV32 | RV64    | RV32 | RV64
6+|16-byte stack alignment - D implemented            
| `PUSHINT/POPINT {ra,m,f}`     | 39                | 236  | 312     | 240  | 320
| `PUSHINT/POPINT {m,f}`        | 38                | 232  | 304     | 240  | 304
| `PUSHINT.E/POPINT.E {ra,m,f}` | 30                | 200  | 240     | 200  | 240
| `PUSHINT.E/POPINT.E {m,f}`    | 29                | 196  | 232     | 200  | 240
6+|16-byte stack alignment - F implemented            
| `PUSHINT/POPINT {ra,m,f}`     | 39                | 156  | 232     | 160  | 240
| `PUSHINT/POPINT {m,f}`        | 38                | 152  | 224     | 160  | 224
| `PUSHINT.E/POPINT.E {ra,m,f}` | 30                | 120  | 160     | 120  | 160
| `PUSHINT.E/POPINT.E {m,f}`    | 29                | 116  | 152     | 120  | 160
6+|16-byte stack alignment - no f registers      
| `PUSHINT/POPINT {ra,m}`       | 19                |  76  | 152     |  80  | 160
| `PUSHINT/POPINT {m}`          | 18                |  72  | 144     |  80  | 144 
6+|8-byte stack alignment for RV32, 16-byte for RV64 - no f registers     
| `PUSHINT.E/POPINT.E {ra,m}`   | 10                |  40  |  80     |  40  |  80
| `PUSHINT.E/POPINT.E {m}`      |  9                |  36  |  72     |  40  |  80
|==============================================================================================


=== Exceptions

==== Legal decoding

The instructions decode as shown below. The tables are prioritised from top to bottom, like a `case` statement.

[#32bit_decode_pushpop_I]
.32-bit instruction decoding for `PUSH/POP` for RV32I/RV64I
[options="header"]
|=====================================
|eabi| ra |rcount  |frcount|decodes as
| 0  | 0  |0       |0      |*reserved*
| 0  | X  |<13     |<13    |PUSH/POP
| 0  | X  |15      |0      |PUSHINT/POPINT
| 0  | X  |15      |15     |PUSHINT/POPINT
4+| default                |*reserved*
|=====================================

[#32bit_decode_pushpop_E]
.32-bit instruction decoding for `PUSH/POP` for RV32E/RV64E
[options="header"]
|=====================================
|eabi| ra |rcount  |frcount|decodes as
| 1  | 0  |0       |0      |*reserved*
| 1  | X  |<6      |<13    |PUSH/POP
| 1  | X  |15      |0      |PUSHINT/POPINT
| 1  | X  |15      |15     |PUSHINT/POPINT
4+| default                |*reserved*
|=====================================

[#32bit_decode_popret_I]
.32-bit instruction decoding for `POPRET` for RV32I/RV64I
[options="header"]
|=====================================
|eabi| ra |rcount  |frcount|decodes as
| 0  | 0  |0       |0      |*reserved*
| 0  | X  |<13     |<13    |POPRET
4+| default                |*reserved*
|=====================================

[#32bit_decode_popret_E]
.32-bit instruction decoding for `POPRET` for RV32E/RV64E
[options="header"]
|=====================================
|eabi| ra |rcount  |frcount|decodes as
| 1  | 0  |0       |0      |*reserved*
| 1  | X  |<6      |<13    |POPRET
4+| default                |*reserved*
|=====================================

If `frcount > 0` then the `F` extension must be implemented without `Zfinx` for legal decoding.

==== Stack Pointer Misalignment

The rules are the same as for the 16-bit encodings - see <<sp-misalign>>.

== Instruction sequences

The rules are the same as for the 16-bit encodings, see <<instruction-sequences>>.

In the tables:

* `N` is the stack pointer adjustment value from <<32bit-8byte-rcount>> and <<32bit-16byte-rcount>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV64

=== `PUSH/POP/POPRET` sequences

The tables assume the `f` registers are 32-bit. If they are wider then different instructions will be used to access them (`DLW/DSW`) and the offsets will scale accordingly.

[#cpush_sequence]
.`PUSH` sequence, for `PUSH.E` `rcount<6` and `spimm` is 8-byte aligned
[options="header",width=50%]
|===============================================================================
| C.PUSH step                               |Execute if
| fsw f27, (-(ra+rcount+11)*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f26, (-(ra+rcount+10)*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f25, (-(ra+rcount+9 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f24, (-(ra+rcount+8 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f23, (-(ra+rcount+7 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f22, (-(ra+rcount+6 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f21, (-(ra+rcount+5 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f20, (-(ra+rcount+4 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f19, (-(ra+rcount+3 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f18, (-(ra+rcount+2 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f9,  (-(ra+rcount+1 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f8,  (-(ra+rcount   )*M)(x2)          |frcount>=1 && frcount<13 && rcount<13
2+|RV32D may require 4-byte padding at this point if `ra+rcount` is odd, so the `f` registers are aligned, TBD
| sw x27,  (-(ra+12)*M)(x2)                 |rcount>=12 && rcount<13
| sw x26,  (-(ra+11)*M)(x2)                 |rcount>=11 && rcount<13
| sw x25,  (-(ra+10)*M)(x2)                 |rcount>=10 && rcount<13
| sw x24,  (-(ra+ 9)*M)(x2)                 |rcount>=9  && rcount<13
| sw x23,  (-(ra+ 8)*M)(x2)                 |rcount>=8  && rcount<13
| sw x22,  (-(ra+ 7)*M)(x2)                 |rcount>=7  && rcount<13
| sw x21,  (-(ra+ 6)*M)(x2)                 |rcount>=6  && rcount<13
| sw x20,  (-(ra+ 5)*M)(x2)                 |rcount>=5  && rcount<13
| sw x19,  (-(ra+ 4)*M)(x2)                 |rcount>=4  && rcount<13
| sw x18,  (-(ra+ 3)*M)(x2)                 |rcount>=3  && rcount<13
| sw x9,   (-(ra+ 2)*M)(x2)                 |rcount>=2  && rcount<13
| sw x8,   (-(ra+ 1)*M)(x2)                 |rcount>=1  && rcount<13
| sw x1,   (-1*M) (x2)                      |ra==1 
| addi x2, x2,  -N                          |1 
|===============================================================================

.`POP/POPRET` sequence, for `POP.E/POPRET.E` `rcount<6` and `spimm` is 8-byte aligned
[options="header",width=50%]
|===============================================================================
| C.POP[.E]/C.POPRET step                      |Execute if
| fsw f27, (-(ra+rcount+11)*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f26, (-(ra+rcount+10)*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f25, (-(ra+rcount+9 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f24, (-(ra+rcount+8 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f23, (-(ra+rcount+7 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f22, (-(ra+rcount+6 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f21, (-(ra+rcount+5 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f20, (-(ra+rcount+4 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f19, (-(ra+rcount+3 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f18, (-(ra+rcount+2 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f9,  (-(ra+rcount+1 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f8,  (-(ra+rcount   )*M+N)(x2)       |frcount>=1 && frcount<13 && rcount<13
2+|*RV32D may require 4-byte padding at this point if `ra+rcount` is odd, so the `f` registers are aligned, TBD*
| sw x27,  (-(ra+12)*M+N)(x2)              |rcount>=12 && rcount<13
| sw x26,  (-(ra+11)*M+N)(x2)              |rcount>=11 && rcount<13
| sw x25,  (-(ra+10)*M+N)(x2)              |rcount>=10 && rcount<13
| sw x24,  (-(ra+ 9)*M+N)(x2)              |rcount>=9  && rcount<13
| sw x23,  (-(ra+ 8)*M+N)(x2)              |rcount>=8  && rcount<13
| sw x22,  (-(ra+ 7)*M+N)(x2)              |rcount>=7  && rcount<13
| sw x21,  (-(ra+ 6)*M+N)(x2)              |rcount>=6  && rcount<13
| sw x20,  (-(ra+ 5)*M+N)(x2)              |rcount>=5  && rcount<13
| sw x19,  (-(ra+ 4)*M+N)(x2)              |rcount>=4  && rcount<13
| sw x18,  (-(ra+ 3)*M+N)(x2)              |rcount>=3  && rcount<13
| sw x9,   (-(ra+ 2)*M+N)(x2)              |rcount>=2  && rcount<13
| sw x8,   (-(ra+ 1)*M+N)(x2)              |rcount>=1  && rcount<13
| sw x1,   (-1*M+N) (x2)                   |ra==1 
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================

=== `PUSHINT/POPINT` example sequences

The use of `x15` in the sequences is arbitrary, any register could be used other than `x0`. 
The `PUSHINT` instruction does not trash any register state, so the value of `x15` is always restored in the sequences.
The sequences are included to show how existing RISC-V instructions can be used to execute the proposed instructions.
The actual handling of the CSR data is implementation defined, so an `x` register does not actually need to be used,  If the sequence is interrupted
for any reason none of the registers change state so that the sequence can be re-executed. See <<instruction-sequences>> for the rules.

.`PUSHINT` sequence 
[options="header",width=50%]
|===============================================================================
| PUSHINT STEP                                |Execute if
| fsw f27, (-(ra+30)*M)(x2)                   |frcount==15 && rcount==14
| fsw f26, (-(ra+29)*M)(x2)                   |frcount==15 && rcount==14
| fsw f25, (-(ra+28)*M)(x2)                   |frcount==15 && rcount==14
| fsw f24, (-(ra+27)*M)(x2)                   |frcount==15 && rcount==14
| fsw f23, (-(ra+26)*M)(x2)                   |frcount==15 && rcount==14
| fsw f22, (-(ra+25)*M)(x2)                   |frcount==15 && rcount==14
| fsw f21, (-(ra+24)*M)(x2)                   |frcount==15 && rcount==14
| fsw f20, (-(ra+23)*M)(x2)                   |frcount==15 && rcount==14
| fsw f19, (-(ra+22)*M)(x2)                   |frcount==15 && rcount==14
| fsw f18, (-(ra+21)*M)(x2)                   |frcount==15 && rcount==14
| fsw f9,  (-(ra+20)*M)(x2)                   |frcount==15 && rcount==14
| fsw f8,  (-(ra+19)*M)(x2)                   |frcount==15 && rcount==14
2+|*RV32D may require 4-byte padding at this point if `ra+rcount+3` is odd, so the `f` registers are aligned, TBD*
| sw x15,  (-(ra+ 9)*M)(x2)                   |rcount==14
| csrr x15, mepc;   sw x15,  (-(ra+18)*M)(x2) |rcount==14
| csrr x15, mtval;  sw x15,  (-(ra+17)*M)(x2) |rcount==14
| csrr x15, mcause; sw x15,  (-(ra+16)*M)(x2) |rcount==14
| sw x31,  (-(ra+15)*M)(x2)                   |rcount==14
| sw x30,  (-(ra+14)*M)(x2)                   |rcount==14
| sw x29,  (-(ra+13)*M)(x2)                   |rcount==14
| sw x28,  (-(ra+12)*M)(x2)                   |rcount==14
| sw x17,  (-(ra+11)*M)(x2)                   |rcount==14
| sw x16,  (-(ra+10)*M)(x2)                   |rcount==14
2+|*restore x15 so that the state isn't trashed by the sequence*
| lw x15,  (-(ra+ 9)*M)(x2)                   |rcount==14
| sw x14,  (-(ra+ 8)*M)(x2)                   |rcount==14
| sw x13,  (-(ra+ 7)*M)(x2)                   |rcount==14
| sw x12,  (-(ra+ 6)*M)(x2)                   |rcount==14
| sw x11,  (-(ra+ 5)*M)(x2)                   |rcount==14
| sw x10,  (-(ra+ 4)*M)(x2)                   |rcount==14
| sw x7,   (-(ra+ 3)*M)(x2)                   |rcount==14
| sw x6,   (-(ra+ 2)*M)(x2)                   |rcount==14
| sw x5,   (-(ra+ 1)*M)(x2)                   |rcount==14
| sw x1,   (-1*M) (x2)                        |ra==1 
| addi x2, x2,  -N                            |1
|===============================================================================

.`PUSHINT.E` sequence 
[options="header",width=50%]
|===============================================================================
| PUSHINT STEP                               |Execute if
| fsw f27, (-(ra+21)*M)(x2)                  |frcount==15 && rcount==15
| fsw f26, (-(ra+20)*M)(x2)                  |frcount==15 && rcount==15
| fsw f25, (-(ra+19)*M)(x2)                  |frcount==15 && rcount==15
| fsw f24, (-(ra+18)*M)(x2)                  |frcount==15 && rcount==15
| fsw f23, (-(ra+17)*M)(x2)                  |frcount==15 && rcount==15
| fsw f22, (-(ra+16)*M)(x2)                  |frcount==15 && rcount==15
| fsw f21, (-(ra+15)*M)(x2)                  |frcount==15 && rcount==15
| fsw f20, (-(ra+14)*M)(x2)                  |frcount==15 && rcount==15
| fsw f19, (-(ra+13)*M)(x2)                  |frcount==15 && rcount==15
| fsw f18, (-(ra+12)*M)(x2)                  |frcount==15 && rcount==15
| fsw f9,  (-(ra+11)*M)(x2)                  |frcount==15 && rcount==15
| fsw f8,  (-(ra+10)*M)(x2)                  |frcount==15 && rcount==15
2+|*RV32D may require 4-byte padding at this point if `ra+rcount+3` is odd, so the `f` registers are aligned, TBD*
| sw x15,  (-(ra+ 6)*M)(x2)                   |rcount==15
| csrr x15, mepc;   sw x15,  (-(ra+9)*M)(x2) |rcount==15
| csrr x15, mtval;  sw x15,  (-(ra+8)*M)(x2) |rcount==15
| csrr x15, mcause; sw x15,  (-(ra+7)*M)(x2) |rcount==15
2+|*restore x15 so that the state isn't trashed by the sequence*
| lw x15,  (-(ra+ 6)*M)(x2)                  |rcount==15
| sw x13,  (-(ra+ 5)*M)(x2)                  |rcount==15
| sw x12,  (-(ra+ 4)*M)(x2)                  |rcount==15
| sw x11,  (-(ra+ 3)*M)(x2)                  |rcount==15
| sw x10,  (-(ra+ 2)*M)(x2)                  |rcount==15
| sw x5,   (-(ra+ 1)*M)(x2)                  |rcount==15
| sw x1,   (-1*M) (x2)                       |ra==1 
| addi x2, x2,  -N                           |1
|===============================================================================

.`POPINT` sequence 
[options="header",width=50%]
|===============================================================================
| POPINT STEP                                   |Execute if
| flw f27, (-(ra+30)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f26, (-(ra+29)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f25, (-(ra+28)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f24, (-(ra+27)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f23, (-(ra+26)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f22, (-(ra+25)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f21, (-(ra+24)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f20, (-(ra+23)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f19, (-(ra+22)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f18, (-(ra+21)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f9,  (-(ra+20)*M+N)(x2)                   |frcount==15 && rcount==15
| flw f8,  (-(ra+19)*M+N)(x2)                   |frcount==15 && rcount==15
2+|*RV32D may require 4-byte padding at this point if `ra+rcount+3` is odd, so the `f` registers are aligned, TBD*
| lw x15,  (-(ra+18)*M+N)(x2); csrw mepc,   x15 |rcount==15
| lw x15,  (-(ra+17)*M+N)(x2); csrw mtval,  x15 |rcount==15
| lw x15,  (-(ra+16)*M+N)(x2); csrw mcause, x15 |rcount==15
| lw x31,  (-(ra+15)*M+N)(x2)                   |rcount==15
| lw x30,  (-(ra+14)*M+N)(x2)                   |rcount==15
| lw x29,  (-(ra+13)*M+N)(x2)                   |rcount==15
| lw x28,  (-(ra+12)*M+N)(x2)                   |rcount==15
| lw x17,  (-(ra+11)*M+N)(x2)                   |rcount==15
| lw x16,  (-(ra+10)*M+N)(x2)                   |rcount==15
| lw x15,  (-(ra+ 9)*M+N)(x2)                   |rcount==15
| lw x14,  (-(ra+ 8)*M+N)(x2)                   |rcount==15
| lw x13,  (-(ra+ 7)*M+N)(x2)                   |rcount==15
| lw x12,  (-(ra+ 6)*M+N)(x2)                   |rcount==15
| lw x11,  (-(ra+ 5)*M+N)(x2)                   |rcount==15
| lw x10,  (-(ra+ 4)*M+N)(x2)                   |rcount==15
| lw x7,   (-(ra+ 3)*M+N)(x2)                   |rcount==15
| lw x6,   (-(ra+ 2)*M+N)(x2)                   |rcount==15
| lw x5,   (-(ra+ 1)*M+N)(x2)                   |rcount==15
| lw x1,   (-1*M) (x2)                          |ra==1 
| addi x2, x2,  -N                              |1
|===============================================================================

.`POPINT.E` sequence 
[options="header",width=50%]
|===============================================================================
| POPINT STEP                                    |Execute if
| flw f27,  (-(ra+21)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f26,  (-(ra+20)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f25,  (-(ra+19)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f24,  (-(ra+18)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f23,  (-(ra+17)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f22,  (-(ra+16)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f21,  (-(ra+15)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f20,  (-(ra+14)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f19,  (-(ra+13)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f18,  (-(ra+12)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f9,   (-(ra+11)*M+N)(x2)                   |frcount==15 && rcount>13
| flw f8,   (-(ra+10)*M+N)(x2)                   |frcount==15 && rcount>13
2+|*RV32D may require 4-byte padding at this point if `ra+rcount+3` is odd, so the `f` registers are aligned, TBD*
| lw x15,   (-(ra+ 9)*M+N)(x2); csrw mepc,   x15 |rcount==15
| lw x15,   (-(ra+ 8)*M+N)(x2); csrw mtval,  x15 |rcount==15
| lw x15,   (-(ra+ 7)*M+N)(x2); csrw mcause, x15 |rcount==15
| lw x15,   (-(ra+ 6)*M+N)(x2)                   |rcount==15
| lw x13,   (-(ra+ 5)*M+N)(x2)                   |rcount==15
| lw x12,   (-(ra+ 4)*M+N)(x2)                   |rcount==15
| lw x11,   (-(ra+ 3)*M+N)(x2)                   |rcount==15
| lw x10,   (-(ra+ 2)*M+N)(x2)                   |rcount==15
| lw x5,    (-(ra+ 1)*M+N)(x2)                   |rcount==15
| lw x1,    (-1*M) (x2)                          |ra==1 
| addi x2, x2,  -N                               |1
|===============================================================================


=== Assembler Examples

==== PUSH RV32

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw fs0,-28(sp)
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra,  -4(sp);
addi sp, sp, -64;
----

==== PUSH RV64

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw fs0,-56(sp)
sw  s4, -48(sp); sw  s3, -40(sp);
sw  s2, -32(sp); sw  s1, -24(sp);
sw  s0, -16(sp); sw  ra,  -8(sp);
addi sp, sp, -64;
----

==== PUSH.E RV32

[source,sourceCode,text]
----
push.e  {fs0-s11}, -128
----

Encoding: eabi=1, rcount=0, frcount=12, spimm=10 (8-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw  fs11,-48(sp); fsw  fs10,-44(sp);
fsw  fs9, -40(sp); fsw  fs8, -36(sp);
fsw  fs7, -32(sp); fsw  fs6, -28(sp);
fsw  fs5, -24(sp); fsw  fs4, -20(sp);
fsw  fs3, -16(sp); fsw  fs2, -12(sp);
fsw  fs1,  -8(sp); fsw  fs0,  -4(sp);
addi sp, sp, -128;
----

==== PUSH RV64

[source,sourceCode,text]
----
push  {fs0-s11}, -128
----

Encoding: eabi=0, rcount=0, frcount=12, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw  fs11,-96(sp); fsw  fs10,-88(sp);
fsw  fs9, -80(sp); fsw  fs8, -72(sp);
fsw  fs7, -64(sp); fsw  fs6, -56(sp);
fsw  fs5, -48(sp); fsw  fs4, -40(sp);
fsw  fs3, -32(sp); fsw  fs2, -24(sp);
fsw  fs1, -16(sp); fsw  fs0,  -8(sp);
addi sp, sp, -128;
----

==== PUSHINT RV32

[source,sourceCode,text]
----
pushint  {ra,x,m}, -160
----

Encoding: eabi=0, rcount=14, frcount=0, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sw  x15, -40(sp);
csrr x15, mepc;   sw x15, -76(sp)
csrr x15, mtval;  sw x15, -72(sp)
csrr x15, mcause; sw x15, -68(sp)
sw  x31, -64(sp); sw  x30, -60(sp);
sw  x29, -56(sp); sw  x28, -52(sp);
sw  x17, -48(sp); sw  x16, -44(sp);
lw  x15, -40(sp); sw  x14, -36(sp);
sw  x13, -32(sp); sw  x12, -28(sp);
sw  x11, -24(sp); sw  x10, -20(sp);
sw   x7, -16(sp); sw   x6, -12(sp);
sw   x5,  -8(sp); sw   x1,  -4(sp);
addi sp, sp, -64;
----

==== POP RV32I UABI

[source,sourceCode,text]
----
pop   {x1, x8-x9, x18-x25}, 256
----

Encoding: eabi=0, ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw  x25, 212(sp);  lw  x24, 216(sp);
lw  x23, 220(sp);  lw  x22, 224(sp)
lw  x21, 228(sp);  lw  x20, 232(sp);
lw  x19, 236(sp);  lw  x18, 240(sp)
lw   x9, 244(sp);  lw   x8, 248(sp);
lw   x1, 252(sp);
addi sp, sp, 256
----

==== POPRET RV32I UABI

[source,sourceCode,text]
----
popret   {x1, x8-x9, x18-x19, f8-f9}, 32
----

Encoding: eabi=0, ra=1, rcount=4, frcount=2, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
flw  f9,  4(s0);  flw  f8,  8(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
lw   x1, 28(sp);
addi sp, sp, 32; ret
----

==== POPRET RV32I EABI

[source,sourceCode,text]
----
popret.e  {x1, x8-x9, f8-f9}, 32
----

Encoding: eabi=1, rcount=2, frcount=2, spimm=1 (8-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
flw  f9, 12(s0);  flw  f8, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
lw   x1, 28(sp);
addi sp, sp, 32; ret
----
