= RISC-V Push/Pop Extension
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 32-bit and 16-bit encodings for `[C.]PUSH[.E]`,
`[C.]POP[.E]` and `[C.]POPRET[.E]` instructions for RV32 and RV64,
architectures, I and E variants.

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

- `POPRET` with `rcount=15` is not useful so should be illegal. Because these cases are for the interrupt handler entry/exit a different mnemonic would make sense like `PUSHINT/POPINT` for example
- should `PUSHINT/POPINT` have the option to avoid saving/restoring `ra`? Should this be an option in general? it could be an extra bit in the 32-bit encoding, or maybe allocated some new rcount values to save (for example) `s0,s0-1,s0-2` without `ra`
- shoudl `PUSHINT/POPINT` also save/restore some CSRs e.g. `MCAUSE/MEPC/MTVAL` to save more code size, and so allow uarch tricks to save cycles?
- need to review usage of register lists, and make sure the proposal matches load/store multiple requirements
- UABI/EABI versions take too much encoding space, need to review them carefully to be clearer about what the proposal is trying to achieve
-- e.g. do we _really_ need to change the stack alignment between the two? Can we use a CSR bit to distinguish and save a bit in the encoding? CSR state is cheaper.



== Rationale

`[C.]PUSH[.E]/[C.]POP[.E]/[C.]POPRET[.E]` are designed to replace the
most commonly called functions generated by the compiler using
_–m-save-restore_. When the _–msave-restore_ option is used the compiler
replaces the sequence of stores plus `sp` decrement operation required
to spill/push registers to the stack with a call to a shared co-routine
that performs this operation. In addition the equivalent fill/pop
sequence is replaced with a jump to a shared co-routine (which then
performs the return to the caller of the function). The code savings can
be significant (provided that the co-routine jump/calls can be encoded
in a single 32-bit instruction) but the run-time overhead is high as an
additional 3 jumps are required for each push/pop sequence; in addition
the shared save/restore routines include redundant memory operations
when the number of registers to spill is not a multiple of 4.

The most useful forms of these instructions are the 16-bit encodings, as
these give the largest code size reduction, whilst covering the vast
majority of useful cases.

== 16-bit encodings

=== `C.PUSH[.E]` instruction

`C.PUSH[.E]` which allows most spill sequences to only take 16-bits of
code space instead of 32-bits for the call to the save routine (or in
some cases 64-bits if the target function is too far away).

=== `C.POP[.E]` instruction

`C.POP[.E]` which allows most fill sequences to be performed with two
16-bit instructions (`C.POP+RET` ) which matches the cost of the
co-routine jump (for jumps <1Mbyte) but with significantly better
performance.

=== `C.POPRET[.E]` instructions

`C.POPRET[.E]` which allows both the `C.POP[.E]` and `RET` to be
performed in a single instruction saving 16-bits of code with respect to
a `C.POP[.E]+RET` or a jump to a restore co-routine.

=== Opcode Assignment

=== `C.PUSH[.E]` Operation


.proposed encoding
[width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction

17+|*These replace reserved encodings, PUSH/POP with support for UABI and EABI*

3+|100|1|0 4+|rcount|0|0 3+|spimm 2+|00|C.POP
3+|100|1|0 4+|rcount|0|1 3+|spimm 2+|00|C.POPRET
3+|100|1|0 4+|rcount|1|0 3+|spimm 2+|00|C.PUSH
3+|100|1|1 4+|rcount|0|0 3+|spimm 2+|00|C.POP.E
3+|100|1|1 4+|rcount|0|1 3+|spimm 2+|00|C.POPRET.E
3+|100|1|1 4+|rcount|1|0 3+|spimm 2+|00|C.PUSH.E
|=======================================================================

Notes

* [11] is `eabi` which distinguishes between the `C.POP` (UABI) and
`C.POP.E` (EABI) versions
* [15:13] and [1:0] identify the encoding within the 16-bit encoding
space.
* The `spimm` field is an unsigned immediate that indicates the number
of additional _n_-byte blocks to adjust the stack pointer by. See <<spimm-table>>
and <<rcount-table>>
* RV32I, RV64I can use either ABI (UABI or EABI), but it is optional to
implement the `.E` variants
* RV32E UABI, RV64E UABI are not supported configurations, these should
only use the `.E` variants
* RV64E is not currently in the RISC-V standard, but may be included in
the future so it is fully included in this specification
* For UABI documentation see Chapter 20 of
http://riscv.org/specifications/isa-spec-pdf[The RISC-V ISA
specification]
* For the EABI, see this
https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc[proposal]


[#spimm-table]
.`spimm` and register holes for different architectures and ABIs
[options="header"]
|=======================================================================
|arch+ABI |spimm _n_ |total stack adjustment for _r_ registers |register holes to skip
|RV32[IE] EABI |8 |adjust = 8*((r+1)/2+spimm) |holes = r mod 2

|RV32I UABI |16 |adjust = 16*((r+3)/4+spimm) |holes = 3-((r+3) mod 4)

|RV64I UABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2

|RV64[IE] EABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2
|=======================================================================

The purpose of `spimm` is to allow a function to allocate additional
space on the stack for automatic variables without having to perform an
additional stack adjustment (and therefore save more code size).

The encodings contain no explicit register index fields as the memory
accesses and pointer increments are all based on the stack pointer
register as defined in the standard RISC-V ABIs `sp` and the registers
to be loaded/stored are specified using the `rcount` field (see
<<rcount-table>>)

The behaviour of each value of `rcount`, `eabi` and `spimm` is shown in
<<rcount-table>>.

[#rcount-table]
.UABI `rcount` values for different architectures
[options="header"]
|==================================================================================================
|eabi|rcount| ABI names            4+|Stack pointer adjustment      4+|reg holes to skip          
|    |      |                      4+|x=spimm -for PUSH, +for POP   4+|                           
|    |      |                        |RV32I  |RV64I  |RV32E  |RV64E   |RV32I|RV64I|RV32E|RV64E    
11+| *UABI only, may give the wrong result if the EABI is in use*                                                           
|0   |0     |ra                      |16(1+x)|16(1+x) 2+|*reserved*   | 3   | 1   2+|*reserved*    
|0   |1     |ra, s0                  |16(1+x)|16(1+x) 2+|*reserved*   | 2   | 0   2+|*reserved*    
|0   |2     |ra, s0-s1               |16(1+x)|16(2+x) 2+|*reserved*   | 1   | 1   2+|*reserved*    
|0   |3     |ra, s0-s2               |16(1+x)|16(2+x) 2+|*reserved*   | 0   | 0   2+|*reserved*    
|0   |4     |ra, s0-s3               |16(2+x)|16(3+x) 2+|*reserved*   | 3   | 1   2+|*reserved*    
|0   |5     |ra, s0-s4               |16(2+x)|16(3+x) 2+|*reserved*   | 2   | 0   2+|*reserved*    
|0   |6     |ra, s0-s5               |16(2+x)|16(4+x) 2+|*reserved*   | 1   | 1   2+|*reserved*    
|0   |7     |ra, s0-s6               |16(2+x)|16(4+x) 2+|*reserved*   | 0   | 0   2+|*reserved*    
|0   |8     |ra, s0-s7               |16(3+x)|16(5+x) 2+|*reserved*   | 3   | 1   2+|*reserved*    
|0   |9     |ra, s0-s8               |16(3+x)|16(5+x) 2+|*reserved*   | 2   | 0   2+|*reserved*    
|0   |10    |ra, s0-s9               |16(3+x)|16(6+x) 2+|*reserved*   | 1   | 1   2+|*reserved*    
|0   |11    |ra, s0-s10              |16(3+x)|16(6+x) 2+|*reserved*   | 0   | 0   2+|*reserved*    
|0   |12    |ra, s0-s11              |16(4+x)|16(7+x) 2+|*reserved*   | 3   | 1   2+|*reserved*    
|0   |13-14 9+|*reserved*
11+| *Save/restore all caller save registers and allocate stack space for entry into an interrupt handler*                                                           
|0   |15    |ra,t0-t2, a0-a7, t3-t6  |16(4+x)|16(8+x) 2+|*reserved*   | 0   | 0   2+|*reserved*    
|==================================================================================================

.EABI `rcount` values for different architectures
[options="header"]
|==================================================================================================
|eabi|rcount| ABI names            4+|Stack pointer adjustment      4+|reg holes to skip          
|    |      |                      4+|x=spimm -for PUSH, +for POP   4+|                           
|    |      |                        |RV32I  |RV64I  |RV32E  |RV64E   |RV32I|RV64I|RV32E|RV64E    
11+| *EABI only, may give the wrong result if the UABI is in use*                                                           

|1   |0     |ra                      | 8(1+x)|16(1+x)| 8(1+x)|16(1+x) 4+| 1
|1   |1     |ra, s0                  | 8(1+x)|16(1+x)| 8(1+x)|16(1+x) 4+| 0
|1   |2     |ra, s0-s1               | 8(2+x)|16(2+x)| 8(2+x)|16(2+x) 4+| 1
|1   |3     |ra, s0-s2               | 8(2+x)|16(2+x)| 8(2+x)|16(2+x) 4+| 0
|1   |4     |ra, s0-s3               | 8(3+x)|16(3+x)| 8(3+x)|16(3+x) 4+| 1
|1   |5     |ra, s0-s4               | 8(3+x)|16(3+x)| 8(3+x)|16(3+x) 4+| 0
|1   |6-14 9+|*reserved*
11+| *Save/restore all caller save registers and allocate stack space for entry into an interrupt handler*                                                           
|1   |15    |ra, t0, a0-3, t1        | 8(4+x)|16(4+x)| 8(4+x)|16(4+x) 4+| 1
|==================================================================================================

[NOTE]
 `rcount=15` is to save/restore the caller registers for the interrupt handler. 
 
CAUTION: `ra, s0-s1` map to the same X registers in UABi and EABI, but `s2-s4` are different, so the instructions behave differently

A `C.PUSH[.E]` instruction writes the set of registers selected by
_rcount_ to memory, the registers are written to the memory immediately
below the current stack pointer. The last register in the list stored to
the lowest memory location to be written by the `C.PUSH[.E]`

[source,sourceCode,text]
----
sp-(XLEN/8)*r
----

where _r_ is the number registers to store (the second column from
<<rcount-table>>)

The selected registers are written to contiguous incrementing
(XLEN/8)-byte words starting with the register in the reverse of the
order shown in <<rcount-table>> above (ra is always stored last).

Once all stores have completed the stack pointer register `sp` is
decremented by the stack adjustment value from <<spimm-table>> and
<<rcount-table>>.

Note that _spimm_ allows up to an additional bytes of stack to be
allocated for automatic variables without having to issue additional
stack manipulation instructions.

Also note that the stores can happen in any order, and may also be
combined into wider stores as they access a continuous block of memory.

=== Suggested `C.PUSH[.E]` UOP sequences

The exact implementation will vary, this is one possible set of
sequences of UOPs (micro-ops) which can be used to implement
`C.PUSH[.E]`

The `sp` adjustment is made first to allocate space before storing to
memory, so that if the sequence is interrupted/resumed then the stack
memory has already been reserved. Therefore the interrupt handler is
able to allocate more stack space without affecting the interrupted
instruction. It also is possible to increment the stack pointer
afterwards instead, and adjust the store addresses accordingly.

In the tables:

* `N` is the stack pointer adjustment value from  <<rcount-table>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV64

.UOPs for ``C.PUSH`` if ``rcount<=12``
[options="header",width=50%]
|===============================================================================
| C.PUSH UOP                                |Execute if
| addi x2, x2,  -N                          |1 
| sw x27,  (-13*M+N)(x2)                    |rcount==12
| sw x26,  (-12*M+N)(x2)                    |rcount<=12 && rcount>=11
| sw x25,  (-11*M+N)(x2)                    |rcount<=12 && rcount>=10
| sw x24,  (-10*M+N)(x2)                    |rcount<=12 && rcount>=9
| sw x23,  ( -9*M+N)(x2)                    |rcount<=12 && rcount>=8
| sw x22,  ( -8*M+N)(x2)                    |rcount<=12 && rcount>=7
| sw x21,  ( -7*M+N)(x2)                    |rcount<=12 && rcount>=6
| sw x20,  ( -6*M+N)(x2)                    |rcount<=12 && rcount>=5
| sw x19,  ( -5*M+N)(x2)                    |rcount<=12 && rcount>=4
| sw x18,  ( -4*M+N)(x2)                    |rcount<=12 && rcount>=3
| sw x9,   ( -3*M+N)(x2)                    |rcount<=12 && rcount>=2
| sw x8,   ( -2*M+N)(x2)                    |rcount<=12 && rcount>=1
| sw x1,   ( -1*M+N)(x2)                    |1 
|===============================================================================

.UOPs for ``C.PUSH`` if ``rcount==15``
[options="header",width=50%]
|===============================================================================
| C.PUSH UOP                                |Execute if
| addi x2, x2,  -N                          |1
| sw x31,  (-16*M+N)(x2)                    |rcount==15
| sw x30,  (-15*M+N)(x2)                    |rcount==15
| sw x29,  (-14*M+N)(x2)                    |rcount==15
| sw x28,  (-13*M+N)(x2)                    |rcount==15
| sw x17,  (-12*M+N)(x2)                    |rcount==15
| sw x16,  (-11*M+N)(x2)                    |rcount==15
| sw x15,  (-10*M+N)(x2)                    |rcount==15
| sw x14,  ( -9*M+N)(x2)                    |rcount==15
| sw x13,  ( -8*M+N)(x2)                    |rcount==15
| sw x12,  ( -7*M+N)(x2)                    |rcount==15
| sw x11,  ( -6*M+N)(x2)                    |rcount==15
| sw x10,  ( -5*M+N)(x2)                    |rcount==15
| sw x7,   ( -4*M+N)(x2)                    |rcount==15
| sw x6,   ( -3*M+N)(x2)                    |rcount==15
| sw x5,   ( -2*M+N)(x2)                    |rcount==15
| sw x1,   ( -1*M+N)(x2)                    |1
|===============================================================================

.UOPs for ``C.PUSH.E`` if ``rcount<=5``
[options="header",width=50%]
|===============================================================================
|C.PUSH.E UOP                             |Execute if
|addi x2, x2,  -N                         |1
|sw x7,   (-6*M+N)(x2)                    |rcount==5
|sw x6,   (-5*M+N)(x2)                    |rcount<=5 && rcount>=4
|sw x14,  (-4*M+N)(x2)                    |rcount<=5 && rcount>=3
|sw x9,   (-3*M+N)(x2)                    |rcount<=5 && rcount>=2
|sw x8,   (-2*M+N)(x2)                    |rcount<=5 && rcount>=1
|sw x1,   (-1*M+N)(x2)                    |1
|===============================================================================

.UOPs for ``C.PUSH.E`` if ``rcount==15``
[options="header",width=50%]
|===============================================================================
| C.PUSH.E UOP                            | Execute if
| addi x2, x2,  -N                        | 1
| sw x15,  (-7*M+N)(x2)                   | rcount==15
| sw x13,  (-6*M+N)(x2)                   | rcount==15
| sw x12,  (-5*M+N)(x2)                   | rcount==15
| sw x11,  (-4*M+N)(x2)                   | rcount==15
| sw x10,  (-3*M+N)(x2)                   | rcount==15
| sw x5,   (-2*M+N)(x2)                   | rcount==15
| sw x1,   (-1*M+N)(x2)                   | 1
|===============================================================================


=== `C.POP[.E]/C.POPRET[.E]` Operation

A `C.POP[.E]/C.POPRET[.E]` instruction loads the set of registers
selected by _rcount_ from the memory. The loads start at the lowest
memory location to be read by the `C.POP[.E]/C.POPRET[.E]`. To get to
that location the stack pointer is first incremented by the scaled value
of `spimm` from <<spimm-table>>, and then incremented by the number of holes
required to mantain the stack alignment (see <<spimm-table>> and  <<rcount-table>>).

The selected registers are loaded from contiguous incrementing
(XLEN/8)-byte words in the reverse of the order shown in  <<rcount-table>>
above (ra is always loaded last).

See <<spimm-table>> for stack increment calculations for all architectures.

Once all loads have completed the stack pointer register `sp` is
incremented by the stack adjustment value from <<spimm-table>> and
 <<rcount-table>>, placing it immediately above the block of memory read
by the `C.POP[.E]/C.POPRET[.E]` instruction.

`C.POPRET[.E]` executes a `RET` as the final step in the sequence

Note that the loads can happen in any order, and may also be combined
into wider loads as they access a continuous block of memory.

=== Suggested C.POP[.E]/C.POPRET[.E] UOP sequences

The exact implementation will vary, this is one possible set of
sequences of UOPs (micro-ops) which can be used to implement
`C.POP[.E]/C.POPRET[.E]`

The `sp` adjustment is made last to deallocate space after loading from
memory, so that if the sequence is interrupted/resumed then the stack
memory is still reserved so that the interrupt handler is able to
allocate stack space and write to the stack without affecting the
interrupted instruction. It is possible to increment the stack pointer
afterwards instead, and adjust the load addresses accordingly.

In the tables:
* `N` is the stack pointer adjustment value from  <<rcount-table>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV6
4

`ra` is loaded early for performance because the value is needed by
`ret`. This may complicate burst reads from memory so may not be a
performance advantage.

.UOPs for ``C.POP/C.POPRET`` if ``rcount<=12``
[options="header",width=50%]
|===============================================================================
| C.POP/C.POPRET UOP                       |Execute if
| lw x1,   (-1*M+N)(x2)                    |1
| lw x27,  (-13*M+N)(x2)                   |rcount==12
| lw x26,  (-12*M+N)(x2)                   |rcount<=12 && rcount>=11
| lw x25,  (-11*M+N)(x2)                   |rcount<=12 && rcount>=10
| lw x24,  (-10*M+N)(x2)                   |rcount<=12 && rcount>=9
| lw x23,  (-9*M+N)(x2)                    |rcount<=12 && rcount>=8
| lw x22,  (-8*M+N)(x2)                    |rcount<=12 && rcount>=7
| lw x21,  (-7*M+N)(x2)                    |rcount<=12 && rcount>=6
| lw x20,  (-6*M+N)(x2)                    |rcount<=12 && rcount>=5
| lw x19,  (-5*M+N)(x2)                    |rcount<=12 && rcount>=4
| lw x18,  (-4*M+N)(x2)                    |rcount<=12 && rcount>=3
| lw x9,   (-3*M+N)(x2)                    |rcount<=12 && rcount>=2
| lw x8,   (-2*M+N)(x2)                    |rcount<=12 && rcount>=1
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================

.UOPs for ``C.POP/C.POPRET`` if ``rcount==15``
[options="header",width=50%]
|===============================================================================
| C.POP/C.POPRET UOP                       |Execute if
| lw x1,   (-1*+N)(x2)                     |1
| lw x31,  (-16*+N)(x2)                    |rcount==15
| lw x30,  (-15*+N)(x2)                    |rcount==15
| lw x29,  (-14*+N)(x2)                    |rcount==15
| lw x28,  (-13*+N)(x2)                    |rcount==15
| lw x17,  (-12*+N)(x2)                    |rcount==15
| lw x16,  (-11*+N)(x2)                    |rcount==15
| lw x15,  (-10*+N)(x2)                    |rcount==15
| lw x14,  (-9*+N)(x2)                     |rcount==15
| lw x13,  (-8*+N)(x2)                     |rcount==15
| lw x12,  (-7*+N)(x2)                     |rcount==15
| lw x11,  (-6*+N)(x2)                     |rcount==15
| lw x10,  (-5*+N)(x2)                     |rcount==15
| lw x7,   (-4*+N)(x2)                     |rcount==15
| lw x6,   (-3*+N)(x2)                     |rcount==15
| lw x5,   (-2*+N)(x2)                     |rcount==15
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================

.UOPs for ``C.POP.E/C.POPRET.E`` if ``rcount<=5``
[options="header",width=50%]
|===============================================================================
| C.POP.E/C.POPRET.E UOP                   |Execute if
| lw x1,   (-1*M+N)(x2)                    |1
| lw x7,   (-6*M+N)(x2)                    |rcount==5
| lw x6,   (-5*M+N)(x2)                    |rcount<=5 && rcount>=4
| lw x14,  (-4*M+N)(x2)                    |rcount<=5 && rcount>=3
| lw x9,   (-3*M+N)(x2)                    |rcount<=5 && rcount>=2
| lw x8,   (-2*M+N)(x2)                    |rcount<=5 && rcount>=1
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET.E
|===============================================================================

.UOPs for ``C.POP.E/C.POPRET.E`` if ``rcount==15``
[options="header",width=50%]
|===============================================================================
| C.POP.E/C.POPRET.E RV32 UOP              |Execute if
| lw x1,   (-1*M+N)(x2)                    |1
| lw x15,  (-7*M+N)(x2)                    |rcount==15
| lw x13,  (-6*M+N)(x2)                    |rcount==15
| lw x12,  (-5*M+N)(x2)                    |rcount==15
| lw x11,  (-4*M+N)(x2)                    |rcount==15
| lw x10,  (-3*M+N)(x2)                    |rcount==15
| lw x5,   (-2*M+N)(x2)                    |rcount==15
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET.E
|===============================================================================


=== Exceptions

If `eabi` is zero and `sp` is not 16 byte aligned when a
`C.PUSH/C.POP/C.POPRET` instruction is executed a memory alignment
exception will be generated (Store Access Fault for `C.PUSH`, Load
Access Fault for `C.POP/C.POPRET`).

If `eabi` is one and `sp` is not 8 byte aligned (RV32) or 16 byte
aligned (RV64) when a `C.PUSH.E/C.POP.E/C.POPRET.E` instruction is
executed a memory alignment exception will be generated (Store Access
Fault for `C.PUSH.E`, Load Access Fault for `C.POP.E/C.POPRET.E`).

Illegal instructions are taken for illegal `rcount` values (see
 <<rcount-table>>).

If `eabi` is zero on an RV32E/RV64E architecture take an illegal
instruction exception.

=== Assembler Syntax

The `C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]` instructions are represented in
assembler as the mnemonic followed by a braced and comma separated list
of registers, followed by the total size of the stack adjustment
expressed in bytes. The stack adjustment should include an appropriate
sign bit and the space needed to accommodate the registers in the
register list. Register ranges are also permitted and indicated using a
hyphen (-). The register list may only contain registers supported by
`C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]` instructions but these can be listed
in any order and use the ABI or "x plus index register" representation.

The mnemonics `C.PUSH/C.POP/C.POPRET` indicate the UABI i.e. `eabi=0`

The mnemonics `C.PUSH.E`/`C.POP.E`/`C.POPRET.E` indicate the EABI i.e.
`eabi=1`

For `RV32I/RV64I` the correct menumonic must be chosen to select the
ABI.

For `RV32E/RV64E` the mneumonics `C.PUSH.E`/`C.POP.E`/`C.POPRET.E` must
be used.

To be legal the stack adjustment must:

1.  Be negative for a `C.PUSH[.E]` and positive for a `C.POP[.E]`/`C.POPRET[.E]`
2.  Match the value range in  <<rcount-table>> for the current architecture and ABI

To use the 16-bit encoding of `C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]` then
the registers specified in the encoding must match one of the sets of
entries in  <<rcount-table>> above, and the stack adjustment must be
legal. Otherwise the assembler will attempt to use the 32-bit encoding,
if it is implemented and is suitable. If not then this will cause an an
`illegal operands` error from the assembler.

=== RV32I UABI Examples

.push 1 to 5 registers, loads can happen in any order, note 3 register holes in the stack pointer increment
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/push_1to5_regs_170pc_zoom.png[push example]

.pop 1 to 5 registers, stores can happen in any order, note 3 register holes in the stack pointer decrement
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/pop_1to5_regs_170pc_zoom.png[pop example]

=== RV32I Assembler Examples

==== C.PUSH RV32I UABI

[source,sourceCode,text]
----
c.push  {ra, s0-s4}, -64
----

Encoding: rcount=5, spimm=2 eabi=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== C.PUSH.E RV32I EABI

[source,sourceCode,text]
----
c.push.e {ra, s0-s4}, -64
----

Encoding: rcount=5, spimm=5 eabi=1 (8-byte aligned, so spimm is larger
than the UABI version)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== C.POP RV32I UABI

[source,sourceCode,text]
----
c.pop   {x1, x8-x9, x18-x25}, 160
----

Encoding: rcount=10, spimm=7 eabi=0 (16-byte aligned, maximum value of
spimm for the 16-bit encoding)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 156(sp);
lw  x25, 116(sp);  lw  x24, 120(sp);
lw  x23, 124(sp);  lw  x22, 128(sp)
lw  x21, 132(sp);  lw  x20, 136(sp);
lw  x19, 140(sp);  lw  x18, 144(sp)
lw   x9, 148(sp);  lw   x8, 152(sp);
addi sp, sp, 160
----

==== C.POPRET RV32I UABI

[source,sourceCode,text]
----
c.popret   {x1, x8-x9, x18-x19}, 32
----

Encoding: rcount=4, spimm=0 eabi=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----

==== C.POPRET.E RV32I EABI

[source,sourceCode,text]
----
c.popret.e  {x1, x8-x9, x14, x6}, 32
----

Encoding: rcount=4, spimm=1 eabi=1 (8-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
lw   x6, 12(sp);  lw  x14, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----

==== Varargs Support

Functions using varargs also spill the argument registers to the stack,
which requires a `SWM` custom instruction (store-word-multiple).

HCC produces this prologue:

[source,sourceCode,text]
----
16: addi sp,sp,-64 
16: sw   ra,28(sp)
16: sw   s0,24(sp)

16: sw   a7,60(sp)
16: sw   a6,56(sp)
16: sw   a5,52(sp)
16: sw   a4,48(sp)
16: sw   a3,44(sp)
16: sw   a2,40(sp)
16: sw   a1,36(sp)
----

This can be optimised to be:

[source,sourceCode,text]
----
16: addi sp,sp,-32
16: push {ra, s0},-32
16: addi sp,sp,(-32+36)
16: swm  {a1-a7},sp
16: addi sp,sp,-36 
----

saving 3x16-bit encodings, but the stack pointer adjustments are awkward
because `SWM` doesn't have an immediate offset

HCC produces this epilogue

[source,sourceCode,text]
----
16: lw   ra,28(sp)
16: lw   s0,24(sp)
16: addi sp,sp,64
16: ret
----

which could become:

[source,sourceCode,text]
----
16: addi sp,sp,32
16: popret {ra,s0},32
----

saving 2x16-bit encodings.

So in total 14 instructions can be reduced to 9.

== 32-bit encodings

The 32-bit versions of the instructions allow greater flexibility in
specifying the list of registers by allowing floating point registers to
be saved/restored. Therefore the register list also allows floating
point registers to be included. They can included in any order, but will
always be accessed in the same order by the instruction. They also allow
a larger range of _spimm_ values. Otherwise the semantics are identical
to the 16-bit versions and so the specification is not repeated here.
The instructions are called `PUSH[.E]`/`POP[.E]`/`POPRET[.E]`

These instructions will _not_ cover all possible push/pop scenarios,
they are designed to cover the common cases without using excessive
encoding space.

This specification does not include the case in RV32D where an odd
number of `X` registers are stored followed by one or more `F`
registers. This _may_ require an adjustment in address between the `X`
and `F` registers to maintain the stack alignment, and the tables
showing the overall stack adjustment _may not_ be correct as every `F`
register is twice as wide as the `X` registers

_Maybe avoid pushing/popping `ra` for tail calls? Could be an extra bit to specify that_

A C-function using varargs will also spill the argument registers to the
stack. They can be achieved by a store-multiple command after the PUSH
instruction and vararg support is not directly implemented by PUSH

=== Opcode Assignment

[options="header",width="90%",cols="14%,6%,12%,10%,12%,9%,9%,12%,16%",]
|================================================================
|31:28 |27 |26:24 |23:20 |19:15 |14:12 |11:7 |6:0 |name
|xxxxxx |0 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |PUSH
|xxxxxx |0 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POP
|xxxxxx |0 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POPRET
|xxxxxx |1 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |PUSH.E
|xxxxxx |1 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POP.E
|xxxxxx |1 |frcount |rcount |spimm |xxx |xxxxx |xxxxxxx |POPRET.E
|================================================================

* bit [27] is `eabi` which specifies which ABI is in use

The `x` registers are specified by <<rcount-table>>, there is no
difference in the specification except that `spimm` has a larger range.
The addition field `frcount` allows callee save `f` registers to be
saved/restored as well. The `f` registers are always appended to the
list of integer registers.

[options="header",width="50%"]
|====================================
  |frcount | ABI names               
  | 0      |none                     
  | 1      |fs0                      
  | 2      |fs0-fs1                  
  | 3      |fs0-fs2                  
  | 4      |fs0-fs3                  
  | 5      |fs0-fs4                  
  | 6      |fs0-fs5                  
  | 7      |fs0-fs6                  
  | 8      |fs0-fs7                  
  | 9      |fs0-fs8                  
  | 10     |fs0-fs9                  
  | 11     |fs0-fs10                 
  | 12     |fs0-fs11                 
  | 13-14  |*reserved*               
  | 15     |ft0-7, fa0-7, ft8-11     
|====================================

`frcount=15` is to save/restore the caller registers for the interrupt
handler. There are different rules for the instruction if `rcount` or
`frcount` are 15

The total stack adjustment is based upon the total number of registers
accessed, not just the `x` registers.

==== Specification if rcount < 15

The order of registers load/stored is:

* ra
* if (`rcount` > 0) s0-s `rcount`
* if (`frcount` != 0 && `frcount` < 13) fs0-fs `frcount`

This is the same as the 16-bit encoding, except that the register list
may be extended with `fs0-fs11`. The final stack pointer offset is the
same as for the 16-bit encoding, but with a larger range see
regcount_table2_eab_0

Therefore the 16-bit encoding allows up to 13 registers to be
saved/restored. The 32-bit encoding also allows up to 12 additional
registers giving a maximum of 25.

If `frcount` >0 and the F extension is not implemented, without `Zfinx`
, then take an illegal instruction exception.

if `frcount` >12 then take an illegal instruction exception.

The other illegal instruction checks are identical to those for the
16-bit encodings.

==== Specification if rcount == 15

The order of registers load/stored is:

* ra
* all `X` caller save registers
* if (`frcount` == 15) all `F` caller save registers

This is the same as the 16-bit encoding with `rcount=15`, except that
the register list may be extended with the `F` caller registers. The
final stack pointer offset is the same as for the 16-bit encoding, but
with a larger range.

* `PUSH/POP/POPRET`: the 16-bit encoding allows 16 `X` registers to be
saved/restored. The 32-bit encoding also allows an additional 20 `F`
registers giving a maximum of 36.
* `PUSH.E/POP.E/POPRET.E`: the 16-bit encoding allows 7 `X` registers to
be saved/restored. The 32-bit encoding also allows an additional 20 `F`
registers giving a maximum of 27.

If `frcount` !=0 && `frcount` !=15 then take an illegal instruction
exception.

If `frcount` ==15 and the F extension is not implemented, without
`Zfinx`, then take an illegal instruction exception.

The other illegal instruction checks are identical to those for the
16-bit encodings.

.Register count mapping for ``PUSH/POP/POPRET``
[options="header",width="50%"]
|==============================================
  |total  2+|SP adjustment   2+|reg holes  
  |# regs 2+|x=spimm,        2+|to skip    
  |       2+|-for PUSH,      2+|           
  |       2+|+for POP/POPRET 2+|           
  |         |RV32I  |RV64I     |RV32I|RV64I
  5+|*eabi = 0*                         
  |1     |16(1+x)|16(1+x) | 3   | 1   
  |2     |16(1+x)|16(1+x) | 2   | 0   
  |3     |16(1+x)|16(2+x) | 1   | 1   
  |4     |16(1+x)|16(2+x) | 0   | 0   
  |5     |16(2+x)|16(3+x) | 3   | 1   
  |6     |16(2+x)|16(3+x) | 2   | 0   
  |7     |16(2+x)|16(4+x) | 1   | 1   
  |8     |16(2+x)|16(4+x) | 0   | 0   
  |9     |16(3+x)|16(5+x) | 3   | 1   
  |10    |16(3+x)|16(5+x) | 2   | 0   
  |11    |16(3+x)|16(6+x) | 1   | 1   
  |12    |16(3+x)|16(6+x) | 0   | 0   
  |13    |16(4+x)|16(7+x) | 3   | 1   
  |14    |16(4+x)|16(7+x) | 2   | 0   
  |15    |16(4+x)|16(8+x) | 1   | 1   
  |16    |16(4+x)|16(8+x) | 0   | 0   
  |17    |16(5+x)|16(9+x) | 3   | 1   
  |18    |16(5+x)|16(9+x) | 2   | 0   
  |19    |16(5+x)|16(10+x)| 1   | 1   
  |20    |16(5+x)|16(10+x)| 0   | 0   
  |21    |16(6+x)|16(11+x)| 3   | 1   
  |22    |16(6+x)|16(11+x)| 2   | 0   
  |23    |16(6+x)|16(12+x)| 1   | 1   
  |24    |16(6+x)|16(12+x)| 0   | 0   
  |25    |16(7+x)|16(13+x)| 3   | 1   
  |25-35 | *reserved*                 
  |36    |16(9+x)|16(18+x)| 0   | 0   
|==============================================

.Register count mapping for PUSH.E/POP.E/POPRET.E`
[options="header",width="70%"]
|===========================================================================
|total  4+|Stack pointer adjustment         |reg holes to skip      
|# regs 4+|x=spimm -for PUSH, +for POP      |                       
|         |RV32I  |RV64I   |RV32E  |RV64E   |                       
6+|*eabi = 1*                                                      
|1     | 8(1+x)|16(1+x) | 8(1+x)|16(1+x) | 1                     
|2     | 8(1+x)|16(1+x) | 8(1+x)|16(1+x) | 0                     
|3     | 8(2+x)|16(2+x) | 8(2+x)|16(2+x) | 1                     
|4     | 8(2+x)|16(2+x) | 8(2+x)|16(2+x) | 0                     
|5     | 8(3+x)|16(3+x) | 8(3+x)|16(3+x) | 1                     
|6     | 8(3+x)|16(3+x) | 8(3+x)|16(3+x) | 0                     
|7     | 8(4+x)|16(4+x) | 8(4+x)|16(4+x) | 1                     
|8     | 8(4+x)|16(4+x) | 8(4+x)|16(4+x) | 0                     
|9     | 8(5+x)|16(5+x) | 8(5+x)|16(5+x) | 1                     
|10    | 8(5+x)|16(5+x) | 8(5+x)|16(5+x) | 0                     
|11    | 8(6+x)|16(6+x) | 8(6+x)|16(6+x) | 1                     
|12    | 8(6+x)|16(6+x) | 8(6+x)|16(6+x) | 0                     
|13    | 8(7+x)|16(7+x) | 8(7+x)|16(7+x) | 1                     
|14    | 8(7+x)|16(7+x) | 8(7+x)|16(7+x) | 0                     
|15    | 8(8+x)|16(8+x) | 8(8+x)|16(8+x) | 1                     
|16    | 8(8+x)|16(8+x) | 8(8+x)|16(8+x) | 0                     
|17    | 8(9+x)|16(9+x) | 8(9+x)|16(9+x) | 1                     
|18    | 8(9+x)|16(9+x) | 8(9+x)|16(9+x) | 0                     
|18-26 5+| *reserved*                                              
|27    |8(14+x)|16(14+x)|8(14+x)|16(14+x)| 1                     
|===========================================================================


=== Assembler Examples

==== PUSH RV32I UABI

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: rcount=5, frcount=1, spimm=2, eabi=0 (16-byte aligned, C.PUSH
doesn't support f registers)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
fsw fs0, 36(sp)
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== PUSH.E RV32I EABI

[source,sourceCode,text]
----
push.e  {ra, s0-s4, fs0}, -64
----

Encoding: rcount=5, frcount=1, spimm=4 eabi=1 (8-byte aligned, so spimm
is larger than the UABI version)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
fsw fs0, 36(sp)
sw  s4, 40(sp); sw  s3, 44(sp);
sw  s2, 48(sp); sw  s1, 52(sp);
sw  s0, 56(sp); sw  ra, 60(sp);
----

==== POP RV32I UABI

[source,sourceCode,text]
----
pop   {x1, x8-x9, x18-x25}, 256
----

Encoding: rcount=10, frcount=0, spimm=13 eabi=0 (16-byte aligned, spimm
out of range for C.POP)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 252(sp);
lw  x25, 212(sp);  lw  x24, 216(sp);
lw  x23, 220(sp);  lw  x22, 224(sp)
lw  x21, 228(sp);  lw  x20, 232(sp);
lw  x19, 236(sp);  lw  x18, 240(sp)
lw   x9, 244(sp);  lw   x8, 248(sp);
addi sp, sp, 256
----

==== POPRET RV32I UABI

[source,sourceCode,text]
----
popret   {x1, x8-x9, x18-x19, f8-f9}, 32
----

Encoding: rcount=4, frcount=2, spimm=0, eabi=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
flw  f9,  4(s0);  flw  f8,  8(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----

==== POPRET RV32I EABI

[source,sourceCode,text]
----
popret.e  {x1, x8-x9, x14, x6, f8-f9}, 32
----

Encoding: rcount=4, frcount=2, spimm=0 eabi=1 (8-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   x1, 28(sp);
flw  f9,  4(s0);  flw  f8,  8(sp);
lw   x6, 12(sp);  lw  x14, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
addi sp, sp, 32; ret
----
