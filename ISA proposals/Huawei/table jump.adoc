= RISC-V Table Jump ISA Proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16/32-bit instructions to allow table jumps to reduce the code size of `JAL` / `JALR` instructions.

* replace 32-bit `JAL` calls to 16-bit `C.TBLJAL`
* replace 64-bit `AUIPC/JALR` calls to fixed locations with either a 16-bit `C.TBLJAL` or a 32-bit `TBLJAL` 
** `[C.]TBLJAL` can be used replace `JALR` if it jumps to a fixed target, which is typically inferred as an `AUIPC/JALR` sequence because the offset from the PC is out of the +/-1MB range.
* the 32-bit encoding allows more functions to be called, but saves less code size, so the most common functions should be callable by the 16-bit encoding

The 32-bit instruction encoding will ensure that 64-bit sequences are unlikely to be needed to call functions, unless the table is full. Additional functionality may be added TBD.

== Issues 

. what additional functionality to add in the 32-bit version, if any?

== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	001f8317            auipc t1,0x1f8
  e084c2:	18a302e7            jalr  t0,394(t1) # 1000648 <__riscv_save_0>
  e084c6:	86b2                mv    a3,a2
  e084c8:	862e                mv    a2,a1
  e084ca:	800005b7            lui	  a1,0x80000
  e084ce:	fff5c593            not	  a1,a1
  e084d2:	f61ff0ef            jal	  ra,e08432 <vsnprintf>
  e084d6:	001f8317            auipc	t1,0x1f8
  e084da:	19630067            jr	  406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJAL` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	xxxx                tbljal #x ;#<mapped to __riscv_save_0>, saving 6-bytes
  e084c6:	86b2                mv     a3,a2
  e084c8:	862e                mv     a2,a1
  e084ca:	800005b7            lui	   a1,0x80000
  e084ce:	fff5c593            not	   a1,a1
  e084d2:	xxxx                tbljal #y ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  e084da:	xxxx                tbljal #z ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of `TBLJALENTRIES` addresses for `[C.]TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. Not all functions are reduced by this much.

== 16-bit Opcode Assignment

|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  2+| 11 7+|         index7              2+| 00  | C.TBLJAL
|=============================================================================================

The 16-bit encoding allows half of the `TBLJALENTRIES` to be accessed (_to be confirmed_).

== 32-bit Opcode Assignment

|============================================================================
|31:23  |22:15   |14:12 |11:7  |6:0     |name
|xxxxxx |index8  |001   |xxxxx |xxxxxxx |TBLJAL
|============================================================================

`TBLJALENTRIES` is defined by the `index8` field in the 32-bit encoding, so initially 256 (_to be confirmed_).

== CSR and Modes

Two modes are proposed for the lookup table

- simple jump table (`MTBLJVEC.scale`=0)
- vector table, similar to the interrupt handler vector (`MTBLJVEC.scale`>0)

[#MTBLJALVEC-table]
.`MTBLJALVEC` definition
|=============================================================================================
| XLEN-1:6          | 5: 0  | CSR        | Permissions
| base[XLEN-1:6]    | scale | MTBLJALVEC | MRW
|=============================================================================================

Using `MTBLJVEC.base` in the pseudo code below implicitly assumes that `MTBLJVEC.base[5:0]=0`. This is consistent with the description of `MTVEC` in the Unprivileged ISA manual.

`MTBLJVEC.base` is naturally aligned for all legal values of `XLEN`

`MTBLJALCFG` control the valid entries inthe table and the _watermarks_ which are used to control which link register is in use for each table entry.

[#MTBLJALCFG-table]
.`MTBLJALCFG` definition
|=============================================================================================
| XLEN-1:24       | 23:16    | 15:8 |  7: 0  | CSR         | Permissions
| ROZ             |maxentry  | wxm5 | wmx0   | MTBLJALCFG  | MRW
|=============================================================================================

[NOTE]

  The range of `MTBLJALCFG.maxentry` is from 0 to `TBLJALENTRIES-1`

[NOTE]
  All 3 fields are _unsigned_ integers

=== Watermarks

The two watermark fields are used to control which tables entries link to

*  `x0` (i.e. `J` not `JAL`)
*  `x1` (`ra`, standard link register)
*  `x5` (alternate link register for millicode routines)

Depending upon the programming, table entries can all be allocated to 1, 2 or all 3 link registers.

In the table MAX is `TBLJALENTRIES-1` (255)

[#MTBLJALCFG-table-watermark-end-conditions]
.`MTBLJALCFG` watermarks
|==================================================================================================================
|`MTBLJALCFG.wmx0`  |`MTBLJALCFG.wmx5`| `JAL x0` range | `JAL x5` range | `JAL x1` range | Comment
6+| Normal programming model, use all 3 link registers
| X, X>0            | Y, Y>X          |*0 to X-1*      |*X to Y-1*      |*Y to MAX*      | Use all 3 link registers
6+| Restricted programming model, exclude 1 or 2 link registers
| 0                 |  MAX            |*0 to MAX*      |_none_          |_none_          | Only link to x0   
| MAX               |  MAX            |_none_          |*0 to MAX*      |_none_          | Only link to x5      
| 0                 | 0               |_none_          |_none_          |*0 to MAX*      | Only link to x1
| 0                 | Y, Y>0          |*0 to Y-1*      |_none_          |*Y to MAX*      | Only link to x0, x1
| X, X>0            | X               |_none_          |*0 to X-1*      |*X to MAX*      | Only link to x1, x5
6+| reserved for future use
| Z                 | <Z            3+|illegal instruction                               | *reserved*
|==================================================================================================================

Some of the modes may not be so useful, so we can consider restricting them, for example

- only link to x5 (only millicode routines)
- only link to x1, x5 (no J equivalent)
- _this needs review, but in general I'd like the specification to be flexible_


With the proposed encodings 

- the 16-bit encoding can access entry 0 to min(127, `MTBLJALCFG.maxentry`)
- the 32-bit encoding can access entry 0 to min(255, `MTBLJALCFG.maxentry`)

[#MTBLJALCFG-table-watermark-examples]
.`MTBLJALCFG` watermark examples
|==========================================================================================================================
|`MTBLJALCFG.wmx0`  |`MTBLJALCFG.wmx5`|`JAL x0` range|`JAL x5` range| `JAL x1` range 
| 20                | 40              |*0 to 19*     |*20 to 39*    |*40 to 255*
| 0                 | 40              |*0 to 39*     |_none_        |*40 to 255*
| 40                | 40              |_none_        |*0 to 39*     |*40 to 255*
| 40                | 39            3+| *reserved*
| 0                 | 255             |*0 to 255*    |_none_        |_none_
| 255               | 255             |_none_        |*0 to 255*    |_none_
| 0                 | 0               |_none_        |_none_        |*0 to 255*               
|==========================================================================================================================

`JAL x1` is always highest in the range (if enabled), so that the 32-bit encoding typically adds more cases using `x1` to convert `AUIPC/JALR x1` sequences to `TBLJAL` to save code size.


.watermark example
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump2.PNG[watermark example]

=== Exceptions

Take an illegal instruction exception if `[C.]TBLJAL #n` is executed and oe of more of these conditions are true:

- `n > MTBLJALWM.maxentry` 
- `MTBLJALWM.wmx5 < MTBLJALWM.wxm0` 
- `MTBLJALWM.wmx0 > MTBLJALWM.maxentry` 
- `MTBLJALWM.wmx5 > MTBLJALWM.maxentry`

All comparisons are _unsigned_.

=== Modes

Table jump supports both jump table and vector modes.

.table jump and vector modes
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump1.PNG[table jump and vector modes]

==== Jump table mode

In jump table mode the behaviour is to load the target address from `MTBLJVEC.base` with an offset which is XLEN/8 times the parameter.

[source,sourceCode,text]
----
# tmp is temporary internal state, it doesn't represent a real register
# Mem is byte indexed
# LINK is x0, x1, x5 depending on the index number and the watermarks
if (n > MTBLJALCFG.maxentry OR MTBLJALWM.wmx5 < MTBLJALWM.wxm0) {
  take_illegal_instruction_exception();
  }
switch(XLEN) {
  32:  {LW tmp, Mem[MTBLJVEC.base + n<<2][XLEN-1:0]; JALR LINK, tmp;}
  64:  {LD tmp, Mem[MTBLJVEC.base + n<<3][XLEN-1:0]; JALR LINK, tmp;}
  128: {LQ tmp, Mem[MTBLJVEC.base + n<<4][XLEN-1:0]; JALR LINK, tmp;}
}

----

For the `vsprintf` example above, the table contains the base addresses of the functions.

[source,sourceCode,text]
----
MTBJALVECWM.wmx0 = 0 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 1 # c.tbljal #1+ map to JAL x1

MTBLJVEC.base+ 0(index 0) = # 100066c <__riscv_restore_0> # requires JAL x0
MTBLJVEC.base+ 8(index 1) = # 1000648 <__riscv_save_0>    # requires JAL x1
MTBLJVEC.base+12(index 2) = #  e08432 <vsnprintf>         # requires JAL x1
----

The functions are not moved in memory, the table lookup is only to give a reference to them using a 16-bit encoding.

==== Vector table mode

In vector table mode, execution passes directly to the scaled offset from the base register.
The entry points are scaled, according to `MTBLJVEC.scale`

|==================================================================
| `MTBLJVEC.scale` | `tablescale` 
| 0               | jump table mode
2+| *All other values are vector table mode*
| 1               | 8-bytes
| 2               | 16-bytes
| 3               | 32-bytes
2+| .....
| 10              | 4096-bytes to match minimum TBL page size
| 11+             | *reserved*
|==================================================================

Note that in vector table mode, `tablescale = 1<<(MTBLJVEC.scale+2)`

[source,sourceCode,text]
----
# Mem is byte indexed
# LINK is x0, x1, x5 depending on the index number and the watermarks
if (n > MTBLJALCFG.maxentry OR MTBLJALWM.wmx5 < MTBLJALWM.wxm0) {
  take_illegal_instruction_exception();
  }
JALR LINK, Mem[MTBLJVEC.base + n*tablescale][XLEN-1:0];
----

This method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

Setting `MTBLJVEC.scale` to specific values does not set a requirement on the alignment of `MTBLJVEC.base`. For example if `tablescale=4096`, `MTBLJVEC.base` does _not_ need to be 4096-byte aligned. 

If `tablescale` is set to 4096 then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `MTBLJVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `MTBLJVEC.scale=2` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is 136 bytes, but will shrink to 128-bytes or smaller by use of `c.tbljal` so I have allocated the first 4 entries to it.

[source,sourceCode,text]
----

MTBJALVECWM.wmx0 = 0 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 1 # c.tbljal #1+ map to JAL x1

#index 0 (JAL x0)
MTBLJVEC.base+0 <__riscv_restore_0>:
 	4902                	lw	s2,0(sp)
 	4492                	lw	s1,4(sp)
 	4422                	lw	s0,8(sp)
 	40b2                	lw	ra,12(sp)
 	0141                	addi	sp,sp,16
 	8082                	ret

# index 2 (JAL x1)
MTBLJVEC.base+32  <__riscv_save_0>:
 	1141                	addi	sp,sp,-16
 	c04a                	sw	s2,0(sp)
 	c226                	sw	s1,4(sp)
 	c422                	sw	s0,8(sp)
 	c606                	sw	ra,12(sp)
 	8282                	jr	t0

# index 3-6 (JAL x1)
MTBLJVEC.base+48: <vsnprintf>
  	xxxx                	tbljal #5 ;# call to <__riscv_save_0>
  ...  up to 128-byte function body ...
  	xxxx                	tbljal #4 ;# call to <__riscv_restore_0>
----

== Caching

For improved performance, the implementation may cache the contents of the table, for either mode. To assist this and avoid unnecessary memory fetches, we state that the table contents may be cached without consistency checks against memory outside the hart if `MTBLJVEC` has not been written to. 

Any write to `MTBLJVEC`, even if the actual value is not updated, will indicate that any table caching must be flushed and refetched.

Therefore if there are any updates to generated code in the table in vector mode, a write to `MTBLJVEC` is required to ensure that any cached contents are not stale.

== Security (future ideas)

The table jump mechanism could be reused for security in the future. It is possible to define that the memory allocated to to the table (in vector mode) can only have entry points on the specific vectors, and also only from `TBLJAL` instructions. In this way sensitive code can be placed in the table which cannot be reused for ROP/JOP gadgets, because the code cannot be targetted by `JALR` instructions.

These ideas will not be pursued as part of the code size work.



