= RISC-V Table Jump ISA Proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16-bit instructions to allow table jumps to reduce the code size of `JAL` / `JALR` instructions, where `JALR` jumps to a fixed target and an `AUIPC/JALR` sequence is required because the offset from the PC is out of the +/-1MB range.

The 32-bit instruction encoding will ensure that 64-bit sequences are not needed to call functions, and additional functionality may be added TBD.

== Issues 

. what functionality to add in the 32-bit version?

== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	001f8317            auipc	t1,0x1f8
  e084c2:	18a302e7            jalr	t0,394(t1) # 1000648 <__riscv_save_0>
  e084c6:	86b2                mv a3,a2
  e084c8:	862e                mv a2,a1
  e084ca:	800005b7            lui	a1,0x80000
  e084ce:	fff5c593            not	a1,a1
  e084d2:	f61ff0ef            jal	ra,e08432 <vsnprintf>
  e084d6:	001f8317            auipc	t1,0x1f8
  e084da:	19630067            jr	406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJ[AL]` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	xxxx                tbljal  #x ;#<mapped to __riscv_save_0>, saving 6-bytes
  e084c6:	86b2                mv a3,a2
  e084c8:	862e                mv a2,a1
  e084ca:	800005b7            lui	a1,0x80000
  e084ce:	fff5c593            not	a1,a1
  e084d2:	xxxx                tbljal  #y ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  e084da:	xxxx                tbljal  #z ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of `TBLJAL_ENTRIES` addresses for `[C.]TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. Not all functions are reduced by this much.

== 16-bit Opcode Assignment

|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  2+| 11 7+|         index7              2+| 00  | C.TBLJAL
|=============================================================================================

The 16-bit encoding allows half of the `TBLJAL_ENTRIES` to be accessed (_to be confirmed_).

== 32-bit Opcode Assignment

|============================================================================
|31:23  |22:15   |14:12 |11:7  |6:0     |name
|xxxxxx |index8  |001   |xxxxx |xxxxxxx |TBLJAL
|============================================================================

`TBLJAL_ENTRIES` is defined by index field in the 32-bit encoding, so initially 256 (_to be confirmed_).

== CSR and Modes

Two modes are proposed for the lookup table

- simple jump table (`MTBLJVEC.scale`=0)
- vector table, similar to the interrupt handler vector (`MTBLJVEC.scale`>0)

[#MTBLJALVEC-table]
.`MTBLJALVEC` definition
|=============================================================================================
| XLEN-1:6          | 5: 0  | CSR        | Permissions
| base[XLEN-1:6]    | scale | MTBLJALVEC | MRW
|=============================================================================================

Using `MTBLJVEC.base` in the pseudo code below implicitly assumes that `MTBLJVEC.base[5:0]=0`. This is consistent with the description of `MTVEC` in the Unprivileged ISA manual.

`MTBLJVEC.base` is naturally aligned for all legal values of `XLEN`

[#MTBLJALWM-table]
.`MTBLJALWM` definition
|=============================================================================================
| XLEN-1:16       | 24:15    | 14:9 |  8: 0  | CSR        | Permissions
| ROZ             | wmx5     | ROZ  | wmx0   | MTBLJALWM  | MRW
|=============================================================================================

=== Watermarks

The two watermarks are used to control which tables entries link to

*  x0 (i.e. J)
*  x1
*  x5

[#MTBLJALWM-table-watermarks]
.`MTBLJALWM` watermarks
|==========================================================
| Low Entry         | High Entry         | Link register
| 0                 | `MTBLJALWM.wmx0`-1 | x0
| `MTBLJALWM.wmx0`  | `MTBLJALWM.wmx5`-1 | x5
| `MTBLJALWM.wmx5`  | `TBLJAL_ENTRIES`-1 | x1
|==========================================================

For example:

* `MTBLJALWM.wmx0` = 5
* `MTBLJALWM.wmx5` = 10

For the 16-bit encoding:

* `C.TBLJAL #0` to `C.TBLJAL #4` will `JAL x0` to the destination PC
* `C.TBLJAL #5` to `C.TBLJAL #9` will `JAL x5` to the destination PC
* `C.TBLJAL #6` to `C.TBLJAL #127` will `JAL x1` to the destination PC

For the 32-bit encoding:

* `TBLJAL #0` to `TBLJAL #4` will `JAL x0` to the destination PC
* `TBLJAL #5` to `TBLJAL #9` will `JAL x5` to the destination PC
* `TBLJAL #6` to `TBLJAL #255` will `JAL x1` to the destination PC

They are specified in this order as I expect there to be few `JAL x0` / `JAL x5` calls but many `JAL x1` calls. In this way the 32-bit encoding is likely to add more `JAL x1` calls only, so the most frequent can be made available to the 16-bit encoding and the 32-bit encoding for less frequent calls which use 64-bit `AUIPC/JALR` calling sequences.

==== Watermark end conditions

[#MTBLJALWM-table-watermark-end-conditions]
.`MTBLJALWM` watermark end conditions
|============================================================================================
| MTBLJALWM.wmx0  | MTBLJALWM.wmx5  | meaning
| 0               | 0               | always JAL x1
| 0               | `TBLJAL_ENTRIES`| always JAL X5
| `TBLJAL_ENTRIES`| `TBLJAL_ENTRIES`| always JAL X0
| X               |  â‰¤ X            | illegal instruction (wmx5 must be greater then wmx0)
|============================================================================================


=== Jump table mode

In jump table mode the behaviour is to load the target address from `MTBLJVEC.base` with an offset which is XLEN/8 times the parameter.

[source,sourceCode,text]
----
switch(opcode) {
  # tmp is temporary internal state, it doesn't represent a real register
  # Mem is byte indexed
  # LINK is x0, x1, x5 depending on the index number and the watermarks
  switch(XLEN) {
    32:  {LW tmp, Mem[MTLBJVEC.base + n<<2][XLEN-1:0]; JALR LINK, tmp;}
    64:  {LD tmp, Mem[MTLBJVEC.base + n<<3][XLEN-1:0]; JALR LINK, tmp;}
    128: {LQ tmp, Mem[MTLBJVEC.base + n<<4][XLEN-1:0]; JALR LINK, tmp;}
  }
}
----

For the `vsprintf` example above, the table contains the base addresses of the functions.

[source,sourceCode,text]
----
MTBJALVECWM.wmx0 = 1 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 2 # c.tbljal #1 maps to JAL x5, c.tbljal #2+ map to JAL x1

MTLBJVEC.base+ 0(index 0) = # 100066c <__riscv_restore_0> # requires JAL x0
MTLBJVEC.base+ 8(index 2) = # 1000648 <__riscv_save_0>    # requires JAL x1
MTLBJVEC.base+12(index 3) = #  e08432 <vsnprintf>         # requires JAL x1
----

The functions are not moved in memory, the table lookup is only to give a reference to them using a 16-bit encoding.

=== Vector table mode

In vector table mode, execution passes directly to the scaled offset from the base register.
The entry points are scaled, according to `MTLBJVEC.scale`

|==================================================================
| `MTLBJVEC.scale` | `tablescale` 
| 0               | jump table mode
2+| *All other values are vector table mode*
| 1               | 8-bytes
| 2               | 16-bytes
| 3               | 32-bytes
2+| .....
| 10              | 4096-bytes to match minimum TLB page size
| 11-15           | *reserved*
|==================================================================

Note that in vector table mode, `tablescale = 4<<MTLBJVEC.scale`

[source,sourceCode,text]
----
c.tbljal #n ;# JALR LINK, Mem[MTLBJVEC.base + n*tablescale][XLEN-1:0];
----

This method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

Setting `MTBLJVEC.scale` to specific values does not set a requirement on the alignment of `MTBLJVEC.base`. For example if `tablescale=4096`, `MTBLJVEC.base` does _not_ need to be 4096-byte aligned. 

If `tablescale` is set to 4096 then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `MTLBJVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `MTLBJVEC.scale=2` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is much larger so I have placed the function prologue in the table, and the body elsewhere to mimimise memory wastage. The original `vsprintf` function is 136-bytes. After shrinking due to use of `c.tbljal` it would fit within 4 entries so I could allocate entries 1-4 and make `__riscv_restore_0` entry 5 instead of entry 2.

[source,sourceCode,text]
----

MTBLJVEC.base+0: <vsnprintf>
  MTBLJVEC.base+0:	xxxx                	tlbjal #0 ;# call to <__riscv_save_0>
  MTBLJVEC.base+2:	xxxx                	#### prologue
  ...
  MTBLJVEC.base+14:	xxxx                	j <_vsnprintf_body> ;# call rest of function
 
MTBLJVEC.base+32  <__riscv_save_0>:
 MTBLJVEC.base+34 :	1141                	addi	sp,sp,-16
 MTBLJVEC.base+36 :	c04a                	sw	s2,0(sp)
 MTBLJVEC.base+38 :	c226                	sw	s1,4(sp)
 MTBLJVEC.base+40 :	c422                	sw	s0,8(sp)
 MTBLJVEC.base+42 :	c606                	sw	ra,12(sp)
 MTBLJVEC.base+44:	8282                	jr	t0

  

MTBLJVEC.base+48 <__riscv_restore_0>:
 MTBLJVEC.base+50:	4902                	lw	s2,0(sp)
 MTBLJVEC.base+52:	4492                	lw	s1,4(sp)
 MTBLJVEC.base+54:	4422                	lw	s0,8(sp)
 MTBLJVEC.base+56:	40b2                	lw	ra,12(sp)
 MTBLJVEC.base+58:	0141                	addi	sp,sp,16
 MTBLJVEC.base+60:	8082                	ret


----

== Caching

For improved performance, the implementation may cache the contents of the table, for either mode. To assist this and avoid unnecessary memory fetches, we state that the table contents may be cached without consistency checks against memory outside the hart if `MTBLJVEC` has not been written to. 

Any write to `MTBLJVEC`, even if the actual value is not updated, will indicate that any table caching must be flushed and refetched.

Therefore if there are any updates to generated code in the table in vector mode, a write to `MTBLJVEC` is required to ensure that any cached contents are not stale.




