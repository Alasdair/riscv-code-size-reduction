= RISC-V Table Jump ISA Proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16/32-bit instructions to allow table jumps to reduce the code size of `JAL` / `JALR` instructions.

* replace 32-bit `JAL` calls to 16-bit `C.TBLJAL`
* replace 64-bit `AUIPC/JALR` calls to fixed locations with either a 16-bit `C.TBLJAL` or a 32-bit `TBLJAL` 
** `[C.]TBLJAL` can be used replace `JALR` if it jumps to a fixed target, which is typically intferred as an `AUIPC/JALR` sequence because the offset from the PC is out of the +/-1MB range.
* the 32-bit encoding allows more functions to be called, but saves less code size, so the most common functions should be callable by the 16-bit encoding

The 32-bit instruction encoding will ensure that 64-bit sequences are unlikely to be needed to call functions, unless the table is full. Additional functionality may be added TBD.

== Issues 

. what functionality to add in the 32-bit version?

== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	001f8317            auipc	t1,0x1f8
  e084c2:	18a302e7            jalr	t0,394(t1) # 1000648 <__riscv_save_0>
  e084c6:	86b2                mv a3,a2
  e084c8:	862e                mv a2,a1
  e084ca:	800005b7            lui	a1,0x80000
  e084ce:	fff5c593            not	a1,a1
  e084d2:	f61ff0ef            jal	ra,e08432 <vsnprintf>
  e084d6:	001f8317            auipc	t1,0x1f8
  e084da:	19630067            jr	406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJAL` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	xxxx                tbljal  #x ;#<mapped to __riscv_save_0>, saving 6-bytes
  e084c6:	86b2                mv a3,a2
  e084c8:	862e                mv a2,a1
  e084ca:	800005b7            lui	a1,0x80000
  e084ce:	fff5c593            not	a1,a1
  e084d2:	xxxx                tbljal  #y ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  e084da:	xxxx                tbljal  #z ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of `TBLJALENTRIES` addresses for `[C.]TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. Not all functions are reduced by this much.

== 16-bit Opcode Assignment

|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  2+| 11 7+|         index7              2+| 00  | C.TBLJAL
|=============================================================================================

The 16-bit encoding allows half of the `TBLJALENTRIES` to be accessed (_to be confirmed_).

== 32-bit Opcode Assignment

|============================================================================
|31:23  |22:15   |14:12 |11:7  |6:0     |name
|xxxxxx |index8  |001   |xxxxx |xxxxxxx |TBLJAL
|============================================================================

`TBLJALENTRIES` is defined by index field in the 32-bit encoding, so initially 256 (_to be confirmed_).

== CSR and Modes

Two modes are proposed for the lookup table

- simple jump table (`MTBLJVEC.scale`=0)
- vector table, similar to the interrupt handler vector (`MTBLJVEC.scale`>0)

[#MTBLJALVEC-table]
.`MTBLJALVEC` definition
|=============================================================================================
| XLEN-1:6          | 5: 0  | CSR        | Permissions
| base[XLEN-1:6]    | scale | MTBLJALVEC | MRW
|=============================================================================================

Using `MTBLJVEC.base` in the pseudo code below implicitly assumes that `MTBLJVEC.base[5:0]=0`. This is consistent with the description of `MTVEC` in the Unprivileged ISA manual.

`MTBLJVEC.base` is naturally aligned for all legal values of `XLEN`

`MTBLJALWM` control the _watermarks_ used to control which link register is in use for each table entry.

[#MTBLJALWM-table]
.`MTBLJALWM` definition
|=============================================================================================
| XLEN-1:16       | 24:15    | 14:9 |  8: 0  | CSR        | Permissions
| ROZ             | wmx5     | ROZ  | wmx0   | MTBLJALWM  | MRW
|=============================================================================================

=== Watermarks

The two watermark fields are used to control which tables entries link to

*  x0 (i.e. `J` not `JAL`)
*  x1
*  x5

Some table entries always link to `x1`. Table entries can also link to `x0` and or `x5`, depending on the programming.


[#MTBLJALWM-table-watermark-end-conditions]
.`MTBLJALWM` watermarks
|==================================================================================================================
|`MTBLJALWM.wmx0`   |`MTBLJALWM.wmx5` | `JAL x0` range | `JAL x5` range | `JAL x1` range | Comment
| X, X>0            | Y, Y>X          | 0 to X-1     | X to Y-1     | Y to `TBLJALENTRIES`-1 | Use all 3 link registers
| 0                 | 0               | none         | none         | 0 to `TBLJALENTRIES`-1 | Only link to x1
| 0                 | `TBLJALENTRIES` | 0 to `TBLJALENTRIES`-1      | none     | none        | Only link to x0   
| `TBLJALENTRIES`   | `TBLJALENTRIES` | none | 0 to `TBLJALENTRIES`-1          | none        | Only link to x5      
| X, X>0            | X               | none         | 0 to X-1     | X to `TBLJALENTRIES`-1 | Only link to x1, x5
| 0                 | Y, Y>0          | 0 to Y-1     | none         | Y to `TBLJALENTRIES`-1 | Only link to x0, x1
| Z                 | <Z            3+|illegal instruction                                   | *reserved*
|==================================================================================================================

With the proposed encodings `TBLJALENTRIES/2=128` so entries 0-127 are accessible by the 16-bit encoding, and 0-255 are accessible by the 32-bit encoding. 

[#MTBLJALWM-table-watermark-examples]
.`MTBLJALWM` watermark examples
|==========================================================================================================================
|`MTBLJALWM.wmx0`   |`MTBLJALWM.wmx5` |`JAL x0` range|`JAL x5` range| `JAL x1` range 
| 20                | 40              | 0 to 19      | 20 to 39     | 40 to 255
| 0                 | 40              | 0 to 39      | none         | 40 to 255
| 40                | 40              | none         | 0 to 39      | 40 to 255
| 40                | 39            3+| *reserved*
| 0                 | 0               | none         | none         | 0 to 255                 
| 256               | 256             | none         | 0 to 255     | none                     
| 0                 | 256             | 0 to 255     | none         | none                    
|==========================================================================================================================

`JAL x1` is always highest in the range (if enabled), so that the 32-bit encoding typically adds more cases using `x1` to convert `AUIPC/JALR x1` sequences to `TBLJAL` to save code size.

=== Jump table mode

In jump table mode the behaviour is to load the target address from `MTBLJVEC.base` with an offset which is XLEN/8 times the parameter.

[source,sourceCode,text]
----
switch(opcode) {
  # tmp is temporary internal state, it doesn't represent a real register
  # Mem is byte indexed
  # LINK is x0, x1, x5 depending on the index number and the watermarks
  switch(XLEN) {
    32:  {LW tmp, Mem[MTBLJVEC.base + n<<2][XLEN-1:0]; JALR LINK, tmp;}
    64:  {LD tmp, Mem[MTBLJVEC.base + n<<3][XLEN-1:0]; JALR LINK, tmp;}
    128: {LQ tmp, Mem[MTBLJVEC.base + n<<4][XLEN-1:0]; JALR LINK, tmp;}
  }
}
----

For the `vsprintf` example above, the table contains the base addresses of the functions.

[source,sourceCode,text]
----
MTBJALVECWM.wmx0 = 1 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 2 # c.tbljal #1 maps to JAL x5, c.tbljal #2+ map to JAL x1

MTBLJVEC.base+ 0(index 0) = # 100066c <__riscv_restore_0> # requires JAL x0
MTBLJVEC.base+ 8(index 2) = # 1000648 <__riscv_save_0>    # requires JAL x1
MTBLJVEC.base+12(index 3) = #  e08432 <vsnprintf>         # requires JAL x1
----

The functions are not moved in memory, the table lookup is only to give a reference to them using a 16-bit encoding.

=== Vector table mode

In vector table mode, execution passes directly to the scaled offset from the base register.
The entry points are scaled, according to `MTBLJVEC.scale`

|==================================================================
| `MTBLJVEC.scale` | `tablescale` 
| 0               | jump table mode
2+| *All other values are vector table mode*
| 1               | 8-bytes
| 2               | 16-bytes
| 3               | 32-bytes
2+| .....
| 10              | 4096-bytes to match minimum TBL page size
| 11-15           | *reserved*
|==================================================================

Note that in vector table mode, `tablescale = 4<<MTBLJVEC.scale`

[source,sourceCode,text]
----
c.tbljal #n ;# JALR LINK, Mem[MTBLJVEC.base + n*tablescale][XLEN-1:0];
----

This method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

Setting `MTBLJVEC.scale` to specific values does not set a requirement on the alignment of `MTBLJVEC.base`. For example if `tablescale=4096`, `MTBLJVEC.base` does _not_ need to be 4096-byte aligned. 

If `tablescale` is set to 4096 then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `MTBLJVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `MTBLJVEC.scale=2` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is 136 bytes, but will shrink to 128-bytes or smaller by use of `c.tbljal` so I have allocated the first 4 entries to it.

[source,sourceCode,text]
----

MTBJALVECWM.wmx0 = 1 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 2 # c.tbljal #1 maps to JAL x5, c.tbljal #2+ map to JAL x1

#index 0 (JAL x0)
MTBLJVEC.base+0 <__riscv_restore_0>:
 	4902                	lw	s2,0(sp)
 	4492                	lw	s1,4(sp)
 	4422                	lw	s0,8(sp)
 	40b2                	lw	ra,12(sp)
 	0141                	addi	sp,sp,16
 	8082                	ret

# index 2 (JAL x1)
MTBLJVEC.base+32  <__riscv_save_0>:
 	1141                	addi	sp,sp,-16
 	c04a                	sw	s2,0(sp)
 	c226                	sw	s1,4(sp)
 	c422                	sw	s0,8(sp)
 	c606                	sw	ra,12(sp)
 	8282                	jr	t0

# index 3-6 (JAL x1)
MTBLJVEC.base+48: <vsnprintf>
  	xxxx                	tbljal #5 ;# call to <__riscv_save_0>
  ...  up to 128-byte function body ...
  	xxxx                	tbljal #4 ;# call to <__riscv_restore_0>
----

== Caching

For improved performance, the implementation may cache the contents of the table, for either mode. To assist this and avoid unnecessary memory fetches, we state that the table contents may be cached without consistency checks against memory outside the hart if `MTBLJVEC` has not been written to. 

Any write to `MTBLJVEC`, even if the actual value is not updated, will indicate that any table caching must be flushed and refetched.

Therefore if there are any updates to generated code in the table in vector mode, a write to `MTBLJVEC` is required to ensure that any cached contents are not stale.




