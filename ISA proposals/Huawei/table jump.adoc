= RISC-V Table Jump ISA Proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16/32-bit instructions to allow table jumps to reduce the code size of `JAL` / `JALR` instructions.

* replace 32-bit `JAL` calls to 16-bit `C.TBLJAL`
* replace 64-bit `AUIPC/JALR` calls to fixed locations with either a 16-bit `C.TBLJAL` or a 32-bit `TBLJAL` 
** `[C.]TBLJAL` can be used replace `JALR` if it jumps to a fixed target, which is typically inferred as an `AUIPC/JALR` sequence because the offset from the PC is out of the +/-1MB range.
* RV64 does not have `C.JAL` so `C.TBLJAL` is even more valuable
* the 32-bit encoding allows more functions to be called, but saves less code size, so the most common functions should be callable by the 16-bit encoding

The 32-bit instruction encoding will ensure that 64-bit sequences are unlikely to be needed to call functions, unless the table is full. Additional functionality may be added TBD.

== Issues 

. what additional functionality to add in the 32-bit version, if any?
. see <<pros-and-cons>>, currently it seems that we should only implement table jump mode, but more discussion is required

== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  #64-bit AUIPC/JALR sequence
  e084be:	001f8317            auipc t1,0x1f8
  e084c2:	18a302e7            jalr  t0,394(t1) # 1000648 <__riscv_save_0>
  
  e084c6:	86b2                mv    a3,a2
  e084c8:	862e                mv    a2,a1
  e084ca:	800005b7            lui	  a1,0x80000
  e084ce:	fff5c593            not	  a1,a1
  
  #32-bit JAL
  e084d2:	f61ff0ef            jal	  ra,e08432 <vsnprintf> # vsnprintf
  
  #64-bit AUIPC/JALR sequence
  e084d6:	001f8317            auipc	t1,0x1f8
  e084da:	19630067            jr	  406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJAL` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	xxxx                tbljal #x ;#<mapped to __riscv_save_0>, saving 6-bytes
  
  e084c6:	86b2                mv     a3,a2
  e084c8:	862e                mv     a2,a1
  e084ca:	800005b7            lui	   a1,0x80000
  e084ce:	fff5c593            not	   a1,a1
  
  e084d2:	xxxx                tbljal #y ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  
  e084da:	xxxx                tbljal #z ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of `TBLJALENTRIES` addresses for `[C.]TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. Not all functions are reduced by this much.

== 16-bit Opcode Assignment

[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  |1 8+|                index8           2+| 00  | C.TBLJAL
|=============================================================================================

The 16-bit encoding allows half of the `TBLJALENTRIES` to be accessed (_to be confirmed_).

== 32-bit Opcode Assignment

[width="100%",options=header]
|============================================================================
|31:23  |23:15   |14:12 |11:7  |6:0     |name
|xxxxxx |index9  |001   |xxxxx |xxxxxxx |TBLJAL
|============================================================================

`TBLJALENTRIES` is defined by the `index9` field in the 32-bit encoding, so initially 512 (_to be confirmed_).

== Operating Modes

Three operating modes are proposed.
All require the following CSR:

[#xTBLJALVEC-table]
.`xTBLJALVEC` definition
[width="100%",options=header]
|=============================================================================================
| XLEN-1:6       |5:2   | 1: 0  | CSR        | Permissions | Status
| base[XLEN-1:6] |scale | mode  | MTBLJALVEC | MRW         | Required if jump table mode is implemented
| base[XLEN-1:6] |scale | mode  | STBLJALVEC | MRW         | Required if S-mode is implemented
| base[XLEN-1:6] |scale | mode  | UTBLJALVEC | MRW         | Optional
|=============================================================================================

* M-mode always uses `MTBLJALVEC.base`
* S-mode always uses `STBLJALVEC.base`
* U-mode uses `UTBLJALVEC.base` if implemented, otherwise `STBLJALVEC.base` if implemented, otherwise `MTBLJALVEC.base`

`xTBLJALVEC.base` is a virtual address, whenever virtual memory is enabled (i.e. S and U-modes only if implemented and enabled).

Using `xTBLJALVEC.base` in the pseudo code below implicitly assumes that `xTBLJALVEC.base[5:0]=0`. This is consistent with the description of `xTVEC` in the Unprivileged ISA manual.

`xTBLJALVEC.base` is naturally aligned for all legal values of `XLEN`.

The memory pointed to by `xTBLJALVEC.base` only requires eXecute permission for all three proposed modes. Read/Write access is not required once the jump table/vector table has been configured.

[#xTBLJALVEC-mode-table]
.`xTBLJALVEC.mode` definition
[width="100%",options=header]
|=============================================================================================
| Mode | Comment
| 00   | Jump table mode
| 01   | Vector table mode
| 10   | Emulation mode
| 11   | *reserved*
|=============================================================================================

Which modes are in the final specification is up for debate.

`xTBLJALVEC.mode` is a WARL field, so can only be programmed to modes which are implemented. Therefore the discovery mechanism is to attempt to program different modes and read back the values to see which are available.

[NOTE]

  `xTBLJALVEC.scale` is used for the vector table mode.

=== Jump table mode

In jump table mode the behaviour is to load the target address from `xTBLJALVEC.base` with an offset which is XLEN/8 times the parameter passed to the instruction. Bits [1:0] of the target address represent which link register is in use, and whether the entry is legal. Therefore the target functions must be word aligned in memory.

The functions are not moved in memory, the table lookup is only to give a reference to them using a 16-bit encoding whenever possible.


[#entry-lsbs]
.bits [1:0] of each jump table entry
[width="100%",options=header]
|=============================================================================================
| Value| Link Register
| 00   | link to x0
| 01   | link to x1
| 10   | link to x5
| 11   | *reserved / table entry is illegal*
|=============================================================================================

[NOTE]

  If the vector table mode is accepted (requiring the `MTBLJALCFG` CSR to be implemented) we may decide to use the watermarks and maximum entries from that instead of using the LSBs of the table entries. This would allow the target functions to be 16-bit aligned in memory.

==== Pseudo-code for jump table mode

[source,sourceCode,text]
----
# tmp is temporary internal state, it doesn't represent a real register
# Mem is byte indexed
# n is the immediate operand passed to [c.]tbljal
switch(XLEN) {
  32:  LW tmp, Mem[xTBLJALVEC.base + n<<2][XLEN-1:0];
  64:  LD tmp, Mem[xTBLJALVEC.base + n<<3][XLEN-1:0];
  128: LQ tmp, Mem[xTBLJALVEC.base + n<<4][XLEN-1:0];
}
switch(tmp[1:0]) {
  0: JALR x0, tmp[XLEN-1:2]<<2;
  1: JALR x1, tmp[XLEN-1:2]<<2;
  2: JALR x5, tmp[XLEN-1:2]<<2;
  #MEPC is the PC of the [c.]tbljal, not tmp
  3: take_illegal_instruction_exception();
}
----

For the `vsprintf` example above, the jump table contains the following:

[source,sourceCode,text]
----
xTBLJALVEC.base+ 0(index 0) = # 100066c <__riscv_restore_0> # requires JAL x0 so [1:0]=00
xTBLJALVEC.base+ 8(index 1) = # 100064a <__riscv_save_0>    # requires JAL x5 so [1:0]=10
xTBLJALVEC.base+12(index 2) = #  e08433 <vsnprintf>         # requires JAL x1 so [1:0]=01
----

==== Exceptions for jump table mode

The only illegal instruction exception is if the jump table LSBs are set to `11`. If this happens `MEPC` is set to the PC of the `[c.]tbljal` instruction.

=== Vector table mode

Vector table mode is very similar to vectored interrupt handling. The target address is a scaled offset from the base vector. Therefore in vector table mode, execution passes directly to the scaled offset from the base register, not via a jump table.

`xTBLJALVEC.scale` controls the scale.

[width="100%",options=header]
|==================================================================
|`xTBLJALVEC.scale`| `tablescale` 
| 0                | 8-bytes
| 1                | 16-bytes
| 2                | 32-bytes
2+| .....
| 9                | 4096-bytes to match minimum TLB page size
| 10+              | *reserved*
|==================================================================

Note that `tablescale = 1<<(xTBLJALVEC.scale+3)`

`MTBLJALCFG` controls the valid entries in the table and the _watermarks_ which are used to control which link register is in use for each table entry.

[#MTBLJALCFG-table]
.`MTBLJALCFG` definition
[width="100%",options=header]
|================================================================================================================
| XLEN-1:24       | 23:16    | 15:8 |  7: 0  | CSR         | Permissions | Status
| ROZ             |maxentry  | wxm5 | wmx0   | MTBLJALCFG  | MRW         | Required if vector mode is implemented
| ROZ             |maxentry  | wxm5 | wmx0   | STBLJALCFG  | SRW         | Required if S-mode is implemented
| ROZ             |maxentry  | wxm5 | wmx0   | UTBLJALCFG  | URW         | Optional
|================================================================================================================

* M-mode always uses `MTBLJALCFG`
* S-mode always uses `STBLJALCFG`
* U-mode uses `UTBLJALCFG` if implemented, otherwise `STBLJALCFG` if implemented, otherwise `MTBLJALCFG`


[NOTE]

  The range of `MTBLJALCFG.maxentry` is from 0 to `TBLJALENTRIES-1`

[NOTE]
  All 3 fields are _unsigned_ integers

==== Watermarks

The two watermark fields are used to control which tables entries link to

*  `x0` (i.e. `J` not `JAL`)
*  `x1` (`ra`, standard link register)
*  `x5` (alternate link register for millicode routines)

Depending upon the programming, table entries can all be allocated to 1, 2 or all 3 link registers.

In the table MAX is `TBLJALENTRIES-1` (255)

[#MTBLJALCFG-table-watermark-end-conditions]
.`MTBLJALCFG` watermarks
[width="100%",options=header]
|==================================================================================================================
|`MTBLJALCFG.wmx0`  |`MTBLJALCFG.wmx5`| `JAL x0` range | `JAL x5` range | `JAL x1` range | Comment
6+| Normal programming model, use all 3 link registers
| X, X>0            | Y, Y>X          |*0 to X-1*      |*X to Y-1*      |*Y to MAX*      | Use all 3 link registers
6+| Restricted programming model, exclude 1 or 2 link registers
| 0                 |  MAX            |*0 to MAX*      |_none_          |_none_          | Only link to x0   
| MAX               |  MAX            |_none_          |*0 to MAX*      |_none_          | Only link to x5      
| 0                 | 0               |_none_          |_none_          |*0 to MAX*      | Only link to x1
| 0                 | Y, Y>0          |*0 to Y-1*      |_none_          |*Y to MAX*      | Only link to x0, x1
| X, X>0            | X               |_none_          |*0 to X-1*      |*X to MAX*      | Only link to x1, x5
6+| reserved for future use
| Z                 | <Z            3+|illegal instruction                               | *reserved*
|==================================================================================================================

Some of the modes may not be so useful, so we can consider restricting them, for example

- only link to x5 (only millicode routines)
- only link to x1, x5 (no J equivalent)
- _this needs review, but in general I'd like the specification to be flexible_

With the proposed encodings 

- the 16-bit encoding can access entry 0 to min(127, `MTBLJALCFG.maxentry`)
- the 32-bit encoding can access entry 0 to min(255, `MTBLJALCFG.maxentry`)

[#MTBLJALCFG-table-watermark-examples]
.`MTBLJALCFG` watermark examples
[width="100%",options=header]
|==========================================================================================================================
|`MTBLJALCFG.wmx0`  |`MTBLJALCFG.wmx5`|`JAL x0` range|`JAL x5` range| `JAL x1` range 
| 20                | 40              |*0 to 19*     |*20 to 39*    |*40 to 255*
| 0                 | 40              |*0 to 39*     |_none_        |*40 to 255*
| 40                | 40              |_none_        |*0 to 39*     |*40 to 255*
| 40                | 39            3+| *reserved*
| 0                 | 255             |*0 to 255*    |_none_        |_none_
| 255               | 255             |_none_        |*0 to 255*    |_none_
| 0                 | 0               |_none_        |_none_        |*0 to 255*               
|==========================================================================================================================

`JAL x1` is always highest in the range (if enabled), so that the 32-bit encoding typically adds more cases using `x1` to convert `AUIPC/JALR x1` sequences to `TBLJAL` to save code size.

.watermark example
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump2.PNG[watermark example]

==== Exceptions for vector table mode

Take an illegal instruction exception if `[C.]TBLJAL #n` is executed and one of more of these conditions are true:

- `n > MTBLJALWM.maxentry` 
- `MTBLJALWM.wmx5 < MTBLJALWM.wxm0` 
- `MTBLJALWM.wmx0 > MTBLJALWM.maxentry` 
- `MTBLJALWM.wmx5 > MTBLJALWM.maxentry`

All comparisons are _unsigned_.

==== Pseudo-code for vector table mode

[source,sourceCode,text]
----
# Mem is byte indexed
# LINK is x0, x1, x5 depending on the index number and the watermarks
if (n > MTBLJALCFG.maxentry OR MTBLJALWM.wmx5 < MTBLJALWM.wxm0) {
  take_illegal_instruction_exception();
  }
JALR LINK, Mem[xTBLJALVEC.base + n*tablescale][XLEN-1:0];
----

==== vector table code

Because this method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

Setting `xTBLJALVEC.scale` to specific values does not set a requirement on the alignment of `xTBLJALVEC.base`. For example if `tablescale=4096`, `xTBLJALVEC.base` does _not_ need to be 4096-byte aligned. 

If `tablescale` is set to 4096 then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `xTBLJALVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `xTBLJALVEC.scale=1` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is 136 bytes, but will shrink to 128-bytes or smaller by use of `c.tbljal` so I have allocated 4 entries to it.

[source,sourceCode,text]
----

MTBJALVECWM.wmx0 = 0 # c.tbljal #0 maps to JAL x0
MTBJALVECWM.wmx5 = 1 # c.tbljal #1+ map to JAL x1

#index 0 (JAL x0)
xTBLJALVEC.base+0 <__riscv_restore_0>:
 	4902                	lw	s2,0(sp)
 	4492                	lw	s1,4(sp)
 	4422                	lw	s0,8(sp)
 	40b2                	lw	ra,12(sp)
 	0141                	addi	sp,sp,16
 	8082                	ret

# index 2 (JAL x1)
xTBLJALVEC.base+32  <__riscv_save_0>:
 	1141                	addi	sp,sp,-16
 	c04a                	sw	s2,0(sp)
 	c226                	sw	s1,4(sp)
 	c422                	sw	s0,8(sp)
 	c606                	sw	ra,12(sp)
 	8282                	jr	t0

# index 3-6 (JAL x1)
xTBLJALVEC.base+48: <vsnprintf>
  	xxxx                	tbljal #5 ;# call to <__riscv_save_0>
  ...  up to 128-byte function body ...
  	xxxx                	tbljal #4 ;# call to <__riscv_restore_0>
----

[NOTE]

  This mode may waste memory as the target functions are very unlikely to all be multiples of `tablescale`.

=== Emulation Mode

Emulation mode is the simplest. It doesn't have a jump table or vector table, so allow a minimal hardware implementation.
It relies on the values in temporary registers not being maintained across function calls.

No illegal instruction exceptions are possible in emulation mode.

==== Pseudo-code for emulation mode

[source,sourceCode,text]
----
t4 = next_PC; #PC+2 for c.tbljal, PC+4 for tbljal
t5 = n;       #immediate operand
J xTBLJALVEC.base
----

[#pros-and-cons]
== Pros and cons

Jump table mode is easy to implement in the linker and doesn't affect the compiler at all as it is only a link time optimisation. It may complicate instruction fetch due to the indirection, and so may cost performance. The instruction fetch can choose the cache the table.

Vector table mode is simplest for the hardware, as it's just the same mechanism as for the interrupt handler vector. The jump is direct to the destination. However the compiler would have to be aware as it will have to try to fit functions into the table, as each entry is a fixed size so it's not so obviously implementable in the toolchain. We may find other reasons for having this mode. TBD.

Emulation mode - there are concerns about overwriting the temporary registers, so I'm not sure about this at the moment.

== Diagram for all modes

.all three modes
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/tbljump4.PNG[all three modes]

== Context Switching

The `xTBLJALVEC` (for all modes) and `xTBLJALCFG` (for vector table mode) form part of the current context, and so will need to be saved and restored. It is also possible for the jump table to have a single configuration for all contexts, but in general `xTBLJALVEC` and `xTBLJALCFG` are considered part of the context.

== Caching (jump / vector table modes)

For improved performance, the implementation may cache the contents of the jump / vector table. To assist this and avoid unnecessary memory fetches, we state that the table contents may be cached without consistency checks against memory outside the hart if `xTBLJALVEC` has not been written to. 

Any write to `xTBLJALVEC`, even if the actual value is not updated, will indicate that any table caching must be flushed and refetched.

Therefore if there are any updates to generated code in the table in vector mode, a write to `xTBLJALVEC` is required to ensure that any cached contents are not stale. This is not expected to be the common case, because in the absence of dynamically linked libraries, the jump table/vector table is static for a given executable. Therefore the recommendation is that it is set with eXecute only privileges as the rest of the code is. This is better for security to prevent code in the vector table being scanned for gadgets. The jump table also only requires eXecute privileges.


== Power/performance of Jump Table mode

The instruction fetch unit could cache the most frequently accessed table jump targets to improve performance. The management of this caching will cost some power (although the ~ 10% code size saving should save power overall by reducing the number of instruction fetches).

An alternative approach is to for the instruction fetch to cache a certain range of table jump indices, e.g. 0-31. The linker could be configured to place the most frequently used table jump indices into this range so that static caching can be used. For this to be successful the linker would need information about the dynamic call frequency of each function call.

== Benchmarking Jump Table Mode

https://github.com/riscv/riscv-code-size-reduction/blob/master/meeting_minutes/code%20size%20meeting%20slides%2020210126.pdf[See this presentation, the "bigger benchmarks" slide]

== Security (future ideas for vector mode)

The vector mode mechanism could be reused for security in the future. It is possible to define that the memory allocated to to the table can only have entry points on the specific vectors, and also only from `[C.]TBLJAL` instructions. In this way sensitive code can be placed in the table which cannot be reused for ROP/JOP gadgets, because the code cannot be targetted by `JALR` instructions.

These ideas will not be pursued as part of the code size work.



