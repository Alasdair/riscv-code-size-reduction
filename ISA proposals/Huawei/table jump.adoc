= RISC-V Table Jump ISA Proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 16-bit instructions to allow table jumps to reduce the code size of `JAL` / `JALR` instructions.
The 32-bit instruction will ensure that 64-bit sequences are not needed to call functions, and additional functionality may be added TBD.

== Issues 

. what functionality to add in the 32-bit verson, if any, for example is there any reason to table the table index field larger?
. maybe allow x1 or x5 as the link reg for TBLJAL?

== Rationale

Function calls and jumps to fixed labels typically take 32-bit or 64-bit instruction sequences.
Here's an example from the Huawei IoT code, GCC output:

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	001f8317          	auipc	t1,0x1f8
  e084c2:	18a302e7          	jalr	t0,394(t1) # 1000648 <__riscv_save_0>
  e084c6:	86b2                	mv	a3,a2
  e084c8:	862e                	mv	a2,a1
  e084ca:	800005b7          	lui	a1,0x80000
  e084ce:	fff5c593          	not	a1,a1
  e084d2:	f61ff0ef          	jal	ra,e08432 <vsnprintf>
  e084d6:	001f8317          	auipc	t1,0x1f8
  e084da:	19630067          	jr	406(t1) # 100066c <__riscv_restore_0>
----

using `C.TBLJ[AL]` we can reduce this as follows (accepting gaps in the PCs as code has been deleted)

[source,sourceCode,text]
----
00e084be <vsprintf>:
  e084be:	xxxx              	tbljal #0 ;#<mapped to __riscv_save_0>, saving 6-bytes
  e084c6:	86b2                	mv	a3,a2
  e084c8:	862e                	mv	a2,a1
  e084ca:	800005b7          	lui	a1,0x80000
  e084ce:	fff5c593          	not	a1,a1
  e084d2:	xxxx              	tbljal #1 ;#<mapped to vsnprintf>, saving 2-bytes (8-byte refs to this fn also exist)
  e084da:	xxxx              	tblj #2 ;#<mapped to __riscv_restore_0>
----

The principle is to have a single lookup table of addresses for `C.TBLJ` and `C.TBLJAL`, which is built by the linker. The linker then substitutes the code as shown in the example above where the 32-byte function is reduced to 18-bytes giving ~ 56% saving. Clearly the lookup table takes some space, but this is a minimal overhead for repeated functions such as the save/restore routines. Not all functions are reduced by this much.

Note that `C.TBLJ` is less frequent than `C.TBLJAL` so the 16-bit encoding can be optimised to have a smaller index into the table.

== 16-bit Opcode Assignment

|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1  4+| 1011       5+| index5              2+| 00  | C.TBLJ
3+|  100       | 1  | 1  2+| 11 7+|         index7              2+| 00  | C.TBLJAL
|=============================================================================================

With the proposed encoding, routines called with `C.TBLJ` must be in the lowest quarter of the table. 

== 32-bit Opcode Assignment

|============================================================================
|31:22  |21:15  |14:12 |11:7  |6:0     |name
|xxxxxx |index7 |000   |xxxxx |xxxxxxx |TBLJ
|xxxxxx |index7 |001   |xxxxx |xxxxxxx |TBLJAL
|============================================================================

In the 32-bit encoding, the full range is allowed for `TBLJ`. It would be possible to make the table index field larger then 7 bits, but it's not clear that this would be useful.

== CSR and Modes

Two modes are proposed for the lookup table

- simple jump table (`MTBLJVEC.scale`=0)
- vector table, similar to the interrupt handler vector (`MTBLJVEC.scale>0`)

|=============================================================================================
| XLEN-1:4          | 3: 0  | CSR       | Permissions
| base[XLEN-1:4]    | scale | MTBLJVEC  | MRW
|=============================================================================================

=== Jump table mode

In jump table mode the behaviour is to load the target address from `MTBLJVEC.base` with an offset which is XLEN/8 times the parameter.

[source,sourceCode,text]
----
switch(opcode) {
  # tmp is temporary internal state, it doesn't represent a real register
  c.tblj:   
    switch(XLEN) {
      32:  {LW tmp, Mem[MTLBJVEC.base + n<<2][XLEN-1:0]; JR tmp;}
      64:  {LD tmp, Mem[MTLBJVEC.base + n<<3][XLEN-1:0]; JR tmp;}
      128: {LQ tmp, Mem[MTLBJVEC.base + n<<4][XLEN-1:0]; JR tmp;}
    }
  c.tbljal:   
    switch(XLEN) {
      32:  {LW tmp, Mem[MTLBJVEC.base + n<<2][XLEN-1:0]; JALR ra, tmp;}
      64:  {LD tmp, Mem[MTLBJVEC.base + n<<3][XLEN-1:0]; JALR ra, tmp;}
      128: {LQ tmp, Mem[MTLBJVEC.base + n<<4][XLEN-1:0]; JALR ra, tmp;}
    }
}
----

For the `vsprintf` example above, the table contains the base addresses of the functions.

[source,sourceCode,text]
----
MTLBJVEC.base+0 = # 1000648 <__riscv_save_0>
MTLBJVEC.base+4 = #  e08432 <vsnprintf>
MTLBJVEC.base+8 = # 100066c <__riscv_restore_0>
----

The functions are not moved in memory, the table lookup is only to give a reference to them using a 16-bit encoding.

=== Vector table mode

In vector table mode, execution passes directly to the scaled offset from the base register.
The entry points are scaled, according to `MTLBJVEC.scale`

|==================================================================
| `MTLBJVEC.scale` | `tablescale` 
| 0               | jump table mode
2+| *All other values are vector table mode*
| 1               | 8-bytes
| 2               | 16-bytes
| 3               | 32-bytes
2+| .....
| 10              | 4KB bytes to match minimum TLB page size
| 11-15           | *reserved*
|==================================================================

Note that in vector table mode, `tablescale = 4<<MTLBJVEC.scale`

[source,sourceCode,text]
----
c.tblj   #n ;# JR       Mem[MTLBJVEC.base + n<<tablescale];
c.tbljal #n ;# JALR ra, Mem[MTLBJVEC.base + n<<tablescale];
----

This method doesn't have the jump table - the code is actually placed in the table. If the code is too large to fit then it will have to call a routine outside the table, or use more than one entry which invalidates one or more table entries.
This avoids an additional redirection to get to the actual code, assuming the whole body of the code actually fits in the table.

If the scale is set to 4K then this allows each entry in the table to be owned by different privilege domain, which can manange its own code. `MTLBJVEC` must be changed by machine mode only so as the table refers to the system as a whole.

In a way this approach is similar to a *flash patch* mechanism, where the code can be patched by replacing an instruction with a 32-bit or 16-bit encoding of `TBLJ[AL]` to call an alternative routine to fix a bug, or add functionality. Although this requires write permission on the code area so cannot work on a boot ROM for example, but it can form the basis of such a mechanism.

For the `vsprintf` example above `riscv_save_0` / `riscv_restore_0` each take 12 bytes, and `MTLBJVEC.scale=1` (16 bytes per entry) so the actual code is placed in the table. `vsprintf` is much larger so I have placed the function prologue in the table, and the body elsewhere to mimimise memory wastage. The original `vsprintf` function is 136-bytes. After shrinking due to use of `c.tblj[al]` it would fit within 4 entries so I could allocate entries 1-4 and make `__riscv_restore_0` entry 5 instead of entry 2.

[source,sourceCode,text]
----

MTBLJVEC.base+0  <__riscv_save_0>:
 MTBLJVEC.base+0 :	1141                	addi	sp,sp,-16
 MTBLJVEC.base+2 :	c04a                	sw	s2,0(sp)
 MTBLJVEC.base+4 :	c226                	sw	s1,4(sp)
 MTBLJVEC.base+6 :	c422                	sw	s0,8(sp)
 MTBLJVEC.base+8 :	c606                	sw	ra,12(sp)
 MTBLJVEC.base+10:	8282                	jr	t0

MTBLJVEC.base+16: <vsnprintf>
  MTBLJVEC.base+16:	xxxx                	tlbjal #0 ;# call to <__riscv_save_0>
  MTBLJVEC.base+18:	xxxx                	#### prologue
  ...
  MTBLJVEC.base+28:	xxxx                	j <_vsnprintf_body> ;# call rest of function
 
  

MTBLJVEC.base+32 <__riscv_restore_0>:
 MTBLJVEC.base+32:	4902                	lw	s2,0(sp)
 MTBLJVEC.base+34:	4492                	lw	s1,4(sp)
 MTBLJVEC.base+36:	4422                	lw	s0,8(sp)
 MTBLJVEC.base+38:	40b2                	lw	ra,12(sp)
 MTBLJVEC.base+40:	0141                	addi	sp,sp,16
 MTBLJVEC.base+48:	8082                	ret


----

== Caching

For improved performance, the implementation may cache the contents of the table, for either mode. To assist this and avoid unnecessary memory fetches, we state that the table contents may be cached without consistency checks against memory outside the hart if `MTBLJVEC` has not been written to. 

Any write to `MTBLJVEC`, even if the actual value is not updated, will indicate that any table caching must be flushed and refetched.

Therefore if there are any updates to generated code in the table in vector mode, a write to `MTBLJVEC` is required to ensure that any cached contents are not stale.




