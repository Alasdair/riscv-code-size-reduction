= RISC-V 32-bit code-size reduction extension proposal
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

See the latest status of the instruction proposals and benchmarking results https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/README.adoc[here]

This document describes 32-bit instructions proposed to help reduce code-size.
They are split into v1.0 and `future` instructions. For the time being we will only analyse v1.0 instructions and push to ratify a subset of those in 2021. 
New proposals will be added into the `future` instructions category.

Currently all are encoded in the CUSTOM encodings, after a set of instructions is chosen for v1.0, encodings will be allocated. 
Some of the encodings are 32-bit versions of proposed 16-bit encodings, and others are new.

All instructions in _italics_ are for the `future`

== Issues

. Anders requested load/stores with scaled offsets, which have not yet been considered
. Andy Glew also suggested this for accessing variables in arrays using a loop counter - so that the loop variable can be used directly
.. eg `load rd := M[rs1+rs2<<scaleImm]` so `rs2` is the unmodified loop counter
. Andy Glew suggested `incblz rd,target`
.. `rd += 1; if( rd < 0 ) goto target` 
.. this requires no immediate value for comparison, so requires the loop counter to start negative and count up, so gives a bigger branch offset range
. I'm worried that `c.slli + c.add` is not the right solution for compiling softfloat as it overwrites the shifted operand compared to 32-bit encoding for `addshf`, I think we may need `addshf/orshf` TBD
. Andes Performance Extension has `beqc/bnec` which are similar to `beqi` but the constant ranges are different (`cmpimm[6:0]` and `offset[10:1]`). Do we need `bnec`? And do we need the other instructions `blti` etc? At the time the compiler team requested a full set of comparisons, which is why we added them all.  It would be better to remove `blti`, `bgei` if we can (need compiler expert input) as they're not so useful.

== v1.0 proposal

The v1.0 proposed instructions will tentatively be included in the first version of the code-size reduction extension.
This should not be taken as a final set at this stage. Any instruction may be rejected or postponed to `future`.

=== v1.0 Opcode Assignment and semantics

[#v1.0 proposed-32bit-encodings]
.proposed 32-bit encodings for v1.0
[width="100%",options=header]

|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
18+| *custom-0 encoding group (all architectures), PUSH/POP and friends*
2+|000         |e |ra 2+|frcount  2+|rcount         3+|spimm          | 000   4+| 00000             |0001011| POP
2+|001         |e |ra 2+|frcount  2+|rcount         3+|spimm          | 000   4+| 00000             |0001011| POPRET
2+|010         |e |ra 2+|frcount  2+|rcount         3+|spimm          | 000   4+| 00000             |0001011| PUSH
18+| *custom-0 encoding group (all architectures), compare-immediate-branch*
6+| cmpimm[7:0]                   2+|  offset[9:6]  3+| rs1           | 001   4+| offset[5:1]       |0001011| BEQI
6+| cmpimm[7:0]                   2+|  offset[9:6]  3+| rs1           | 010   4+| offset[5:1]       |0001011| BNEI
18+| *custom-0 encoding group (all architectures), GP relative load/store, allowing X3 (tp=0) and X4 (tp=1) as GPs*
 8+|imm[11:2, 17:16]                                3+| rs1           | 011   3+| imm[15:12]    | tp|1011011| LWGP
 5+|imm[11:5]                3+| rs2                2+|imm[15:12]|tp  | 110   4+| imm[4:2, 17:16]   |1011011| SWGP
18+| *https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from B-extension]*
8+|imm[11:0]                                          |00 2+|rs1'   2+| 11100         3+| rd'       |0011011| MULI
7+|imm[11:0]                           |rs2'          |00 2+|rs1'   2+| 11100         3+| rd'       |0011011| MULIADD
7+|imm[11:0]                           |rs2'          |00 2+|rs1'   2+| 11101         3+| rd'       |0011011| ADDIADD
18+| *table jump - no encodings yet*
7+|xxxxxx 4+|index8 |001   4+|xxxxx |xxxxxxx |TBLJAL
|=========================================================================================================================

[#v1.0semantics]
.v1.0 semantics
[width="100%",options=header]
|==============================================================================================================================================================================================
|instruction           | definition
| POP                  | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers]
| POPRET               | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers and return]
| PUSH                 | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[PUSH registers]
| TBLJAL               | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[Table jump and link]
| BEQI                 | if (rs1==sign_ext(cmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BNEI                 | if (rs1< sign_ext(cmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| LWGP                 | base=(tp==1)?tp:gp; rd=zero_ext(Memory[base+sign_ext(imm)][31:0]);
| SWGP                 | base=(tp==1)?tp:gp; Memory[base+sign_ext(imm)][31:0])=rs2[31:0];
| MULI                 | rd' = rs1' * sign_ext(imm)
| MULIADD              | rd' = rs1' + rs2' * sign_ext(imm)
| ADDIADD              | rd' = rs1' + rs2' + sign_ext(imm)
|==============================================================================================================================================================================================

https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[See this document for `muliadda/muliaddb`] which is for the existing ISA extension available on silicon which  has different encoding for `muliadd`.

=== v1.0 Assembly Examples

[source,sourceCode,text]
----
beqi  a5,1,e005e2       # if (a5== 1) branch_target=0xe005e2; else branch_target=PC+4; //signed comparison
bnei  a5,4,e06222       # if (a5!= 4) branch_target=0xe06222; else branch_target=PC+4; //signed comparison

lw  a1,0xfffff(gp)      # will use LWGP if immediate is out of range for LW
sw  a1,0xfffff(tp)      # will use SWGP if immediate is out of range for SW

muliadd  a1, a2, a3,20  # a1 = a2 + (a3 * 20) 

----

== `Future` Proposals

These instructions may be included in a later revision of the code-size reduction ISA extension.

=== `Future` Opcode Assignment and semantics

[#`Future` proposed-32bit-encodings]
.proposed 32-bit encodings for the `future`
[width="100%",options=header]

|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23:20            | 19:16 |15 | 14:12        | 11:9        | 8 | 7 | 6 : 0 | instruction
15+| *custom-0 encoding group (all architectures), PUSH/POP and friends*
2+|000         |e |ra 2+|frcount    |rcount         2+|spimm     | 000        3+| 00000               |0001011| _POPINT_
2+|010         |e |ra 2+|frcount    |rcount         2+|spimm     | 000        3+| 00000               |0001011| _PUSHINT_
2+|011         |e |ra 2+|frcount    |rcount         2+|spimm     | 000        3+| 00000               |0001011| _PUSHZERO_
15+| *custom-0 encoding group (all architectures), load/store multiple, .U means update address after spec to follow*
|set  6+| mask32[13:3]                              2+| rs1      | 110          |  mask32[2:0]| 0 | 0 |0001011| _LWM_
|set  6+| mask32[13:3]                              2+| rs1      | 110          |  mask32[2:0]| 0 | 1 |0001011| _LWM.U_
|set  6+| mask32[13:3]                              2+| rs1      | 110          |  mask32[2:0]| 1 | 0 |0001011| _SWM_
|set  6+| mask32[13:3]                              2+| rs1      | 110          |  mask32[2:0]| 1 | 1 |0001011| _SW.MU_
15+| *custom-0 encoding group (all architectures), load/store arbitrary pair of registers*
15+| *should use an odd/even reg pair, giving 5 bits more immediate and maybe 1 more bit from the reg field*
2+|000       3+| imm[5:2]    2+|   rd2              2+| rs1      | 111        3+|  rd                 |0001011| _LWP_
2+|001       3+| imm[5:2]    2+|   rs2              2+| rs1      | 111        3+|  rs3                |0001011| _SWP_
15+| *custom-0 encoding group (all architectures), pre-index loads with address writeback*
2+|010       5+| imm[8:0]                           2+| rs1      | 111        3+|  rd                 |0001011| _LBU.U_
2+|011       5+| imm[8:0]                           2+| rs1      | 111        3+|  rd                 |0001011| _LHU.U_
2+|100       5+| imm[8:0]                           2+| rs1      | 111        3+|  rd                 |0001011| _LW.U_
2+|101       3+| imm[8:5]    2+| rs2                2+| rs1      | 111        3+| imm[4:0]            |0001011| _SB.U_
2+|110       3+| imm[8:5]    2+| rs2                2+| rs1      | 111        3+| imm[4:0]            |0001011| _SH.U_
2+|111       3+| imm[8:5]    2+| rs2                2+| rs1      | 111        3+| imm[4:0]            |0001011| _SW.U_
15+| *custom-0 encoding group (all architectures), PC relative load*
2+|000       5+| imm[8:1, 9]                        2+| rs1      | 000        3+|  rd                 |0101011| _LWPC_
15+| *custom-0 encoding group (all architectures), post-index loads with address writeback*
2+|010       5+| imm[8:0]                           2+| rs1      | 000        3+|  rd                 |1011011| _LBU.PU_
2+|011       5+| imm[8:0]                           2+| rs1      | 000        3+|  rd                 |1011011| _LHU.PU_
2+|100       5+| imm[8:0]                           2+| rs1      | 000        3+|  rd                 |1011011| _LW.PU_
2+|101       3+| imm[8:5]    2+| rs2                2+| rs1      | 000        3+| imm[4:0]            |1011011| _SB.PU_
2+|110       3+| imm[8:5]    2+| rs2                2+| rs1      | 000        3+| imm[4:0]            |1011011| _SH.PU_
2+|111       3+| imm[8:5]    2+| rs2                2+| rs1      | 000        3+| imm[4:0]            |1011011| _SW.PU_
|=========================================================================================================================

[NOTE] 

  maybe add preshifted arithmetic from https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_preshifted_arithmetic.rst[here??]

[#futuresemantics]
.`Future` semantics
[width="100%",options=header]
|=====================================================================================================================================================================================================
|instruction           | definition
| _POPINT_             | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[spec needs updating following the email thread]
| _PUSHINT_            | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[spec needs updating following the email thread]
| _PUSHZERO_           | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64.adoc[PUSH registers and ZERO the allocated memory]
| _LWM[.U]_            | spec to follow
| _SWM[.U]_            | spec to follow
| _LBU.U_              | rd=zero_ext(Memory[rs1+sign_ext(imm)][ 7:0]); rs1=rs1+1;
| _LHU.U_              | rd=zero_ext(Memory[rs1+sign_ext(imm)][15:0]); rs1=rs1+2;
| _LW.U_               | rd=zero_ext(Memory[rs1+sign_ext(imm)][31:0]); rs1=rs1+4;
| _SB.U_               | Memory[rs1+sign_ext(imm)][ 7:0]=rs2[ 7:0]; rs1=rs1+1;
| _SH.U_               | Memory[rs1+sign_ext(imm)][15:0]=rs2[15:0]; rs1=rs1+2;
| _SW.U_               | Memory[rs1+sign_ext(imm)][31:0]=rs2[31:0]; rs1=rs1+4;
| _LWPC_               | rd=Memory[PC+sign_ext(imm)]
| _LWP_                | rd=sign_ext(Memory[rs1+sign_ext(imm)][31:0]); rd2=sign_ext(Memory[rs1+sign_ext(imm)+4][31:0]);
| _SWP_                | Memory[rs1+sign_ext(imm)][31:0]=rs2; Memory[rs1+sign_ext(imm)+4][31:0]=rs3;
| _LBU.PU_             | rd=zero_ext(Memory[rs1][ 7:0]); rs1=rs1+1;
| _LHU.PU_             | rd=zero_ext(Memory[rs1][15:0]); rs1=rs1+2;
| _LW.PU_              | rd=zero_ext(Memory[rs1][31:0]); rs1=rs1+4;
| _SB.PU_              | Memory[rs1][ 7:0]=rs2[ 7:0]; rs1=rs1+1;
| _SH.PU_              | Memory[rs1][15:0]=rs2[15:0]; rs1=rs1+2;
| _SW.PU_              | Memory[rs1][31:0]=rs2[31:0]; rs1=rs1+4;
|=====================================================================================================================================================================================================

=== `Future` Assembly Examples

[source,sourceCode,text]
----
lbu a1, 4(t0)!          # load unsigned byte from t0+4 into a1, t0=t0+1
lhu a1, 4(t0)!          # load unsigned half from t0+4 into a1, t0=t0+2
lw  a1, 4(t0)!          # load word          from t0+4 into a1, t0=t0+4

lbu a1, (t0)4!          # load unsigned byte from t0 into a1, t0=t0+1
lhu a1, (t0)4!          # load unsigned half from t0 into a1, t0=t0+2
lw  a1, (t0)4!          # load word          from t0 into a1, t0=t0+4

lwp a5, s0, 32(t0)      # load  a5 from t0+32, s0 from t0+36
swp a5, s0, 32(t0)      # store a5 to   t0+32, s0 to   t0+36

sb  a1, 4(t0)!          # store byte to t0+4, t0=t0+1
sh  a1, 4(t0)!          # store half to t0+4, t0=t0+2
sw  a1, 4(t0)!          # store word to t0+4, t0=t0+4

sb  a1, (t0)4!          # store byte to t0, t0=t0+1
sh  a1, (t0)4!          # store half to t0, t0=t0+2
sw  a1, (t0)4!          # store word to t0, t0=t0+4
----


== Rejected instructions

