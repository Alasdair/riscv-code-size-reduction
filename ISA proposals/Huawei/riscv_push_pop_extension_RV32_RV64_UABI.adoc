= RISC-V Push/Pop Extension (UABI only version)
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describesï¼š

* 32-bit encodings for `PUSH/PUSH.F/PUSH.D, POP/POP.F/POP.D and `POPRET/POPRET.F/POPRET.D`
* 16-bit encodings for `C.PUSH, C.POP` and `C.POPRET` instructions 

The instructions are defined for RV32 and RV64 architectures I variants only, using the UABI. 

Future revisions may include:

* The E variant and EABI.
* RV128[FDQ]

These instructions are to reduce the code-size of function prologues and epilogues by using a single encoding to replace a sequence of instructions. 
They are designed to replace common function prologue/epilogue sequences, but will not replace all possible cases. 

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

* whether to share an encoding with `POP[RET]` and so maybe have fewer `POP` rcount values to save encoding space (for 16-bit)
* we could squeeze `rcount` and `frcount` into 1 bit fewer for the 32-bit encodings if we reduce the available options

== Assembler Syntax

[source,sourceCode,text]
----
//these encodings may be 16-bit or 32-bit depending upon the parameters
push     {<xreg_list>},  -<stack_adjustment>
pop      {<xreg_list>},   <stack_adjustment> 
popret   {<xreg_list>},   <stack_adjustment> 

//these encodings are 32-bit
push.f   {<fxreg_list>}, -<stack_adjustment> 
pop.f    {<fxreg_list>},  <stack_adjustment> 
popret.f {<fxreg_list>},  <stack_adjustment> 

//these encodings are 32-bit
push.d   {<fxreg_list>}, -<stack_adjustment> 
pop.d    {<fxreg_list>},  <stack_adjustment> 
popret.d {<fxreg_list>},  <stack_adjustment> 
----

. All variants of `PUSH` push the registers specified in `[f]xreg_list` to the stack, and then adjust the stack pointer by the `stack_adjustment`.
. All variants of `POP` pop the registers in `[f]xreg_list to the stack` from the stack, and then adjusts the stack pointer by the `stack_adjustment`.
. all variants of `POPRET` have the same behaviour as `POP`, followed by `RET`.

32-bit and 16-bit forms are available, the assembler should choose the 16-bit form if the parameters permit and the C extension is implemented.

The registers in `xreg_list` are in a comma separated list. The list must not be empty.

[source,sourceCode,text]
----
<reg_list>   ::= <xreg_list> | <fxreg_list>
<xreg_list>  ::= <ra> "," <xreg_range> | <ra> | <xreg_range>
<fxreg_list> ::= <ra> "," <xreg_range> ", " <freg_range> | <ra> "," <freg_range> | <xreg_range> "," <freg_range> | <freg_range>
<xreg_range> ::= <s0>  | <s0-sN>   (where `N` is in the range [1, 11])
<freg_range> ::= <fs0> | <fs0-fsM> (where `M` is in the range [1, 7])
----

For the 16-bit encodings

. `ra` must be included
. `s0-sN` may be included, valid values of `N` are 0,1,2,3,5,8,11
. `fs0-fsM` must not be included
. the `stack_adjustment` must be no more than the total memory required for `xreg_list`, rounded up to a multiple of 16-bytes, plus an addition (0..7)*16-bytes.

[NOTE]
  To save encoding space some opcodes do not allow the full range of `spimm` which reduces the possible `stack adjustment` range further, see <<#16bitencodings>>

For the 32-bit encodings

. the `stack_adjustment` must be no more than the total memory required for `reg_list`, rounded up to a multiple of 16-bytes, plus an additional (0..15)*16-bytes.

For example

. `push {ra,s0-s2}, -64` can use a 16-bit encoding
. `push.f {ra,s0-s2, fs0}, -64` must use a 32-bit encoding as `fs0` is in the register list
. `push {ra,s0-s2}, -256` must use a 32-bit encoding as the `stack_adjustment` is out of range

[NOTE]
 Should we allow the x-register syntax? It breaks up the ranges which is annoying as s1 and s2  do not map to consecutive registers

To be a legal encoding:

1.  The stack adjustment must be negative for all `PUSH` variants and positive for a `POP[RET]` variants
2.  The stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register list must be valid (see above)

[NOTE]
  When moving from accessing `x` registers to `f` registers there may be a gap as the registers may be different widths, and all registers must be aligned in memory

== Implementation of sequenced instructions

The sequences below show the required architectural state updates only, the hardware implementation is not specified here. 

Note that each step of the example sequence can be executed as a standard RISC-V 32-bit encoding, so that it is possible to convert the sequences into a sequence of standard instructions. 

Because the sequences include load and store operations, they may take any exception caused by executing loads or stores such as page faults, PMP faults, debug triggers. 

Additionally interrupts and debug halts may be received during execution. 

Handling of these cases is implementation defined but it is recommended that the standard interrupt/exception/debug handlers can be used without modification.

=== PUSH Pseudo-code

All variants of the `PUSH` instruction store the set of registers from `reg_list` to consecutive memory locations, and decrement the stack pointer.
The pseudo-code uses assembly inserts so that it can use `fsw/fsd`.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
addr=sp;
sp+=stack_adjustment; //decrement
if (ra) {
  addr-=XLEN/4;
  switch(XLEN) {
    32:  asm("sw ra, 0(addr)");
    64:  asm("sd ra, 0(addr)");
  }
}
for(i in xreg_list)  {
  addr-=XLEN/4;
  switch(XLEN) {
    32:  asm("sw s[i], 0(addr)");
    64:  asm("sd s[i], 0(addr)");
  }
}
if (freg_list AND opcode==PUSH.D AND XLEN==32 AND (addr%8)>0) { 
  addr-=4; //RV32D - need to ensure fs0 is aligned
}
for(i in freg_list)  {
  switch(opcode) { 
    "PUSH.F": {addr-= 4; asm("fsw fs[i], 0(addr)");}
    "PUSH.D": {addr-= 8; asm("fsd fs[i], 0(addr)");}
  }
}
----

=== POP[RET] Pseudo-code

A `POP` instruction loads the set of registers from `reg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `flw/fld/ret`.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
addr=sp+stack_adjustment;
if (ra) {
  addr-=XLEN/4;
  switch(XLEN) {
    32:  asm("lw ra, 0(addr)");
    64:  asm("ld ra, 0(addr)");
  }
}
for(i in xreg_list)  {
  addr-=XLEN/4;
  switch(XLEN) {
    32:  asm("lw s[i], 0(addr)");
    64:  asm("ld s[i], 0(addr)");
  }
}
if (freg_list AND opcode==PUSH.D AND XLEN==32 AND (addr%8)>0) { 
  addr-=4; //RV32D - need to ensure fs0 is aligned
}
for(i in freg_list)  {
  switch(opcode) { 
    "PUSH.F": {addr-= 4; asm("flw fs[i], 0(addr)");}
    "PUSH.D": {addr-= 8; asm("fld fs[i], 0(addr)");}
}
sp+=stack_adjustment; //increment
if (opcode == "POPRET*) { 
   asm("ret");
}
----

== 32-bit Encodings

.proposed 32-bit encodings
[options="header",width="100%"]
|============================================================================
|31:28  | 28 |27|26:24   |23:20  |19:15 |14:12 |11:7  |6:0     |name
|xxxxxx | ra |0 |000     |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH
|xxxxxx | ra |0 |000     |rcount |spimm |001   |xxxxx |xxxxxxx |POP
|xxxxxx | ra |0 |000     |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET

|xxxxxx | ra |0 |>0      |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH.F
|xxxxxx | ra |0 |>0      |rcount |spimm |001   |xxxxx |xxxxxxx |POP.F
|xxxxxx | ra |0 |>0      |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET.F

|xxxxxx | ra |1 |>0      |rcount |spimm |000   |xxxxx |xxxxxxx |PUSH.D
|xxxxxx | ra |1 |>0      |rcount |spimm |001   |xxxxx |xxxxxxx |POP.D
|xxxxxx | ra |1 |>0      |rcount |spimm |010   |xxxxx |xxxxxxx |POPRET.D
10+|*reserved as [27]=1 means .D but no F-registers specified*
|xxxxxx | x  |1 |000     |rcount |spimm |<3    |xxxxx |xxxxxxx |*reserved*
10+|*reserved as `rcount` is out of range*
|xxxxxx | x  |x |x       |>12    |spimm |<3    |xxxxx |xxxxxxx |*reserved*
10+|*reserved as no registers are specified*
|xxxxxx | x  |0 |000     |000    |spimm |<3    |xxxxx |xxxxxxx |*reserved*
|============================================================================

[NOTE]
  bits [26:24] are the `frcount` field. bits [27] if the `fd` field

=== Illegal instructions for the 32-bit encodings

The encoding takes the same behaviour as any floating point instruction if executed when disabled:

* `PUSH.F/POP.F/POPRET.F` is executed and `MISA.F=0`
* `PUSH.D/POP.D/POPRET.D` is executed and `MISA.D=0`

The following cases do not decode as `PUSH*/POP*/POPRET*`

* No registers are specified (`ra, rcount, frcount` are all zero)
* `rcount>12`
* `fd=1 and frcount=0`

[#16bitencodings]
== 16-bit Encodings

.proposed 16-bit encodings
[options="header",width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction
3+|100|1|0|0|0 2+|rcount|0 |0 2+|00 | spimm 2+|00|C.POP
3+|100|1|0|0 3+|rcount|0 |1 3+|spimm 2+|00|C.POPRET
3+|100|1|0|0 3+|rcount|1 |0 3+|spimm 2+|00|C.PUSH
|=======================================================================

[NOTE]
  * For `C.POP`, `spimm[1]=0`, and `rcount[2]=0` are reserved, as these encodings  give minimal benefit
  * For `C.PUSH/C.POPRET`, if `rcount[2]=1` then `spimm[2]=0` as these encodings  give minimal benefit
  * These encodings remain *reserved* for the time being so we can add them later if they can be justified

== Encoding Fields

[#spimm]
=== `spimm` encoding field

The `stack_adjustment` field in the assembly syntax comprises of two components:

. the memory required for the registers in the list, rounded up to 16-bytes (using the `Align16` function below)
. additional stack space allocated for local variables, encoded in the `spimm` field

The 16-bit encoding allows up to 7 additional 16-byte blocks (as `spimm` has up to 3-bits), and the 32-bit encoding allows up to 15.

[source,sourceCode,text]
----
total_register_bytes = number_of_registers_in_reg_list * XLEN / 8
stack_adjustment = Align16(total_register_bytes) + 16*spimm
----

=== `ra, frcount, rcount` for the 32-bit encodings

The registers in the `reg_list` are controlled by these three fields

[#32bit-ra]
.`ra` field
[options="header"]
|====================================
|ra      | ABI names               
| 0      |none                     
| 1      |ra
|====================================

[#32bit-frcount]
.`frcount` values for the 32-bit encodings
[options="header"]
|=====================
|frcount | ABI names  
| 0      |none        
| 1      |fs0         
| 2      |fs0-fs1     
| 3      |fs0-fs2     
| 4      |fs0-fs3     
| 5      |fs0-fs4     
| 6      |fs0-fs5     
| 7      |fs0-fs6     
|=====================

[NOTE]
  We could allocate one more bit for `frcount` to allow up to `fs11` to be accessed but more than 7 floating point arguments are very unlikely. We may even decide then we only need 2 bits for this field TBD.

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|==========================
|rcount  | ABI names      
| 0      |none       
| 1      |s0
| 2      |s0-s1
| 3      |s0-s2
| 4      |s0-s3
| 5      |s0-s4
| 6      |s0-s5
| 7      |s0-s6
| 8      |s0-s7
| 9      |s0-s8
| 10     |s0-s9
| 11     |s0-s10
| 12     |s0-s11
| 13-15  | *reserved*
|==========================

=== `rcount` for the 16-bit encodings

[#rcount-table]
.`rcount` values for the 16-bit encodings
[options="header",width=100%]
|============================
|rcount| ABI names
|0     |ra
|1     |ra, s0
|2     |ra, s0-s1
|3     |ra, s0-s2
2+|Following options for `C.PUSH/C.POPRET` only
|4     |ra, s0-s3
|5     |ra, s0-s5
|6     |ra, s0-s8
|7     |ra, s0-s11
|============================

== Benchmarking results

Using the `PUSH/POP` support in HCC (Huawei GCC branch) allows the full range of register lists in the 16-bit encodings, and up to 5-bits of `spimm`.

https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/push_pop_encoding_results.xlsx[This spreadsheet] shows the results across the whole benchmark suite to show which instructions were inferred (not broken down by benchmark).

The target for the 16-bit encodings has been to minimise encoding space while keeping ~ 95% of the cases on the benchmark suite (94.9% achieved)

The overall saving compared to -msave-restore is 4.8% using HCC (this result is subject to change as the benchmark suite is updated). Minimising the encoding space reduces this benefit to 4.6%.

[#results-table]
.16-bit encoding code-size benefit
[options="header",width=100%]
|==================================================================
|Instruction|percentage of calls from HCC|overall code-size saving
|All        | 94.9%                      | 4.6% (94.9% of 4.8%)
|`C.PUSH`   | 47.5%                      | 2.3%
|`C.POPRET` | 37.6%                      | 1.8%
|`C.POP`    | 9.8%                       | 0.5%
|==================================================================

== Assembly examples

=== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
sw  ra, 60(sp);
sw  s0, 56(sp); 
sw  s1, 52(sp);
sw  s2, 48(sp); 
sw  s3, 44(sp);
sw  s4, 40(sp); 
sw  s5, 36(sp);
----

=== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -32
----

Encoding: rcount=2, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
addi sp, sp, -32;
sw  ra, 28(sp);
sw  s0, 24(sp); 
sw  s1, 20(sp);
----

=== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw   s8, 120(sp);  
lw   s7, 124(sp);  
lw   s6, 128(sp);  
lw   s5, 132(sp);  
lw   s4, 136(sp);  
lw   s3, 140(sp);  
lw   s2, 144(sp);  
lw   s1, 148(sp);  
lw   s0, 152(sp);  
lw   ra, 156(sp);
addi sp, sp, 160
----

=== PUSH.F RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {fs0, ra, s0-s4}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
fsw fs0,  4(sp)
sw  s4,   8(sp); 
sw  s3,  12(sp); 
sw  s2,  16(sp); 
sw  s1,  20(sp); 
sw  s0,  24(sp); 
sw  ra,  28(sp);
----

=== PUSH.F RV64 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {fs0, ra, s0-s4}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -64;
fsw fs0,  8(sp)
sw  s4,  16(sp); 
sw  s3,  24(sp);
sw  s2,  32(sp); 
sw  s1,  40(sp);
sw  s0,  48(sp); 
sw  ra,  56(sp);
----

=== PUSH.F RV64 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {fs0-fs7}, -128
----

Encoding: eabi=0, rcount=0, frcount=12, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
addi sp, sp, -128; 
fsw  fs7,  64(sp); 
fsw  fs6,  72(sp);
fsw  fs5,  80(sp); 
fsw  fs4,  88(sp);
fsw  fs3,  96(sp); 
fsw  fs2, 108(sp);
fsw  fs1, 116(sp); 
fsw  fs0, 128(sp);
----

=== POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
pop   {ra, s0-s9}, 256
----

Encoding: eabi=0, ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 252(sp);
lw   s0, 248(sp);
lw   s1, 244(sp);  
lw   s2, 240(sp)
lw   s3, 236(sp);  
lw   s4, 232(sp);
lw   s5, 228(sp);  
lw   s6, 224(sp)
lw   s7, 220(sp);  
lw   s8, 216(sp);
lw   s9, 212(sp);  
addi sp, sp, 256
----

=== POPRET.F RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
popret.f   {fs0-fs1, ra, s0-s3}, 32
----

Encoding: eabi=0, ra=1, rcount=4, frcount=2, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);  
lw   s2, 16(sp);
lw   s3, 12(sp);  
flw  fs0, 8(sp);
flw  fs1, 4(s0);  
addi sp, sp, 32; 
ret
----

