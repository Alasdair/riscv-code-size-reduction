= RISC-V Push/Pop Extension
Version 0.1
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes 32-bit and 16-bit encodings for `[C.]PUSH`,
`[C.]POP` and `[C.]POPRET` instructions for RV32 and RV64 architectures I variants only, using the UABI.

`PUSHINT/POPINT` are included for fast interrupt handler context save/restore, but are not included in this document.

`f` registers may also be saved/restored by the 32-bit encodings.

== Open issues

it's better to list these first, as they are resolved I'll update the proposal

* should these instructions check alignment? if you use -msave-restore there's no alignment check, and if the compiler produces the prologue/epilogue directly there's no alignment check, so is it worth it?
* whether to share an encoding with `POP[RET]` and so maybe have fewer `POP` rcount values to save encoding space.

== Rationale

`[C.]PUSH/[C.]POP/[C.]POPRET` are designed to replace the
most commonly called functions generated by the compiler using
_–m-save-restore_. When the _–msave-restore_ option is used the compiler
replaces the sequence of stores plus `sp` decrement operation required
to spill/push registers to the stack with a call to a shared co-routine
that performs this operation. In addition the equivalent fill/pop
sequence is replaced with a jump to a shared co-routine (which then
performs the return to the caller of the function). The code savings can
be significant (provided that the co-routine jump/calls can be encoded
in a single 32-bit instruction) but the run-time overhead is high as an
additional 3 jumps are required for each push/pop sequence; in addition
the shared save/restore routines include redundant memory operations
when the number of registers to spill is not a multiple of 4.

The most useful forms of these instructions are the 16-bit encodings, as
these give the largest code size reduction, whilst covering the vast
majority of useful cases.

== 16-bit encodings

=== `C.PUSH` instruction

`C.PUSH` which allows most spill sequences to only take 16-bits of
code space instead of 32-bits for the call to the save routine (or in
some cases 64-bits if the target function is too far away).

=== `C.POP` instruction

`C.POP` which allows most fill sequences to be performed with two
16-bit instructions (`C.POP+RET` ) which matches the cost of the
co-routine jump (for jumps <1Mbyte) but with significantly better
performance.

=== `C.POPRET` instructions

`C.POPRET` which allows both the `C.POP` and `RET` to be
performed in a single instruction saving 16-bits of code with respect to
a `C.POP+RET` or a jump to a restore co-routine.

=== Opcode Assignment

.proposed encoding
[width="100%"]
|=======================================================================
|15 |14 |13 |12 |11 |10 |9 |8 |7 |6 |5 |4 |3 |2 |1 |0 |instruction

17+|*These replace reserved encodings

3+|100|1|0 4+|rcount|0|0 3+|spimm 2+|00|C.POP
3+|100|1|0 4+|rcount|0|1 3+|spimm 2+|00|C.POPRET
3+|100|1|0 4+|rcount|1|0 3+|spimm 2+|00|C.PUSH
|=======================================================================

Notes

* The `spimm` field is an unsigned immediate that indicates the number
of additional 16-byte blocks to adjust the stack pointer by. See <<spimm-table>>
and <<rcount-table>>
* the instructions are designed to support the UABI only for RV32 and for RV64
* For UABI documentation see Chapter 20 of
http://riscv.org/specifications/isa-spec-pdf[The RISC-V ISA
specification]
* For the EABI, see this
https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc[proposal]


[#spimm-table]
.`spimm` and register holes for different architectures and ABIs
[options="header"]
|=======================================================================
|arch+ABI |spimm _n_ |total stack adjustment for _r_ registers |register holes to skip
|RV32I UABI |16 |adjust = 16*((r+3)/4+spimm) |holes = 3-((r+3) mod 4)
|RV64I UABI |16 |adjust = 16*((r+1)/2+spimm) |holes = r mod 2
|=======================================================================

The purpose of `spimm` is to allow a function to allocate additional
space on the stack for automatic variables without having to perform an
additional stack adjustment (and therefore save more code size).

The encodings contain no explicit register index fields as the memory
accesses and pointer increments are all based on the stack pointer
register as defined in the standard RISC-V ABI `sp` and the registers
to be loaded/stored are specified using the `rcount` field (see
<<rcount-table>>)

The behaviour of each value of `rcount` and `spimm` is shown in
<<rcount-table>>.

[#rcount-table]
.`rcount` values for different architectures
[options="header",width=100%]
|===================================================================================================================================
|rcount| ABI names            2+|Stack pointer adjustment              2+|reg holes to skip          
|      |                      2+|x=spimm, -for C.PUSH, +for C.POP[RET] 2+|to maintain 16-byte alignment                           
|      |                        |RV32I   |RV64I                          |RV32I |RV64I  
|0     |ra                      |16(1+x) |16(1+x)                        | 3    | 1   
|1     |ra, s0                  |16(1+x) |16(1+x)                        | 2    | 0   
|2     |ra, s0-s1               |16(1+x) |16(2+x)                        | 1    | 1   
|3     |ra, s0-s2               |16(1+x) |16(2+x)                        | 0    | 0   
|4     |ra, s0-s3               |16(2+x) |16(3+x)                        | 3    | 1   
|5     |ra, s0-s5               |16(2+x) |16(4+x)                        | 1    | 0   
|6     |ra, s0-s8               |16(3+x) |16(5+x)                        | 2    | 1   
|7     |ra, s0-s11              |16(4+x) |16(7+x)                        | 3    | 0   
|8   5+|*reserved for EABI*
|9   5+|*reserved for EABI*
|10  5+|*reserved for EABI*
|11-15 5+|*reserved*
|===================================================================================================================================

=== `C.PUSH` Operation

A `C.PUSH` instruction writes the set of registers selected by `rcount` to memory, the registers are written to the memory immediately
below the current stack pointer. The last register in the list is stored to the lowest memory location to be written by the `C.PUSH`

[source,sourceCode,text]
----
sp-(XLEN/8)*r
----

where `r` is the number registers to store

The selected registers are written to contiguous incrementing
(`XLEN`/8)-byte words starting with the register in the reverse of the
order shown in <<rcount-table>> above (ra is always stored last).

Once all stores have completed the stack pointer register `sp` is
decremented by the stack adjustment value from <<spimm-table>> and
<<rcount-table>>.

Note that `spimm` allows additional bytes of stack to be
allocated for automatic variables without having to issue additional
stack manipulation instructions.

.push 1 to 5 registers
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/push_1to5_regs_170pc_zoom.png[push example]

=== `C.POP[RET]` Operation

A `C.POP[RET]` instruction loads the set of registers selected by `rcount` from the memory. The loads start with the last register in the list from <<rcount-table>>
at the lowest memory location to be read by the `C.POP[RET]`, which is at the current stack pointer incremented by the number of holes, also from <<rcount-table>>.

The selected registers are loaded from contiguous incrementing (XLEN/8)-byte words in the reverse of the order shown in  <<rcount-table>>
above ( `ra` is always loaded last).

Once all loads have completed the stack pointer register `sp` is incremented by the stack adjustment value from <<spimm-table>> and
<<rcount-table>>, placing it immediately above the block of memory read by the `C.POP[RET]` instruction.

`C.POPRET` executes a `RET` as the final step in the sequence

.pop 1 to 5 registers
image::https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/pop_1to5_regs_170pc_zoom.png[pop example]

[#instruction-sequences]
=== Instruction sequences

The behaviour of these instructions is specified using instruction sequences.

All loads and stores in the sequences can be executed multiple times, and in any order. They can be merged into wider loads or stores, 
or broken down into smaller loads and stores.

The `ADDI` at the end of the sequences (`ADDI, RET` for `C.POPRET`) only executes if all other steps have completed without causing an exception 
(such as load or store access fault, load or store page fault, breakpoint), taking an interrupt or entering into debug mode (breakpoint or external 
debug halt). It is possible to interrupt the sequence between the final load or store and the `ADDI` instruction. It is _not_ possible to interrupt 
`C.POPRET` between the `ADDI` and the `RET`.

When execution resumes any number of the loads or stores in the sequences may be re-executed, including partial loads or stores if they have been broken 
down into smaller memory accesses.

It is implementation defined whether to detect cases such as page faults, PMP faults and watchpoint triggers before the sequences
start executing, or on a step-by-step basis. For exceptions, `mepc` will always be the PC of the `PUSH/POP[RET]` and `mtval` will 
always have the address of the load/store which caused the fault, regardless of whether any of the steps of the sequence have 
actually been issued.

The same argument is true for watchpoint triggers causing entry into debug mode, these can be detected before issuing the sequence or part way through the sequence.
If the same instruction causes more than one watchpoint trigger, then the one triggered by the lowest numbered step is taken.

Additionally, it is implementation defined whether to take interrupts or external debug halts at all during the sequence. An implementation may choose
to only take them before or after the sequence executes.

In the tables:

* `N` is the stack pointer adjustment value from <<rcount-table>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV64

[#cpush_sequence]
.`C.PUSH` sequence
[options="header",width=50%]
|===============================================================================
| `C.PUSH` step                             |Execute if
| sw x27,  (-13*M)(x2)                      |rcount==7
| sw x26,  (-12*M)(x2)                      |rcount==7
| sw x25,  (-11*M)(x2)                      |rcount==7
| sw x24,  (-10*M)(x2)                      |rcount>5 && rcount<8
| sw x23,  ( -9*M)(x2)                      |rcount>5 && rcount<8
| sw x22,  ( -8*M)(x2)                      |rcount>5 && rcount<8
| sw x21,  ( -7*M)(x2)                      |rcount>4 && rcount<8
| sw x20,  ( -6*M)(x2)                      |rcount>4 && rcount<8
| sw x19,  ( -5*M)(x2)                      |rcount>3 && rcount<8
| sw x18,  ( -4*M)(x2)                      |rcount>2 && rcount<8
| sw x9,   ( -3*M)(x2)                      |rcount>1 && rcount<8
| sw x8,   ( -2*M)(x2)                      |rcount>0 && rcount<8
| sw x1,   ( -1*M)(x2)                      |1 
| addi x2, x2,  -N                          |1 
|===============================================================================

.`C.POP[RET]` sequence
[options="header",width=50%]
|===============================================================================
| `C.POP[RET]` step                    |Execute if
| lw x27,  (-13*M+N)(x2)                   |rcount==7
| lw x26,  (-12*M+N)(x2)                   |rcount==7
| lw x25,  (-11*M+N)(x2)                   |rcount==7
| lw x24,  (-10*M+N)(x2)                   |rcount>5
| lw x23,  (-9*M+N)(x2)                    |rcount>5 && rcount<8
| lw x22,  (-8*M+N)(x2)                    |rcount>5 && rcount<8
| lw x21,  (-7*M+N)(x2)                    |rcount>4 && rcount<8
| lw x20,  (-6*M+N)(x2)                    |rcount>4 && rcount<8
| lw x19,  (-5*M+N)(x2)                    |rcount>3 && rcount<8
| lw x18,  (-4*M+N)(x2)                    |rcount>2 && rcount<8
| lw x9,   (-3*M+N)(x2)                    |rcount>1 && rcount<8
| lw x8,   (-2*M+N)(x2)                    |rcount>0 && rcount<8
| lw x1,   (-1*M+N)(x2)                    |1
| addi x2, x2,  N                          |1
| ret                                      |C.POPRET
|===============================================================================

=== Exceptions

[#sp-misalign]
==== Stack pointer misalignment

Stack pointer misalignment causes a Store Access Fault for `C.PUSH` or a Load Access Fault for `C.POP[RET]`.

Take an exception if the stack pointer is not 16-byte aligned.

==== Illegal instructions

Take an illegal instruction exception if `rcount > 7`, unless those `rcount` values decode as different instuctions.

==== Load/store exceptions

The instructions require loads or stores to be issued, as shown in <<instruction-sequences>>.
Therefore any exceptional behaviour caused by issuing the loads or stores from the sequences can be caused by using these instructions.

=== Assembler Syntax

[source,sourceCode,text]
----
push   {<register_list>}, -<total_stack_adjustment>
pop    {<register_list>},  <total_stack_adjustment>
popret {<register_list>},  <total_stack_adjustment>
----

The `C.PUSH/C.POP[RET]` instructions are represented in assembler as the mnemonic (excluding `C.`) followed by a a register list in braces and then the _total_ size of the stack adjustment in bytes. 

The register list may include individual registers or register ranges using ABI names or `x` names. The registers may be listed in any order.
e.g. `s0-s5` and also accepts `x` register names e.g. `x8-x9,x18-20`.  For example `rcount=5` can be represented by

1. `{ra, s0-s5}` (this is the recommended syntax)
2. `{s0, s1, s2, s3, s4, s5, ra}``
3. `{x1, x8-x9,x18-x20}`
4. `{x1, x8, x9, x18, x19, x20}` 
5. `{x18-x20, x9, x8, x1}` 

To be a legal encoding stack adjustment must:

1.  The stack adjustment must be negative for a `C.PUSH` and positive for a `C.POP[RET]`
2.  The stack adjustment must match the value range in <<rcount-table>> for the current architecture
3.  The register list must match an `rcount` value for either a 16-bit or 32-bit encoding

If not then this will cause an `illegal operands` error from the assembler.

=== RV32 Assembler Examples

==== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  s5, -28(sp);
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra, -4(sp);
addi sp, sp, -64;
----

==== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, -32
----

Encoding: rcount=2, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  s1, -12(sp);
sw  s0,  -8(sp); 
sw  ra,  -4(sp);
addi sp, sp, -32;
----

==== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {x1, x8-x9, x18-x24}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw  x24, 120(sp);  lw  x23, 124(sp);  
lw  x22, 128(sp);  lw  x21, 132(sp);  
lw  x20, 136(sp);  lw  x19, 140(sp);  
lw  x18, 144(sp);  lw   x9, 148(sp);  
lw   x8, 152(sp);  lw   x1, 156(sp);
addi sp, sp, 160
----

[#varargs-support]
==== Varargs Support

Functions using varargs also spill the argument registers to the stack,
which maybe require a `SWM` instruction (store-word-multiple).

HCC (Huawei's branch of GCC) produces this prologue:

[source,sourceCode,text]
----
16: addi sp,sp,-64 
16: sw   ra,28(sp)
16: sw   s0,24(sp)

16: sw   a7,60(sp)
16: sw   a6,56(sp)
16: sw   a5,52(sp)
16: sw   a4,48(sp)
16: sw   a3,44(sp)
16: sw   a2,40(sp)
16: sw   a1,36(sp)
----

This could be optimised to be:

[source,sourceCode,text]
----
16: push {ra, s0},-32
16: addi sp,sp,-32
16: swm  {a1-a7},36(sp)
----

HCC produces this epilogue

[source,sourceCode,text]
----
16: lw   ra,28(sp)
16: lw   s0,24(sp)
16: addi sp,sp,64
16: ret
----

which could become:

[source,sourceCode,text]
----
16: addi sp,sp,32
16: popret {ra,s0},32
----

saving 2x16-bit encodings.

So in total 14 instructions can be reduced to 6.

== 32-bit encodings

The 32-bit versions of the instructions allow greater flexibility in
specifying the list of registers by allowing floating point registers to
be saved/restored, and also give the option of excluding `ra`. 
Therefore the register list syntax also allows floating
point registers to be included. They can included in any order, but will
always be accessed in the same order by the instruction. 

The 32-bit encodings also allow
a larger range of `spimm` values. Otherwise the semantics are identical
to the 16-bit versions and so the specification is not repeated here.
The instructions are called `PUSH/POP[RET]`.

These instructions will _not_ cover all possible push/pop scenarios,
they are designed to cover the common cases without using excessive
encoding space.

[NOTE]
  This specification assumes that `XLEN==FLEN` and so does not currently include `RV32D`. This will be included in the future after resolving the simpler cases.

A C-function using varargs will also spill the argument registers to the
stack. They can be achieved by a store-multiple command after the `PUSH`
instruction and vararg support is not directly implemented by `PUSH` (see <<varargs-support>>)

=== Opcode Assignment

.32-bit encodings for the UABI
[options="header",width="100%"]
|============================================================================
|31:28  | 27 |26:24   |23:20  |19:15 |14:12 |11:7  |6:0     |name
|xxxxxx | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |PUSH
|xxxxxx | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POP
|xxxxxx | ra |frcount |rcount |spimm |xxx   |xxxxx |xxxxxxx |POPRET
|============================================================================

The register list is specified by a concentenating the registers specified of the `ra`, `rcount` and `frcount` fields. 

[#32bit-ra]
.`ra` field
[options="header",width="50%"]
|====================================
|ra      | ABI names               
| 0      |none                     
| 1      |ra
|====================================

The `x` registers are specified by <<32bit-rcount>>. Compared to the 16-bit encodings there is finer control of how many `x` registers are accessed.
There is no semantic difference in the specification.
The addition field `frcount` allows callee save `f` registers to be
saved/restored as well. The `f` registers are always appended to the
list of `x` registers.

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|================================================================
|rcount  |#regs|instruction  | ABI names | `x` register numbers       
| 0      | 0   |PUSH/POP[RET]|none       | none               
| 1      | 1   |PUSH/POP[RET]|s0         | x8         
| 2      | 2   |PUSH/POP[RET]|s0-s1      | x8-x9             
| 3      | 3   |PUSH/POP[RET]|s0-s2      | x8-x9,x18             
| 4      | 4   |PUSH/POP[RET]|s0-s3      | x8-x9,x18-x19             
| 5      | 5   |PUSH/POP[RET]|s0-s4      | x8-x9,x18-x20             
| 6      | 6   |PUSH/POP[RET]|s0-s5      | x8-x9,x18-x21             
| 7      | 7   |PUSH/POP[RET]|s0-s6      | x8-x9,x18-x22             
| 8      | 8   |PUSH/POP[RET]|s0-s7      | x8-x9,x18-x23             
| 9      | 9   |PUSH/POP[RET]|s0-s8      | x8-x9,x18-x24             
| 10     | 10  |PUSH/POP[RET]|s0-s9      | x8-x9,x18-x25             
| 11     | 11  |PUSH/POP[RET]|s0-s10     | x8-x9,x18-x26             
| 12     | 12  |PUSH/POP[RET]|s0-s11     | x8-x9,x18-x27             
| 13-15 4+| *reserved*               
|================================================================

[#32bit-frcount]
.`frcount` values for the 32-bit encodings
[options="header"]
|========================================================================
|frcount |#regs|instruction    | ABI names   | `f` register numbers            
| 0      | 0   |PUSH/POP[RET]  |none         | none                    
| 1      | 1   |PUSH/POP[RET]  |fs0          | f8              
| 2      | 2   |PUSH/POP[RET]  |fs0-fs1      | f8-f9                  
| 3      | 3   |PUSH/POP[RET]  |fs0-fs2      | f8-f9,f18                  
| 4      | 4   |PUSH/POP[RET]  |fs0-fs3      | f8-f9,f18-f19                  
| 5      | 5   |PUSH/POP[RET]  |fs0-fs4      | f8-f9,f18-f20                  
| 6      | 6   |PUSH/POP[RET]  |fs0-fs5      | f8-f9,f18-f21                  
| 7      | 7   |PUSH/POP[RET]  |fs0-fs6      | f8-f9,f18-f22                  
| 8      | 8   |PUSH/POP[RET]  |fs0-fs7      | f8-f9,f18-f23                  
| 9      | 9   |PUSH/POP[RET]  |fs0-fs8      | f8-f9,f18-f24                  
| 10     | 10  |PUSH/POP[RET]  |fs0-fs9      | f8-f9,f18-f25                  
| 11     | 11  |PUSH/POP[RET]  |fs0-fs10     | f8-f9,f18-f26                  
| 12     | 12  |PUSH/POP[RET]  |fs0-fs11     | f8-f9,f18-f27                  
| 13-15  4+|*reserved*               
|========================================================================

The `spimm` field is always a multiple of 16-bytes

[#32bit-16byte-rcount]
.Register count mapping for `PUSH/POP[RET]` with 16-byte alignment
[options="header",width="50%"]
|==============================================
  |total  2+|SP adjustment     2+|reg holes  
  |# regs 2+|x=spimm,          2+|to skip    
  |       2+|-for PUSH,        2+|           
  |       2+|+for POP[RET]   2+|           
  |         |RV32I    |RV64I     |RV32I|RV64I
  |1        |16(1+x)  |16(1+x)   | 3   | 1   
  |2        |16(1+x)  |16(1+x)   | 2   | 0   
  |3        |16(1+x)  |16(2+x)   | 1   | 1   
  |4        |16(1+x)  |16(2+x)   | 0   | 0   
  |5        |16(2+x)  |16(3+x)   | 3   | 1   
  |6        |16(2+x)  |16(3+x)   | 2   | 0   
  |7        |16(2+x)  |16(4+x)   | 1   | 1   
  |8        |16(2+x)  |16(4+x)   | 0   | 0   
  |9        |16(3+x)  |16(5+x)   | 3   | 1   
  |10       |16(3+x)  |16(5+x)   | 2   | 0   
  |11       |16(3+x)  |16(6+x)   | 1   | 1   
  |12       |16(3+x)  |16(6+x)   | 0   | 0   
  |13       |16(4+x)  |16(7+x)   | 3   | 1   
  |14       |16(4+x)  |16(7+x)   | 2   | 0   
  |15       |16(4+x)  |16(8+x)   | 1   | 1   
  |16       |16(4+x)  |16(8+x)   | 0   | 0   
  |17       |16(5+x)  |16(9+x)   | 3   | 1   
  |18       |16(5+x)  |16(9+x)   | 2   | 0   
  |19       |16(5+x)  |16(10+x)  | 1   | 1   
  |20       |16(5+x)  |16(10+x)  | 0   | 0   
  |21       |16(6+x)  |16(11+x)  | 3   | 1   
  |22       |16(6+x)  |16(11+x)  | 2   | 0   
  |23       |16(6+x)  |16(12+x)  | 1   | 1   
  |24       |16(6+x)  |16(12+x)  | 0   | 0   
  |25       |16(7+x)  |16(13+x)  | 3   | 1   
|==============================================

=== Register lists and assembly syntax

==== `PUSH/POP[RET]`

The register list is a concatenation of the values from <<32bit-ra>>, <<32bit-rcount>>, <<32bit-frcount>>.
In all cases the head of the list must be one of

* `ra`
* `s0`
* `fs0`

This pseudo-code is valid for `PUSH/POP[RET]`

[source,sourceCode,text]
----
reg_list = {}; //empty list
if (ra) reg_list = {ra};
if (rcount>0) {
    for (i=1; i<=rcount; i++)  reglist += {s[i-1]};  //add s registers, X numbers vary depending on ABI
}
if (frcount>0) {
    for (i=1; i<=frcount; i++) reglist += {fs[i-1]}; //add fs registers
}
----

`PUSH/POP[RET]` have identical assembly syntax to the 16-bit encodings. The assembler will automatically choose the 16-bit encoding if possible, if not then the 32-bit encoding.

=== Exceptions

If no registers are specified (`ra, rcount, frcount` are all zero) then take an illegal instruction exception.
If `frcount > 0` then the `F` extension must be implemented without `Zfinx` for legal decoding.
If `rcount` or `frcount` are out of rnange take an illegal instruction exception, unless those values have been assigned a different meaning in another specification.

==== Stack Pointer Misalignment

The rules are the same as for the 16-bit encodings - see <<sp-misalign>>.

== Instruction sequences

The rules are the same as for the 16-bit encodings, see <<instruction-sequences>>.

In the tables:

* `N` is the _total_ stack pointer adjustment value from <<32bit-16byte-rcount>>.
* `M` is `XLEN/8` i.e. 4 for RV32, 8 for RV64

=== `PUSH/POP[RET]` sequences

The tables assume the `f` registers are 32-bit. If they are wider then different instructions will be used to access them (`FLD/FSD`) and the offsets will scale accordingly.

[#cpush_sequence]
.`PUSH` sequence
[options="header",width=50%]
|===============================================================================
| PUSH step                                 |Execute if
| fsw f27, (-(ra+rcount+11)*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f26, (-(ra+rcount+10)*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f25, (-(ra+rcount+9 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f24, (-(ra+rcount+8 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f23, (-(ra+rcount+7 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f22, (-(ra+rcount+6 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f21, (-(ra+rcount+5 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f20, (-(ra+rcount+4 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f19, (-(ra+rcount+3 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f18, (-(ra+rcount+2 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f9,  (-(ra+rcount+1 )*M)(x2)          |frcount>=2 && frcount<13 && rcount<13
| fsw f8,  (-(ra+rcount   )*M)(x2)          |frcount>=1 && frcount<13 && rcount<13
| sw x27,  (-(ra+12)*M)(x2)                 |rcount>=12 && rcount<13
| sw x26,  (-(ra+11)*M)(x2)                 |rcount>=11 && rcount<13
| sw x25,  (-(ra+10)*M)(x2)                 |rcount>=10 && rcount<13
| sw x24,  (-(ra+ 9)*M)(x2)                 |rcount>=9  && rcount<13
| sw x23,  (-(ra+ 8)*M)(x2)                 |rcount>=8  && rcount<13
| sw x22,  (-(ra+ 7)*M)(x2)                 |rcount>=7  && rcount<13
| sw x21,  (-(ra+ 6)*M)(x2)                 |rcount>=6  && rcount<13
| sw x20,  (-(ra+ 5)*M)(x2)                 |rcount>=5  && rcount<13
| sw x19,  (-(ra+ 4)*M)(x2)                 |rcount>=4  && rcount<13
| sw x18,  (-(ra+ 3)*M)(x2)                 |rcount>=3  && rcount<13
| sw x9,   (-(ra+ 2)*M)(x2)                 |rcount>=2  && rcount<13
| sw x8,   (-(ra+ 1)*M)(x2)                 |rcount>=1  && rcount<13
| sw x1,   (-1*M) (x2)                      |ra==1 
| addi x2, x2,  -N                          |1 
|===============================================================================

.`POP[RET]` sequence
[options="header",width=50%]
|===============================================================================
| C.POP[RET] step                      |Execute if
| fsw f27, (-(ra+rcount+11)*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f26, (-(ra+rcount+10)*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f25, (-(ra+rcount+9 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f24, (-(ra+rcount+8 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f23, (-(ra+rcount+7 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f22, (-(ra+rcount+6 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f21, (-(ra+rcount+5 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f20, (-(ra+rcount+4 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f19, (-(ra+rcount+3 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f18, (-(ra+rcount+2 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f9,  (-(ra+rcount+1 )*M+N)(x2)       |frcount>=2 && frcount<13 && rcount<13
| fsw f8,  (-(ra+rcount   )*M+N)(x2)       |frcount>=1 && frcount<13 && rcount<13
| sw x27,  (-(ra+12)*M+N)(x2)              |rcount>=12 && rcount<13
| sw x26,  (-(ra+11)*M+N)(x2)              |rcount>=11 && rcount<13
| sw x25,  (-(ra+10)*M+N)(x2)              |rcount>=10 && rcount<13
| sw x24,  (-(ra+ 9)*M+N)(x2)              |rcount>=9  && rcount<13
| sw x23,  (-(ra+ 8)*M+N)(x2)              |rcount>=8  && rcount<13
| sw x22,  (-(ra+ 7)*M+N)(x2)              |rcount>=7  && rcount<13
| sw x21,  (-(ra+ 6)*M+N)(x2)              |rcount>=6  && rcount<13
| sw x20,  (-(ra+ 5)*M+N)(x2)              |rcount>=5  && rcount<13
| sw x19,  (-(ra+ 4)*M+N)(x2)              |rcount>=4  && rcount<13
| sw x18,  (-(ra+ 3)*M+N)(x2)              |rcount>=3  && rcount<13
| sw x9,   (-(ra+ 2)*M+N)(x2)              |rcount>=2  && rcount<13
| sw x8,   (-(ra+ 1)*M+N)(x2)              |rcount>=1  && rcount<13
| sw x1,   (-1*M+N) (x2)                   |ra==1 
| addi x2, x2,  N                          |1
| ret                                      |POPRET
|===============================================================================

=== Assembler Examples

==== PUSH RV32

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw fs0,-28(sp)
sw  s4, -24(sp); sw  s3, -20(sp);
sw  s2, -16(sp); sw  s1, -12(sp);
sw  s0,  -8(sp); sw  ra,  -4(sp);
addi sp, sp, -64;
----

==== PUSH RV64

[source,sourceCode,text]
----
push  {ra, s0-s4, fs0}, -64
----

Encoding: eabi=0, ra=1, rcount=5, frcount=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw fs0,-56(sp)
sw  s4, -48(sp); sw  s3, -40(sp);
sw  s2, -32(sp); sw  s1, -24(sp);
sw  s0, -16(sp); sw  ra,  -8(sp);
addi sp, sp, -64;
----

==== PUSH RV64

[source,sourceCode,text]
----
push  {fs0-fs11}, -128
----

Encoding: eabi=0, rcount=0, frcount=12, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsw  fs11,-96(sp); fsw  fs10,-88(sp);
fsw  fs9, -80(sp); fsw  fs8, -72(sp);
fsw  fs7, -64(sp); fsw  fs6, -56(sp);
fsw  fs5, -48(sp); fsw  fs4, -40(sp);
fsw  fs3, -32(sp); fsw  fs2, -24(sp);
fsw  fs1, -16(sp); fsw  fs0,  -8(sp);
addi sp, sp, -128;
----

==== POP RV32I UABI

[source,sourceCode,text]
----
pop   {x1, x8-x9, x18-x25}, 256
----

Encoding: eabi=0, ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw  x25, 212(sp);  lw  x24, 216(sp);
lw  x23, 220(sp);  lw  x22, 224(sp)
lw  x21, 228(sp);  lw  x20, 232(sp);
lw  x19, 236(sp);  lw  x18, 240(sp)
lw   x9, 244(sp);  lw   x8, 248(sp);
lw   x1, 252(sp);
addi sp, sp, 256
----

==== POPRET RV32I UABI

[source,sourceCode,text]
----
popret   {x1, x8-x9, x18-x19, f8-f9}, 32
----

Encoding: eabi=0, ra=1, rcount=4, frcount=2, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
flw  f9,  4(s0);  flw  f8,  8(sp);
lw  x19, 12(sp);  lw  x18, 16(sp);
lw   x9, 20(sp);  lw   x8, 24(sp);
lw   x1, 28(sp);
addi sp, sp, 32; ret
----

