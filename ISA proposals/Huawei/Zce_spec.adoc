= RISC-V Zce code-size reduction extension proposal v0.14
Version 0.14
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes the `Zce` extension to reduce code-size.

== Spec update history

|===================================================================
| version | change
| 0.14    | BNEI/BEQI/MULI/MULIADD/ADDIADD moved from Zced to Zcec. Found encodings for B*I and DECBGEZ to allow Zced+ZDinx. Reduced cmpimm range for BNEI/BEQI to fit the encoding. Allocated provisional encodings for all 32-bit instructions. Fixed width of frcount, mv in PUSH/POP encodings.
| 0.13    | split LWGP/SWGP into LWGP/SWGP and LWTP/SWTP
| 0.12    | reduce ret_val to 2-bits for POP/POPRET
| 0.11    | Add C.SEXT.W, C.ZEXT.W, MULI, MULIADDW, ADDIADDW, and change the C.[SZ]EXT.* encodings. Rename flen PUSH/POP encoding field to fdq to avoid confusion with FLEN.
|===================================================================

== Issues

* there are probably too many instructions listed, so we need to reduce the list
** we don't need `both c.mvp` and also `c.mvas*`
* we need to check the sizes of the immediate fields, so we don't waste encoding space
* `c.mvp` and `c.mvas*` don't have a sensible 32-bit alternative, as no code size would be saved (unless C isn't implemented), so is it ok to convert to a sequence of two 32-bit encodings? If not then we need to allocate pointless 32-bit encodings.
* `decbgez` doesn't need to be in `Zced`, but `c.decbgez` does
** maybe I can squeeze `c.decbgez` into `Zcec`, TBD, need to benchmark the size of the immediate range
* need to choose a B-extension subset to include

== Zce configurations

Zce is split into subsets. It includes 

* `Zces` sequenced instructions
** 16-bit: `C.POP, C.POPRET, C.PUSH, C.MVA01S07, C.MVA23S07, C.MVP`     
** 32-bit: `POP, POPRET, PUSH, POP.[FDQ], POPRET.[FDQ], PUSH.[FDQ]`
* `Zced` instructions which conflict with the D-extension
** 16-bit: `C.LBU, C.LHU, C.SB, C.SH, C.DECBGEZ`
** 32-bit: `LWGP, SWGP, LWTP, SWTP`
* `Zcec` common instructions
** all others

=== Zce configuration options

. If `Zce` is specified, and `D` is _not_ specified then `C_Zces_Zced_Zcec` are configured.

. If `Zce` is specified, and `D` _is_  specified then `C_Zces_Zcec` are configured.

. If `Zce` is specified, and `ZDinx` is  specified then `C_Zces_Zced_Zcec` are configured, as there are no conflicts with `ZDinx`.
.. Therefore if a core needs double precision arithmetic _and_ small code size then the correct configuration to choose is Zce_ZDinx.

. If `Zces` is not required then `Zcec` and optionally `Zced` may be specified.

. `Zced` and `Zces` both imply `Zcec`.

. `Zcec` implies `C`.

== C-extension subsets

The C-extension already reuses encodings between different architectures. `Zce` extends this concept further. <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>> show how each encoding is allocated for different architectures or for different combinations of extensions.

For example:

* `C.FSD`, `C.SQ`, and `{C.LBU, C.SB}` share opcodes, so for different configurations the encodings represent:
** `C.FSD` for `RV32CD/RV64CD`
** `C.SQ`  for `RV128C`
** `{C.LBU, C.SB}` for `RV32C_Zce, RV64C_Zce`
** illegal encoding for `RV32C, RV64C`, as neither `D` nor `Zce` was specified

The shared encoding column in the tables assigns an arbitrary number to show which encodings are grouped together (I can't find a better way of highlighting groups of cells in the table in adoc format). `Zce` instructions are in *bold*.

[#zce_quad0]
.C-extension quadrant 0
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension
|000       |C.ADDI4SPN| |Zci |✓|✓ |✓  |C

|001       |C.FLD     |1|Zcd |✓|✓ |   |C+D
|001       |C.LQ      |1|Zcq |  |  |✓  |C
|001       |*C.DECBGEZ* |1|*Zced*|✓|✓ |  |C+*Zce*

|010       |C.LW      | |Zci |✓|✓ |✓  |C

|011       |C.FLW     |2|Zcf |✓|   |   |C+F
|011       |C.LD      |2|Zc64/Zc128| |✓|✓|C

|100       |*C.POP*     | |*Zces*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.POPRET*  | |*Zces*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.PUSH*    | |*Zces*|	✓|	✓|	✓|	C+*Zce*

|100       |*C.TBLJAL*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SHSP*    | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SBSP*    | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LHUSP*   | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LBUSP*   | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.B*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.H*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.W*  | |*Zcec*|	 |	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.B*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.H*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.W*  | |*Zcec*|	 |	✓|	✓|	C+*Zce*
|100       |*C.LSBNOT*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MUL*     | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVA01S07*| |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVA23S07*| |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVP*	    | |*Zcec*|  ✓|  ✓| 	✓|  C+*Zce*

|101       |C.FSD     |3|Zcd|✓|✓| |C+D
|101       |C.SQ      |3|Zcq| | |✓|D
|101       |*C.SB*      |3|*Zced*|✓|✓| |C+*Zce*
|101       |*C.LBU*     |3|*Zced*|✓|✓ |  |C+*Zce*

|110       |C.SW      | |Zci|✓|✓|✓|C

|111       |C.FSW     |4|Zcf|✓| | |C+F
|111       |C.SD      |4|Zc64/Zc128| |✓|✓|C
|===============================================================================

[#zce_quad1]
.C-extension quadrant 1
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.NOP	| |Zci	|✓	|✓	|✓	|C
|000       |C.ADDI	| |Zci	|✓	|✓	|✓	|C


|001       |C.JAL	        |5|Zc32	        |✓	|	|	|C
|001       |C.ADDIW (rd=0:RSV)  |5|Zc64/Zc128	|	|✓	|✓	|C

|010       |C.LI (rd=0:HINT) | |Zci	|✓	|✓	|✓	|C


|011       |C.ADDI16SP (nzimm=0:RSV)	| | Zci	|✓	|✓	|✓	|C
|011       |C.LUI (nzimm=0: RSV; rd=0:HINT)	| |Zci	|✓	|✓	|✓	|C


|100       |C.SRLI (RV32:NSE, nzuimm[5]=1)        |6|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRLI64 (RV32:HINT)                  |6|Zc128	|	|	|✓	|C
|100       |C.SRAI (RV32:NSE, nzuimm[5]=1)        |7|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRAI64 (RV32/64:HINT)               |7|Zc128	|	|	|✓       |C
|100       |C.ANDI                                | |Zci	|✓	|✓	|✓	|C
|100       |C.SUB                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.XOR                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.OR                                  | |Zci	|✓	|✓	|✓	|C
|100       |C.AND                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.SUBW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C
|100       |C.ADDW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C

|101       |C.J	       | |Zci	|✓	|✓	|✓	|C


|110       |C.BEQZ	| |Zci	|✓	|✓	|✓	|C


|111       |C.BNEZ	| |Zci	|✓	|✓	|✓	|C
|===============================================================================

[#zce_quad2]
.C-extension quadrant 2
[width="100%",options=header]
|======================================================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.SLLI (rd=0:HINT; RV32 && nzuimm[5]=1:NSE)| 8|Zc32/Zc64	|✓	|✓	|	|C
|000       |C.SLLI64 (RV32/64 or rd=0:HINT)	       | 8|Zc128	        |	|	|✓	|C
|001       |C.FLDSP	                               | 9|Zcd	        |✓	|✓	|	|C+D
|001       |C.LQSP (rd=0:RSV)	                     | 9|Zc128	        |	|	|✓	|C
|001       |*unallocated*	                         | 9|*Zced* 	|✓	|✓	| 	|C+*Zce*
|010       |C.LWSP (rd=0:RSV)	                     |  |Zci	        |✓	|✓	|✓	|C
|011       |C.FLWSP	                               |10|Zcf	        |✓	|	|	|C+F
|011       |C.LDSP (rd=0:HINT)	                   |10|Zc64/Zc128	|	|✓	|✓	|C
|100       |C.JR     (rd=0:RSV)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.MV   (rd=0:HINT)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.EBREAK	                             |  |Zci   	|✓	|✓	|✓	|C
|100       |C.JALR	                               |  |Zci   	|✓	|✓	|✓	|C
|100       |C.ADD (rd=0:HINT)	                     |  |Zci   	|✓	|✓	|✓	|C
|101       |C.FSDSP	                               |11|Zcd	        |✓	|✓	|	|C+D
|101       |C.SQSP	                               |11|Zc128		|       | 	|✓	|C
|101       |*C.SH*	                               |11|*Zced**	|✓	|✓	| 	|C+*Zce*
|101       |*C.LHU*	                               |11|*Zced* 	|✓	|✓	| 	|C+*Zce*
|110       |C.SWSP	                               |  |Zci	        |✓	|✓	|✓	|C
|111       |C.FSWSP	                               |12|Zcf	        |✓	|	|	|C+F
|111       |C.SDSP	                               |12|Zc128	        |	|✓	|✓	|C
|======================================================================================================

== Allocation of new 16-bit encodings

This section gives a short-hand lookup of exactly where the new encodings are allocated to make it easier to review the encoding space. The first column is the group number from <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>>.

|======================================
|Group|[15:13]|[12:10]|[1:0]|Instruction

| |100    |000    |00   |C.POP, C.POPRET, C.PUSH
| |100    |001    |00   |C.[SZ]EXT.[BH], C.LSBNOT, C.MUL
| |100    |01x    |00   |C.L[BH]USP, C.S[BH]SP
| |100    |100    |00   |C.MVA01S07, C.MVA23S07
| |100    |101    |00   |C.MVP
| |100    |11x    |00   |C.TBLJAL

|1|001    |xxx    |00   |C.DECBGEZ

|3|101    |0xx    |00   |C.SB
|3|101    |1xx    |00   |C.LBU

| |011    |000    |00   |C.NOT
| |011    |001    |00   |C.NEG


|11|101   |0xx    |10   |C.SH
|11|101   |1xx    |10   |C.LHU
|======================================


=== Spare 16-bit encodings

Some spare encodings are noted in the tables below. The remaining unallocated space is listed here:

[#spare encodings]
.spare 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  011       |0   |1  4+|xxxx         5+|00000              2+|01     | *reserved*
17+|These three are RV32 only
3+|  000       |1 10+|  xxxxx                                 2+|10     | *reserved*
3+|  100       |1   |0  9+| xxxx                              2+|01     | *reserved*
3+|  100       |1 2+|11 8+| xxxx                              2+|00     | *reserved*
17+|This conflicts with the D-extension
3+|  001     11+|xxxx                                         2+|10     | *reserved*
|================================================================================================

[#pushpoppopret]
== `PUSH/POP/POPRET`

`PUSH/POP/POPRET` are used to reduce the size of function prologues and epilogues.

=== A brief example from Zephyr

This example gives a nice illustration of what `PUSH/POP/POPRET` are trying to achieve.

[source,sourceCode,text]
----
from subsys/bluetooth/controller/crypto/crypto.c
int bt_rand(void *buf, size_t len)
{
        return lll_csrand_get(buf, len);
}
----

compiles with GCC10 to:

[source,sourceCode,text]
----
20405458 <bt_rand>:
20405458:	1141                	addi	sp,sp,-16	;#PUSH(1)
2040545a:	c04a                	sw	s2,0(sp)	;#PUSH(2)
2040545c:	70000937          	lui	s2,0x70000
20405460:	62090613          	addi	a2,s2,1568 # 70000620 <prng>
20405464:	c422                	sw	s0,8(sp)	;#PUSH(3)
20405466:	c226                	sw	s1,4(sp)	;#PUSH(4)
20405468:	c606                	sw	ra,12(sp)	;#PUSH(5)
2040546a:	842a                	mv	s0,a0		;#PUSH(6)
2040546c:	84ae                	mv	s1,a1		;#PUSH(7)
<function body>
20405494:	4501                	li	a0,0		;#POPRET(1)
20405496:	40b2                	lw	ra,12(sp)	;#POPRET(2)
20405498:	4422                	lw	s0,8(sp)	;#POPRET(3)
2040549a:	4492                	lw	s1,4(sp)	;#POPRET(4)
2040549c:	4902                	lw	s2,0(sp)	;#POPRET(5)
2040549e:	0141                	addi	sp,sp,16	;#POPRET(6)
204054a0:	8082                	ret			;#POPRET(7)
----

with the GCC option `msave-restore` the output is the following:

[source,sourceCode,text]
----
204089ac <bt_rand>:
204089ac:       f97f72ef                jal     t0,20400942 <__riscv_save_0>	;#PUSH(1)
204089b0:       70001937                lui     s2,0x70001
204089b4:       ac090613                addi    a2,s2,-1344 # 70000ac0 <prng>
204089b8:       842a                    mv      s0,a0	;#PUSH(2)
204089ba:       84ae                    mv      s1,a1	;#PUSH(3)
<function_body>
204089e2:       4501                    li      a0,0	;#POPRET(1)
204089e4:       f83f706f                j       20400966 <__riscv_restore_0>	;#POPRET(2)
----

with `PUSH/POPRET` this reduces to

[source,sourceCode,text]
----
20405458 <bt_rand>:
20405458:	<16-bit>                push	 {ra,s0-s2},{a0-a1},-16
2040545c:	70000937          	lui	s2,0x70000
20405460:	62090613          	addi	a2,s2,1568 # 70000620 <prng>
<function body>
20405496:	<16-bit>                popret	 {ra,s0-s2},{0} 16

----

The prologue / epilogue reduce from 28-bytes in the original code, to 14-bytes with `-msave-restore`, and to to 8-bytes with `PUSH/POP`, which will also improve the performance.

[NOTE]

  We should also develop a better optimised version of `-msave-restore`
  
[NOTE]

  The calls to `<riscv_save_0>/<riscv_restore_0>` become 64-bit when the target functions are out of the +/-1MB range, increasing the prologue/epilogue size to 22-bytes.

=== Assembler Syntax

[source,sourceCode,text]
----
//these encodings may be 16-bit or 32-bit depending upon the parameters
push           {<rsreg_list>},[{<areg_list>},] -<stack_adjustment>
pop            {<rsreg_list>},[{ret_val},]      <stack_adjustment> 
popret         {<rsreg_list>},[{ret_val},]      <stack_adjustment> 
----

. The `PUSH` instruction 
** pushes(stores)  the registers specified in `rsreg_list` to the stack
** if `areg_list` is included, moves the registers in the `areg_list` into `s` registers
** adjusts the stack pointer by the `stack_adjustment` 

. The `POP` instruction 
** pops(loads) the registers in `rsreg_list to the stack` from the stack
** if `ret_val` is included, moves the specified value into `a0` as the return value
** adjusts the stack pointer by the `stack_adjustment`.

. `POPRET` has the same behaviour as `POP`, followed by `RET`.

[source,sourceCode,text]
----
//these encodings are 32-bit as F registers are included in the list
//the length of the F registers is specified in the opcode
push.[fdq]     {<fsreg_list>}, -<stack_adjustment> 
pop.[fdq]      {<fsreg_list>},  <stack_adjustment> 
popret.[fdq]   {<fsreg_list>},  <stack_adjustment> 
----

These instructions allow `fs` registers to be pushed/popped and do not allow `areg_list` or `ret_val` to be specified (to save encoding space).

32-bit and 16-bit forms are available, the assembler should choose the 16-bit form if the parameters permit.

The registers in `reg_list` and `areg_list` are comma separated lists and must not be empty.

[source,sourceCode,text]
----
<sreg_list>  ::= <ra> "," <sreg_range> | <ra> | <sreg_range>
<rsreg_list> ::= <ra> "," <sreg_range> | <ra>
<fsreg_list> ::= <ra> "," <sreg_range> ", " <freg_range> | <ra> "," <freg_range> | <sreg_range> "," <freg_range> | <freg_range>
<rfsreg_list> ::= <ra> "," <sreg_range> ", " <freg_range> | <ra> "," <freg_range>
<areg_list>  ::= <areg_range>
<ret_val>    ::= s0 | 0 | 1
<sreg_range> ::= <s0>  | <s0-sN>   (where N is in the range [1, 11])
<freg_range> ::= <fs0> | <fs0-fsM> (valid values of M are 1,2,3,5,8,11)
<areg_range> ::= <a0>  | <a0-aP>   (where P is in the range [1, 2])
<reg_list>   ::= <sreg_list>  | <rsreg_list> | <fsreg_list> | <rfsreg_list>

//legal syntax

push         {<sreg_list>},  [{<areg_list>}],-stack_adjustment
push.[fdq]   {<fsreg_list>},                 -stack_adjustment

pop          {<sreg_list>},  [{ret_val},]    stack_adjustment
pop.[fdq]    {<fsreg_list>},                 stack_adjustment

popret       {<rsreg_list>}, [{ret_val},]    stack_adjustment //popret must include ra
popret.[fdq] {<rfsreg_list>},                stack_adjustment //popret must include ra

----

For the 16-bit encodings

. In `reg_list`
.. `ra` must be included
.. `s0-sN` may be included, valid values of `N` are 0,1,2,3,5,8,11
.. `fs0-fsM` must not be included
. for `pop, ret_val` must not be included 
. for `popret, ret_val` may be included - and can only be set to `0`
.. rationale: about 27% of functions which infer `popret` issue `li a0, 0` first
. for `push` only specific combinations of `areg_list` and `sreg_list` are permitted
.. `if sreg_list={ra}:       areg_list={}`
.. `if sreg_list={ra,s0}:    areg_list={a0}`
.. `if sreg_list={ra,s0-sN}: areg_list={a0-a1} where N=1,2,3`
.. `if sreg_list={ra,s0-sN}: areg_list={a0-a2} where N=5,8,11`
. The `stack_adjustment` must be no more than the total memory required for `reg_list`, rounded up to a multiple of 16-bytes, plus an additional (0..7)*16-bytes.

Examples of valid 16-bit encodings for RV32 or RV64:

[source,sourceCode,text]
----

push   {ra},                 -16; //store ra;                                      decrement sp by 16
push   {ra,s0},    {a0},     -32; //store ra,s0;     mv s0,a0;                     decrement sp by 32
push   {ra,s0-s3}, {a0-a1},  -96; //store ra,s0-s3;  mv s0,a0; mv s1,a1;           decrement sp by 96
push   {ra,s0-s11},{a0-a2}, -128; //store ra,s0-s11; mv s0,a0; mv s1,a1; mv s2,a2; decrement sp by 128

pop    {ra},        16;  //load  ra;        increment sp by 16
popret {ra},        16;  //load  ra;        increment sp by 16; jump to ra

pop    {ra,s0},     32;  //load  ra,s0;     increment sp by 32
popret {ra,s0},{s0},32;  //load  ra,s0;     increment sp by 32; mv a0, s0; jump to ra

pop    {ra,s0-s3},  96;  //load  ra,s0-s3;  increment sp by 96
popret {ra,s0-s3},  96;  //load  ra,s0-s3;  increment sp by 96; jump to ra

pop    {ra,s0-s11}, 128; //load  ra,s0-s11; increment sp by 128
popret {ra,s0-s11}, 128; //load  ra,s0-s11; increment sp by 128; jump to ra

----
[NOTE]
  There is no encoding space in the 16-bit `c.push` encoding to explicitly specify `areg_list` so it is automatically determined from the `reg_list` value based on analysing usage in the benchmark suite


[NOTE]
  To save encoding space some opcodes do not allow the full range of `spimm` or `reg_list` which reduces the possible `stack adjustment` range further, see <<#pushpoppopret16bitencodings>>

For the 32-bit encodings

. The `stack_adjustment` must be no more than the total memory required for `reg_list`, rounded up to a multiple of 16-bytes, plus an additional (0..15)*16-bytes.

For example

. `push   {ra,s0-s2}, {a0-a1}, -64` can use a 16-bit encoding
. `push   {s0-s2},    {a0-a1}, -64` must use a 32-bit encoding as `ra` is not in the register list
. `push   {ra,s0-s2}, {a0-a1}, -256` must use a 32-bit encoding as the `stack_adjustment` is out of range
. `push   {ra,s0-s2},          -32` must use a 32-bit encoding as `sreg_list` requires `areg_list={a0-a1}` for the 16-bit encoding
. `push.f {ra,s0-s2, fs0},     -64` must use a 32-bit encoding as `fs0` is in the register list
. `pop    {ra,s0-s2}, {s0},     32` must use a 32-bit encoding as `ret_val` is specified
. `popret {ra,s0-s2}, {s0},     32` must use a 32-bit encoding as `c.popret` only supports `0` as the `ret_val` value

To be a legal encoding:

1.  The stack adjustment must be negative for all `PUSH` variants and positive for all `POP/POPRET` variants
2.  The stack adjustment must be in range (see <<spimm>>) and must be a multiple of 16
3.  The register lists must be valid (see above)
4.  If any `f` registers are included in the list there must be an `.[fdq]` suffix
5.  It there is an `.[fdq]` suffix, there must be `f` registers in the list
6.  It there is an `.[fdq]` suffix, `areg_list` must not be included in the synax
7.  For `POPRET` variants, `rsreg_list` must include `ra`
8.  `areg_list` must not be included for all `POP` and `POPRET` variants and for `PUSH.[FDQ]`

Additionally:

. If `sp` is not 16-byte aligned then take a load (`push`) or store (`POP/POPRET`) address misaligned exception, and do not issue any loads or stores.

[NOTE]
  When moving from loading or storing `x` registers to `f` registers there may be a gap as the registers may be different widths, and all registers must be aligned in memory

=== Determining XLEN and FLEN to decode and execute the instructions

The width of `x` registers in the register list depends upon XLEN and so `misa.MXL`. From the ELF file header, XLEN is determined by the following flags:

* ELFCLASS64 for RV64
* ELFCLASS32 for RV32 

[NOTE]

  I don't think there's an ELFCLASS128 for RV128

If using a debugger then `misa.MXL` can be read, if XLEN is not known for the core.

FLEN is explicitly specified in the opcode as the presence of any `f` registers requires a `.[fdq]` suffix on the opcode.

Follow this link for details of the https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md#file-header[ELF file header]

==== Rationale: why include the .[fdq] suffix

It is required to hard-code the length of the `f` registers in the opcode, and not just save/restore the whole register. We must allow code compiled for the F-extension
to run on a  core which supports D and possibly Q. We must also allow code compiled for the D-extension to run on a core which supports Q.

If we don't explicitly state the `f` register width and always store the whole register, then the registers will be stored at different addresses to the ones expected 
by the compiler. 

An alternative would be to use `misa.[FDQ]`
to directly control the behaviour and so set `misa.[DQ]=0` when running F code. Nothing else in the architecture requires this, so it seems unreasonable to 
add this requirement here. This approach also wouldn't work for `Z[FDQ]inx` cores as `misa.[FDQ]` are all hardwired to zero.

=== Pseudo-code

The pseudo-code below show the required architectural state updates. 

Note that every architectural state update in the pseudo-code can be executed as a standard RISC-V 32-bit encoding, so that it is possible execute the instructions as sequences of standard instructions. 

Because the pseudo-code includes load or store operations, they may take any fault caused by executing loads or stores. See <<fault-handling>> for more details.

==== PUSH Pseudo-code

All variants of the `PUSH` instruction store the set of registers from `reg_list` to consecutive memory locations, and decrement the stack pointer.
The pseudo-code uses assembly inserts so that it can use `fsw/fsd` etc.

The pseudo-code shows the memory and architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is negative.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])     {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw ra, 0(addr)");
    8:  asm("sd ra, 0(addr)");
    16: asm("sq ra, 0(addr)");
  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("sw s[i], 0(addr)");
    8:  asm("sd s[i], 0(addr)");
    16: asm("sq s[i], 0(addr)");
  }
}
if (freq_list) {
  switch (opcode) {
    //if FLEN > XLEN, then get the address back into alignment before saving the F registers
    "PUSH.D": while(addr% 8) {addr-=bytes;}
    "PUSH.Q": while(addr%16) {addr-=bytes;}
  }
  for(i in freg_list)  {
    switch (opcode) {
      "PUSH.F": {addr-= 4;asm("fsw fs[i], 0(addr)");}
      "PUSH.D": {addr-= 8;asm("fsd fs[i], 0(addr)");}
      "PUSH.Q": {addr-=16;asm("fsq fs[i], 0(addr)");}
    }
  }
}
if (areg_list) {
  for (i in areg_list) {
    asm("mv s[i], a[i]");}
  }
}
sp+=stack_adjustment; //decrement
----

==== POP/POPRET Pseudo-code

A `POP/POPRET` instruction loads the set of registers from `reg_list` from consecutive memory locations, and then increments the stack pointer. 
The pseudo-code uses assembly inserts so that it can use `flw/fld/ret`.

The pseudo-code shows the architectural state updates of the whole instruction which has completed without faults, debug halts or interrupts. See <<fault-handling>> and <<software-view>> for more information.

[NOTE]
  `stack_adjustment` is positive.

[source,sourceCode,text]
----
//sp must be correctly aligned
if (sp[3:0])     {take_illegal_instruction_exception();}
if (misa.MXL==1) {bytes=4;}
if (misa.MXL==2) {bytes=8;}
else             {bytes=16;}
addr=sp+stack_adjustment;
if (ra) {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw ra, 0(addr)");
    8:  asm("ld ra, 0(addr)");
    16: asm("lq ra, 0(addr)");

  }
}
for(i in sreg_list)  {
  addr-=bytes;
  switch(bytes) {
    4:  asm("lw s[i], 0(addr)");
    8:  asm("ld s[i], 0(addr)");
    16: asm("lq s[i], 0(addr)");
  }
}
if (freq_list) {
  switch (opcode) {
    //if FLEN > XLEN, then get the address back into alignment before saving the F registers
    "POP.D", "POPRET.D": while(addr% 8) {addr-=bytes;}
    "POP.Q", "POPRET.Q": while(addr%16) {addr-=bytes;}
  }
  for(i in freg_list)  {
    switch (opcode) {
      "POP.F", "POPRET.F": {addr-= 4;asm("flw fs[i], 0(addr)");}
      "POP.D", "POPRET.D": {addr-= 8;asm("fld fs[i], 0(addr)");}
      "POP.Q", "POPRET.Q": {addr-=16;asm("flq fs[i], 0(addr)");}
    }
  }
}
if (ret_val) {
   switch(ret_val) {
      "s0": asm("mv a0, s0");
      "0":  asm("li a0, 0");
      "1":  asm("li a0, 1");
   }
}
sp+=stack_adjustment; //increment
if (opcode == "POPRET") { 
   asm("ret");
}
----

[#pushpoppopret32bitencodings]
=== 32-bit Encodings

NOTE]

  These encodings are provisional.


.push/pop 32-bit encodings
[options="header",width="100%"]
|=========================================================================================================================
| 31:27              |26|25     |24 |23|22|21:20         |19:18|17:16|15 | 14:12   | 11:10 |9: 7      | 6 : 0 | instruction
15+|`PUSH` encodings
2+|0000000         2+|00         2+|00   |mv          2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH
2+|0000000         2+|00         2+|01   |frcount     2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH.F
2+|0000000         2+|00         2+|10   |frcount     2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH.D
2+|0000000         2+|00         2+|11   |frcount     2+|rcount     |ra | 001   2+| spimm             |1000011| PUSH.Q
15+|`POP` encodings
2+|0000000         2+|01         2+|00   |ret_val     2+|rcount     |ra | 010   2+| spimm             |1000011| POP
2+|0000000         2+|01         2+|01   |frcount     2+|rcount     |ra | 010   2+| spimm             |1000011| POP.F
2+|0000000         2+|01         2+|10   |frcount     2+|rcount     |ra | 010   2+| spimm             |1000011| POP.D
2+|0000000         2+|01         2+|11   |frcount     2+|rcount     |ra | 010   2+| spimm             |1000011| POP.Q
15+|`POPRET` encodings
2+|0000000         2+|10         2+|00   |ret_val     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET
2+|0000000         2+|10         2+|01   |frcount     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET.F
2+|0000000         2+|10         2+|10   |frcount     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET.D
2+|0000000         2+|10         2+|11   |frcount     2+|rcount     |1  | 011   2+| spimm             |1000011| POPRET.Q
|=========================================================================================================================

[NOTE]
  bits [23:22] are the `fdq` field
  `ra=1` for all `popret` encodings, it is not specified in the encoding

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here] and the 16-bit encoding is in <<pushpop16>>.


==== Illegal instructions for the 32-bit encodings

The encoding takes the same behaviour as any floating point instruction if executed when disabled:

* if `frcount>0` and `misa.F==0`
* if `frcount>0` and `fdq==1` and `misa.D==0`
* if `frcount>0` and `fdq==2` and `misa.Q==0`

The following cases do not decode as `PUSH*/POP*/POPRET*`

* No registers are specified (`rcount, frcount` are both zero)
* `rcount>14`
* `fdq=3`
* `rcount==13` and `frcount>0` and the opcode doesn't have an `[fdq]` suffix

==== Rational: `rcount=13, frcount=0` saving all saved registers

The debian distro does save all `s` and `fs` registers on a few occasions, so I used a special encoding for this case. I saw no justification for saving all `fs` registers *without* saving all `s` registers. It seems useful to have a form which saves all saved registers.

The programmable range for `frcount` doesn't save many `fs` registers as `FPMark` only saves one or two and Debian rarely saves more than that.


[#pushpoppopret16bitencodings]
=== 16-bit Encodings

[NOTE]

  The reserved 16-bit encodings could be used for EABI versions in the future.

[#proposed-16bit-encodings-1]
.PUSH/POP 16-bit encodings
[width="100%",options=header]
|===============================================================================
|15 |14 |13 |12 |11 |10  |9 |8  |7 |6   |5 |4 |3 |2           |1 |0 |instruction
17+|`C.POP` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0  |0 2+|rcount[1:0]|0 |0 2+|00 | spimm[0] 2+| 00  |C.POP
3+|100  |0  |0  |0  |1 2+|xx         |0 |0 3+|xxx           2+| 00  |*reserved*
3+|100  |0  |0  |0 3+|xxx            |0 |0 2+|!=00| x       2+| 00  |*reserved*
17+|`C.POPRET` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0 3+|rcount[2:0]  |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET
3+|100  |0  |0  |0   |1 2+|xxx        |x|1 |1 2+|xx         2+| 00  |*reserved*
17+|`C.PUSH` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0 3+|rcount[2:0]  |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH
3+|100  |0  |0  |0   |1 2+|xx      |1 |0   |1 2+|xx         2+| 00  |*reserved*
|===============================================================================

  * For `C.POPRET`, `ret_val[0]=ret0` as specified in the encoding, `ret_val[1]=0`. 
  * For `C.POP` `ret_val[1:0]=0`.
  * Some encodings remain *reserved* for the time being so we can add them later if they can be justified
  ** For `C.POP`, `rcount[2]=1` is reserved
  ** For `C.POP`, `spimm > 1` is reserved
  ** For `C.PUSH/C.POPRET`, `rcount[2]=1 && spimm[2]=1` is reserved


=== Encoding Fields

[#spimm]
==== `spimm` encoding field

The `stack_adjustment` field in the assembly syntax comprises of two components:

. the memory required for the registers in the list, rounded up to 16-bytes (using the `Align16` function below)
. additional stack space allocated for local variables, encoded in the `spimm` field

The 16-bit encoding allows up to 7 additional 16-byte blocks (as `spimm` has up to 3-bits), and the 32-bit encoding allows up to 31.

[NOTE]
  we may change the size of `spimm` in the 32-bit encoding once benchmarking work has completed

[source,sourceCode,text]
----
//the padding calculation requires SP to be 16-byte aligned before executing the instruction
if (FLEN>XLEN && 
    number_of_registers_in_freg_list>0 && 
    number_of_registers_in_reg_list % (FLEN/XLEN)>0) {
  //need padding to ensure FLEN registers are aligned
  padding = (FLEN/XLEN - number_of_registers_in_reg_list % (FLEN/XLEN)) * XLEN/8;
} else {
  padding = 0
}
total_register_bytes = number_of_registers_in_reg_list * XLEN/8 + padding + number_of_registers_in_freg_list * FLEN/8;
stack_adjustment = Align16(total_register_bytes) + 16*spimm;
----

The bytes required for padding is simple - if FLEN==XLEN it's always zero. If FLEN=2*XLEN it is 0 or 4. RV32Q is more complex (see below) but this is an unlikely configuration.
`n` is an integer in the tables so `2n` is always even, `2n+1` is always odd.

[#padding-examples-RV32D]
.RV32D padding examples, XLEN=32, FLEN=64
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1   |4-bytes
|====================================

[#padding-examples-RV64Q]
.RV64Q padding examples, XLEN=64, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 2n     |none                     
| 2n+1  |4-bytes
|====================================

[#padding-examples-RV32Q]
.RV32Q padding examples, XLEN=32, FLEN=128
[options="header"]
|====================================
| #Xreg  |Padding required if accessing Fregs
| 4n     |none                     
| 4n+1   |4-bytes
| 4n+2   |8-bytes                     
| 4n+3   |12-bytes
|====================================

==== `mv, ret_val, ra, frcount, rcount` for the 32-bit encodings

The registers in the `reg_list` are controlled by these fields

Note that `frcount`, `mv` and `ret_val` are in the same location in the encoding.

[#32bit-frcount]
.`frcount` values for the 32-bit encodings for `PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]`
[options="header"]
|=====================
|frcount | ABI names  
| 0      |none or `fs0-fs11` (see `rcount=13`)
| 1      |fs0         
| 2      |fs0-fs1
| 3      |fs0-fs5
|=====================

[#32bit-mv]
.`mv` values for the 32-bit encodings for `PUSH`
[options="header"]
|=========================================
|mv      |ABI names  
| 0      |none        
| 1      |a0
| 2      |a0-a1
| 3      |a0-a2
|=========================================

[#32bit-ret_val]
.`ret_val` values for the 32-bit encodings for `POP, POPRET`
[options="header"]
|=========================================
|return value      |ABI names  
| 0      |none (don't set a0)        
| 1      |a0=0
| 2      |a0=1
| 3      |a0=s0
|=========================================

[#32bit-ra]
.`ra` values for the 32-bit encodings 
[options="header"]
|=========================================
|ra      |ABI names  
| 0      |none        
| 1      |ra
|=========================================

[#32bit-rcount]
.`rcount` field values for the 32-bit encodings
[options="header"]
|==========================
|rcount  | ABI names      
| 0      |none       
| 1      |s0
| 2      |s0-s1
| 3      |s0-s2
| 4      |s0-s3
| 5      |s0-s4
| 6      |s0-s5
| 7      |s0-s6
| 8      |s0-s7
| 9      |s0-s8
| 10     |s0-s9
| 11     |s0-s10
| 12     |s0-s11
2+|  `rcount=13` is valid if `frcount=0` for `[.fdq]` opcodes
| 13     |s0-s11,fs0-fs11
2+|these values could be used for interrupt save/restore
| 14-15  | *reserved*
|==========================

==== `rcount`, `ret_val` for the 16-bit encodings

[#rcount-table]
.`rcount` values for the 16-bit encodings
[options="header",width=100%]
|============================
|rcount| ABI names
|0     |ra
|1     |ra, s0
|2     |ra, s0-s1
|3     |ra, s0-s2
2+|Following options for `C.PUSH/C.POPRET` only
|4     |ra, s0-s3
|5     |ra, s0-s5
|6     |ra, s0-s8
|7     |ra, s0-s11
|============================

`ret_val` is as specified in <<32bit-ret_val>>. Note that:

* `C.POPRET` allows bit 0 to vary, bit 1 is always 0
* `C.POP` always has `ret_val=0` to save encoding space

[#fault-handling]
=== Fault handling

The sequence required to execute the instruction may be interrupted, or may not be able to start execution for several reasons.

* virtual memory page fault or PMP fault
** these can be detected before execution, or during execution if the memory addresses cross a page/PMP boundary
* watchpoint trigger
** these can be detected before execution, or during execution depending on the trigger type (load data triggers require the sequence to have started executing, for example)
* external debug halt
** the halt can treat the whole sequence atomically, or interrupt mid sequence (implementation defined)
* debug halt caused by a trigger
** same comment as watchpoint trigger above
* load access fault
** these are detected while the sequence is executing
* store access fault (precise or imprecise)
** these may be detected while the sequence is executing, or afterwards if imprecise
* interrupts
** these may arrive at any time. An implementation can choose whether to interrupt the sequence or not.

Because some faults can only be detected during the sequence the core implementation is able to recover from the fault and re-execute the sequence. This may involve executing some or all of the loads and stores from the sequence multiple times before the sequence completes (as multiple faults or multiple interrupts are possible).

Therefore correct execution requires that `sp` refers to idempotent memory (see <<non-idem-mem>> for non-idempotent handling)

[#software-view]
=== Software view of execution

==== Software view of `PUSH` sequence

From a software perspective the `PUSH` sequence appears as:

* A sequence of stores writing a contiguous block of memory. Any of the bytes may be written multiple times.
* A stack pointer adjustment

Because the memory is idempotent and the stores are non-overlapping, they may be reordered, grouped into larger accesses, split into smaller access or any combination of these.

If an implementation allows interrupts during the sequence, and the interrupt handler uses `sp` to allocate stack memory, then any stores which were executed before the interrupt maybe be overwritten by the handler. This is safe because the memory is idempotent and the stores will be re-executed once the handler completes.

The stack pointer adjustment must only be committed once it is certain that all of the stores will complete within triggerring any precise faults (stores may return imprecise bus errors which are received after the instruction has completed execution).

Referring to the example in <<push-example-1>> 

[source,sourceCode,text]
----
c.push  {ra, s0-s5},{a0-a2}, -64
----

Appears to software as:

[source,sourceCode,text]
----
# any bytes from SP-1 to SP-28 may be written multiple times before the instruction completes
sw  ra, -4(sp);   
sw  s0, -8(sp);   
sw  s1,-12(sp);   
sw  s2,-16(sp);  
sw  s3,-20(sp);   
sw  s4,-24(sp);   
sw  s5,-28(sp);   

# these must only execute once, and will only execute after all stores complete sucessfully
mv s0, a0;
mv s1, a1;
mv s2, a2;
addi sp, sp, -64; 
----

==== Software view of `POP/POPRET` sequence

From a software perspective the `POP/POPRET` sequence appears as:

* A sequence of loads, any of which may be executed multiple times
* A stack pointer adjustment
* An optional `RET`

If an implementation allows interrupts during the sequence, then any loads which were executed before the interrupt may update architectural state. The loads will be re-executed once the handler completes, so the values will be overwritten. Therefore it is permitted for an implementation to update some of the destination registers before taking the interrupt or other fault.

The register moves and stack pointer adjustment must only be committed once it is certain that all of the loads will complete successfully.

For `POPRET` once the stack pointer adjustment has been committed the `RET` must execute.

Referring to the example in <<popret-example-1>> 

[source,sourceCode,text]
----
popret   {ra, s0-s3}, {s1}, 32 ; 
----

Appears to software as:

[source,sourceCode,text]
----
# any or all of these load instructions may execute multiple times
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);
lw   s2, 16(sp);
lw   s3, 12(sp);
flw  fs0, 8(sp);
flw  fs1, 4(s0);

# must only execute once, will only execute after all loads complete successfully
# all instructions must execute atomically
mv a0, s1
addi sp, sp, 32;
ret;
----
[[non-idem-mem]]
==== Non-idempotent memory

An implementation may have a requirement to issue `PUSH/POP/POPRET` to non-idempotent memory. 

==== Error detection

If the core implementation does not have a requirement to support `PUSH/POP/POPRET` to non-idempotent memories, and the core can use a PMA to detect that the memory is non-idempotent, then take a load(`POP/POPRET`) or store (`PUSH`) access fault exception.

==== Non-idempotent support

It is possible to support non-idempotent memory. One reason is to re-use `PUSH/POP` as a restricted form of a load/store multiple instruction to a peripheral (see <<ldstm>>), as there is no generic load/store multiple instruction currently in the RISC-V ISA. If load/store multiple is supported in the future then it should support non-idempotent memory.

Non-idempotent memory support requires additional restrictions:

. Do not allow interrupts during execution
. Do not allow external debug halt during execution
. Detect any virtual memory page faults or PMP faults for the whole instruction before starting execution (instead of during the sequence)
. Do not split / merge / reorder the generated memory accesses

It is possible that one of the following will still occur during execution:

. Watchpoint trigger
. Load/store access fault

In these cases the core will jump to the debug or exception handler. If execution is required to continue afterwards (so the event is not fatal to the code execution), then the handler is required to do so in software. 

By following these rules memory accesses will only ever be issued once, and in the order listed in the pseudo-code.

It is possible for implementations to follow these restricted rules and to safely access both types of memory. It is also possible for an implementation to use PMAs to detect the memory type and apply different rules, such as only allowing interrupts if accessing cacheable memory, for example.

=== Toolchain implementation

`PUSH/POP/POPRET` can be generated by the compiler, but can also be added as an optimisation in the linker. If they are inferred at link time then they can also be used to optimise precompiled library code. This means that the libraries can be shipped without these instructions, but platforms which implement them can still benefit from the code-size saving.

=== Assembly examples

[#push-example-1]
==== C.PUSH RV32 UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push  {ra, s0-s5}, {a0-a2}, -64
----

Encoding: rcount=5, spimm=2

Equivalent sequence:

[source,sourceCode,text]
----
sw  ra, -4(sp);
sw  s0, -8(sp); 
sw  s1, -12(sp);
sw  s2, -16(sp); 
sw  s3, -20(sp);
sw  s4, -24(sp); 
sw  s5, -28(sp);
mv  s0, a0;
mv  s1, a1;
mv  s2, a2;
addi sp, sp, -64;
----

==== C.PUSH RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.push {ra, s0-s1}, {a0-a1} -32
----

Encoding: rcount=2, spimm=1

Equivalent sequence:

[source,sourceCode,text]
----
sw  ra, -4(sp);
sw  s0, -8(sp); 
sw  s1, -12(sp);
mv s0, a0;
mv s1, a1;
addi sp, sp, -32;
----

==== C.POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw   ra, 156(sp);
lw   s0, 152(sp);  
lw   s1, 148(sp);  
lw   s2, 144(sp);  
lw   s3, 140(sp);  
lw   s4, 136(sp);  
lw   s5, 132(sp);  
lw   s6, 128(sp);  
lw   s7, 124(sp);  
lw   s8, 120(sp);  
addi sp, sp, 160
----

==== C.POPRET RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
c.pop   {ra, s0-s7},{s0}, 160
----

Encoding: rcount=6, spimm=7 

Equivalent sequence:

[source,sourceCode,text]
----
lw   ra, 156(sp);
lw   s0, 152(sp);  
lw   s1, 148(sp);  
lw   s2, 144(sp);  
lw   s3, 140(sp);  
lw   s4, 136(sp);  
lw   s5, 132(sp);  
lw   s6, 128(sp);  
lw   s7, 124(sp);  
lw   s8, 120(sp);  
addi sp, sp, 160;
mv a0, s0;
ret
----

==== PUSH.F RV32I[FDQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.f  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rcount=5, frcount=1, fdq=0, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sw  ra,   -4(sp);
sw  s0,   -8(sp); 
sw  s1,  -12(sp); 
sw  s2,  -16(sp); 
sw  s3,  -20(sp); 
sw  s4,  -24(sp); 
fsw fs0, -28(sp)
addi sp, sp, -64;
----

==== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {ra, s0-s4, fs0}, -64
----

Encoding: ra=1, rcount=5, frcount=1, fdq=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
sd  ra,  -8(sp);
sd  s0,  -16(sp); 
sd  s1,  -24(sp);
sd  s2,  -32(sp); 
sd  s3,  -40(sp);
sd  s4,  -48(sp); 
fsd fs0, -56(sp)
addi sp, sp, -64;
----

==== PUSH.D RV64I[DQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
push.d  {fs0-fs7}, -128
----

Encoding: rcount=0, frcount=12, fdq=2, spimm=2 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
fsd  fs0,  -8(sp);
fsd  fs1, -16(sp); 
fsd  fs2, -24(sp);
fsd  fs3, -32(sp); 
fsd  fs5, -40(sp); 
fsd  fs4, -48(sp);
fsd  fs6, -56(sp);
fsd  fs7, -64(sp); 
fsd  fs8, -72(sp); 
fsd  fs9, -80(sp); 
fsd  fs10,-88(sp); 
fsd  fs11,-96(sp); 
addi sp, sp, -128; 
----

==== POP RV32I UABI (16-byte aligned stack)

[source,sourceCode,text]
----
pop   {ra, s0-s9}, {s0}, 256
----

Encoding: ra=1, rcount=10, frcount=0, spimm=13 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 252(sp);
lw   s0, 248(sp);
lw   s1, 244(sp);  
lw   s2, 240(sp)
lw   s3, 236(sp);  
lw   s4, 232(sp);
lw   s5, 228(sp);  
lw   s6, 224(sp)
lw   s7, 220(sp);  
lw   s8, 216(sp);
lw   s9, 212(sp); 
mv   a0, s0
addi sp, sp, 256
----

[#popret-example-1]
==== POPRET.F RV32I[FDQ] UABI (16-byte aligned stack)

[source,sourceCode,text]
----
popret.f   {ra, s0-s3, fs0-fs1}, 32
----

Encoding: ra=1, rcount=4, frcount=2, fdq=1, spimm=0 (16-byte aligned)

Micro operation sequence:

[source,sourceCode,text]
----
lw   ra, 28(sp);
lw   s0, 24(sp);
lw   s1, 20(sp);  
lw   s2, 16(sp);
lw   s3, 12(sp);  
flw  fs0, 8(sp);
flw  fs1, 4(s0);  
addi sp, sp, 32; 
ret
----

[[ldstm]]
=== Appendix: Usage as load/store-multiple

`PUSH/POP` encodings can be reused as generic load/store multiple instructions. For example:

[source,sourceCode,text]
----

lui t0, 0xffff
sw  s5, 4c(t0)
sw  s4, 50(t0)
sw  s3, 54(t0)
sw  s2, 58(t0)
sw  s1, 5c(t0)
sw  s0, 60(t0)

----

Can be replaced by

[source,sourceCode,text]
----

lui t0, 0xffff
addi sp, t0, 64
push {s0-s5}, -64

----

This requires that  `sp` is saved before and restored after the sequence. Also `POP` can be used to replace the equivalent series of loads. 

Even though there is not much code-size saving once the `sp` save/restore code has been included, and the restricted memory layout targetted by the instructions, there may be a performance benefit to doing this for small embedded cores. A load/store-multiple sequence may be issued to the peripheral bus as a single burst instead of multiple single accesses which individually require arbitration. In some cases this can save one or more cycles per access as the arbiter remains locked to the core until the sequence has completed.

If the target memory is non-idempotent then see <<non-idem-mem>> for additional constraints.

== `Zces` definition

`Zces` is optional as cores may not want to build the sequencer to issue the instructions.

=== PUSH/POP/POPRET

See <<pushpoppopret>> for the specification.

[[pushpop32]]
==== PUSH, POP, POPRET, PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]

See <<pushpoppopret32bitencodings>> for the encodings.

[[pushpop16]]
==== C.PUSH, C.POP, C.POPRET

See <<pushpoppopret16bitencodings>> for the encodings.

=== C.MVA01S07, C.MVA23S07

Register moves are the most common in GCC output in both the benchmark suite and the Debian distro. These two instructions combine two very common pairs of moves into single 16-bit encodings:

* move from two `s[0-7]` registers into `a0` and `a1`.
* move from two `s[0-7]` registers into `a2` and `a3`.

[NOTE]

  The syntax takes ABI names not `x` register names, so it is unusual. However this allows much more frequent usage without increasing the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional (`Zces`) as they require 2 register file write ports, or are sequenced.

[#proposed-16bit-encodings-4]
.`C.MV01S07, C.MV23S07` 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     2+|10     3+| 000      3+|sreg1      3+|sreg2    2+| 00    | C.MVA01S07
3+|  100     2+|10     3+| 001      3+|sreg1      3+|sreg2    2+| 00    | C.MVA23S07
|================================================================================================

[#mvs07_semantics]
.`C.MV01S07, C.MV23S07` semantics
[width="100%",options=header]
|=======================================================================
|instruction                | definition
| C.MVA01S07 sreg1, sreg2   | mv a0, s[sreg1];  mv a1, s[sreg2]
| C.MVA23S07 sreg1, sreg2   | mv a2, s[sreg1];  mv a3, s[sreg2]
|=======================================================================

[#mvs07_syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.MVAS01S07 | mv(a0,a1),(sreg1,sreg2)| none                               | N/A
|C.MVAS23S07 | mv(a2,a3),(sreg1,sreg2)| none                               | N/A
|======================================================================================================

Assembly examples.
[source,sourceCode,text]
----
# c.mva01s: sreg1 = 0; sreg2 = 0;
mv (a0, a1), (s0, s0) ; # mv a0, s0; mv a1, s0

# c.mva23s: sreg1 = 1; sreg2 = 3;
mv (a2, a3), (s1, s3) ; # mv a2, s1; mv a3, s3
----


=== C.MVP

The generic move uses standard x register numbers, and so it more standard than `C.MVA*S07`, however it takes a lot more encoding space. Both register pairs must be even/odd pairs (`rdp[0]=0, rsp[0]=0`) to reduce the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional as they require 2 register file write ports, or are sequenced.

[#mvp-encoding]
.generic double move 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     3+|101    4+| rdp[4:1] 4+|  rsp[4:1]       2+| 00    | C.MVP
|================================================================================================

[#mvp-semantics]
.generic double move semantics
[width="100%",options=header]
|=======================================================================
|instruction            | definition
| C.MVP rdp, rsp        | mv rdp, rsp;  mv rdp+1, rsp+1
|=======================================================================

[#mvp-syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax          | requirements for 16-bit encoding   | 32-bit extension
|C.MVP       | mv(rdp,rsp),(rdp+1,rsp+1)| none                               | N/A
|======================================================================================================

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

Assembly examples.
[source,sourceCode,text]
----
# c.mvp: sreg1 = 0; sreg2 = 0;
mv (x2, x3), (x18, x19) ; # mv x2, x2; mv x18, x19
----


== `Zcec` definition

=== Table Jump

[[tablejump16]]
==== C.TBLJAL

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here].

The 32-bit encoding is in <<tablejump32>>.

[#tbljal-16encoding]
.C.TBLJAL 16-bit encoding
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1     9+|index9                             2+| 00 | C.TBLJAL
|=============================================================================================

[[tablejump32]]
==== TBLJAL

[NOTE]

  This encoding is provisional.

The 16-bit encoding is in <<tablejump16>> and the specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here].

[zcec-32bit-encodings-table-jump]
.*temporary* TBLJAL 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30|29   |28|27| 26|25   |24  |23|22|21:20      |19:18|17:16|15 | 14:12   | 11:10 |9:7 | 6 : 0 | instruction
9+|000000000                         5+|index13[12:5]                 | 000   2+| index13[4:0]      |1000011| TBLJAL
|=========================================================================================================================

=== C.[SZ]EXT.[BH], C.LSBNOT, C.MUL

These instructions are 16-bit versions of existing 32-bit instructions.

[#dyadic-16encodings]
.simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|Single source/dest with room for 3 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 000     2+| 00  | C.ZEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 001     2+| 00  | C.ZEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 010     2+| 00  | C.ZEXT.W
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 011     2+| 00  | C.SEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 100     2+| 00  | C.SEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 101     2+| 00  | C.SEXT.W
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 110     2+| 00  | C.LSBNOT
3+|  100       | 0  | 0  | 1 3+| xxx      | 0  | 0  3+| 111     2+| 00  | *reserved*
17+|Dyadic with room for 2 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 1  3+| rs2'    2+| 00  | C.MUL
3+|  100       | 0  | 0  | 1 3+| xxx      | 1  | x  3+| xxx     2+| 00  | *reserved*
|=============================================================================================

[#monsemantics]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.ZEXT.B      | rd' = zero_ext(rd'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rd'[15:0])
| C.SEXT.B      | rd' = sign_ext(rd'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rd'[15:0])
| C.LSBNOT      | rd' = rd' XOR 1
| C.MUL         | rd' = rd' * rs2'
2+|RV64/RV128 only
| C.ZEXT.W      | rd' = zero_ext(rd'[31:0])
| C.SEXT.W      | rd' = sign_ext(rd'[31:0])
|=======================================================================

[#mon-32bit]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.ZEXT.B    | zext.b rd             | all registers x8-x15, rd==rs1      | I-extension
|C.ZEXT.H    | zext.h rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.B    | sext.b rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.H    | sext.h rd             | all registers x8-x15, rd==rs1      | B-extension
|C.LSBNOT    | lsbnot rd             | all registers x8-x15, rd==rs1      | I-extension
|C.MUL       | mul    rd, rs1, rs2   | all registers x8-x15, rd==rs1      | I-extension
4+|RV64/RV128 only
|C.ZEXT.W    | zext.w rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.W    | sext.w rd             | all registers x8-x15, rd==rs1      | B-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
zext.b a5;  # a5 = zero_ext(a5[7:0])
zext.h a5;  # a5 = zero_ext(a5[15:0])
sext.b a5;  # a5 = sign_ext(a5[7:0])
sext.h a5;  # a5 = sign_ext(a5[15:0])

lsbnot a5;      # a5 = a5 XOR 1

mul a5, a5, a6; # a5 = a5 * a6

#RV64/RV128 only

zext.w a5; # a5 = zero_ext(a5[31:0])
sext.w a5; # a5 = sign_ext(a5[31:0])

----


=== C.NOT, C.NEG

These instructions are 16-bit versions of existing 32-bit instructions.

[#monadic-16encodings]
.B-extension monadic instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|These are taken from the B-extension draft specification
3+|  011       |0   | 0  | 0 3+| rs1'/rd'  5+| 00000            2+| 01  | C.NOT
3+|  011       |0   | 0  | 1 3+| rs1'/rd'  5+| 00000            2+| 01  | C.NEG
|=============================================================================================

[#monadic-semantics]
.B-extension monadic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.NOT         | rd' = ~rd' / rd' = rd' XOR -1
| C.NEG         | rd' = -rd'
|=======================================================================

[#monadic-32bit]
.B-extension monadic instructions 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.NOT       | not    rd, rs1        | all registers x8-x15, rd==rs1      | I-extension
|C.NEG       | sub    rd, 0, rs2     | all registers x8-x15, rd==rs2      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
not a5          # a5 = ~a5 bitwise inversion
neg a5          # a5 = -a5 two's complement inversion
----


=== C.LBUSP, C.LHUSP, C.SBSP, C.SHSP

[#ldstbhsprel-16encodings]
.load/store half/byte SP relative 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:1，4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:1，4] 2+|11 2+|00 | C.SHSP
|================================================================================================

[#ldstbhsprel-semantics]
.load/store byte/half SP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | Memory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | Memory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh_sprel_32bit]
.load/store byte/half SP relative assembly syntax and 32-bit equivalent instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBUSP     | lbu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.LHUSP     | lhu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SBSP      | sb     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SHSP      | sh     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0])
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0])
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0]   
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0]   
----

=== MULI, MULIADD, ADDIADD

See https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from the B-extension].
Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[this document], which is implemented on silicon.

[zcec-32bit-encodings-arithmetic]
.arithmetic instructions 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26|25   |24  |23|22|21:20      |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
15+| *https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from the B-extension]*
7+|imm[11:0]                                          |00 2+|rs1'   2+| 11100           | rd'       |0011011| MULI
7+|imm[11:0]                                          |10 2+|rs1'   2+| 11100           | rd'       |0011011| MULIW
5+|imm[8:0]                          2+|rs2'          |00 2+|rs1'   2+| 11100           | rd'       |0011111| MULIADD
5+|imm[8:0]                          2+|rs2'          |10 2+|rs1'   2+| 11100           | rd'       |0011111| MULIADDW
5+|imm[8:0]                          2+|rs2'          |00 2+|rs1'   2+| 11101           | rd'       |0011111| ADDIADD
5+|imm[8:0]                          2+|rs2'          |10 2+|rs1'   2+| 11101           | rd'       |0011111| ADDIADDW
|=========================================================================================================================

[#arithmetic_semantics]
.Arithmetic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
|MULI           |rd' = rs1' * sign_ext(imm)
|MULIADD        |rd' = rs1' + rs2' * sign_ext(imm)
|ADDIADD        |rd' = rs1' + rs2' + sign_ext(imm)
2+|RV64/RV128 only
|MULIW          |rd' = sign_ext(rs1'[31:0] * sign_ext(imm))
|MULIADDW       |rd' = sign_ext(rs1'[31:0] + rs2' * sign_ext(imm))
|ADDIADDW       |rd' = sign_ext(rs1'[31:0] + rs2' + sign_ext(imm))
|=======================================================================

=== BEQI, BNEI, BGEUI, BLTUI

These allocate reserved encodings.

The encodings allow a comparison of a register and an immediate value. `BEQI` in particular is very useful for _switch_ statements. 

[NOTE]

  The full set of comparisons would include `BGEI, BLTI` but these are rarely inferred by the compiler, so are not implemented. See https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_condbr_imm_extension.rst[this document], which is implemented on silicon.

[zced-32bit-encodings]
.proposed 32-bit encodings for `Zced`
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26:25  |24   |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
| scmpimm[5:1]       |10      |scmpimm[0]  2+|  offset[9:6]  3+| rs1  | 000   2+| offset[5:1]       |1000011| BEQI
| scmpimm[5:1]       |10      |scmpimm[0]  2+|  offset[9:6]  3+| rs1  | 001   2+| offset[5:1]       |1000011| BNEI
| zcmpimm[5:1]       |10      |zcmpimm[0]  2+|  offset[9:6]  3+| rs1  | 010   2+| offset[5:1]       |1000011| BGEUI
| zcmpimm[5:1]       |10      |zcmpimm[0]  2+|  offset[9:6]  3+| rs1  | 011   2+| offset[5:1]       |1000011| BLTUI
|=========================================================================================================================

[#compare-immediate branch_semantics]
.Compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BEQI          | if (rs1==sign_ext(scmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BNEI          | if (rs1!=sign_ext(scmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BGEUI         | if (rs1>=~u~ zero_ext(zcmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BLTUI         | if (rs1<~u~  zero_ext(zcmpimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

Assembly Examples

[source,sourceCode,text]
----
beq  a5, 1,offset # if(a5== 1) branch_to(PC+offset) # signed comparison
bne  a5,-1,offset # if(a5!=-1) branch_to(PC+offset) # signed comparison
bgeu a5, 1,offset # if(a5>= 1) branch_to(PC+offset) # unsigned comparison
bltu a5, 1,offset # if(a5<  1) branch_to(PC+offset) # unsigned comparison
----

=== DECBGEZ

This reuses uses reserved encoding space adjacent to `BNEI` etc.

The 16-bit encoding and specification is in <<decbr16>>.

[decbgez-32bit-encodings]
.proposed 32-bit encodings for arithmetic instructions
[width="100%",options=header]
|=========================================================================================================================
| 31:27              | 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9:7        | 6 : 0 | instruction
| imm[9:6]           |10     3+|imm[5:0]              |scale 2+| 000  | 100   2+| rd                |1010011| DECBGEZ
|=========================================================================================================================

[#decbgezsemantics32]
.decrement, compare and branch 32-bit semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| DECBGEZ       | rd = rd - (1<<scale); bge rd, zero, sign_ext(imm);
|=======================================================================

Assembly Example
[source,sourceCode,text]
----
decbgez s2, 1, offset ;# s2-=1;if(s2>=0) branch_to(PC+offset)
----

== `Zced` definition

The D-extension takes priority over these encodings.

=== Decrement and branch

[[decbr16]]
==== C.DECBGEZ

This instruction is a combined decrement and branch, used for inferring loops with an optionally scaled loop counter.

[#proposed-16bit-encodings-dec_br]
.proposed 16-bit encodings for dec-and-branch
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  001          3+|uimm[6:4] 3+| rd'  3+|uimm[3:1] 2+|scale 2+| 00 | C.DECBGEZ
|=============================================================================================

[#deccmpbrsemantics]
.decrement, compare and branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.DECBGEZ     | rd' = rd' - (1<<scale); bge rd', zero, -zero_ext(uimm);
|=======================================================================

[#v1.0-32bit]
.32-bit equivalent instructions for decrement, compare and branch semantics
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.DECBGEZ   | decbgez, rd, imm, offset | rd is x8-x15, imm is [1248], offset is in range   | Zce
|======================================================================================================

Assembly Example
[source,sourceCode,text]
----
decbgez s2, 1, offset ;# s2-=1;if(s2>=0) branch_to(PC+offset)
----

=== C.LBU, C.LHU, C.SB, C.SH

The D-extension takes priority over these encodings

[#ldstbh]
.proposed 16-bit encodings for load/store byte/half
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  101       |1 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.LBU
3+|  101       |1 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.LHU
3+|  101       |0 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.SB
3+|  101       |0 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.SH
|=============================================================================================

[#ldstbhsemantics]
.Load/store byte/half semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][15:0])
| C.SB          | rd' = Memory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = Memory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh-32bit]
.Load/store byte-half 32-bit equivalent instructions with a direct equivalent
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBU       | lbu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.LHU       | lhu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SB        | sb     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SH        | sh     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|======================================================================================================

Assembly Examples
[source,sourceCode,text]
----
lbu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[ 7:0])
lhu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[15:0])
sb  a5,20(a4)   # Memory(a4+20)[ 7:0] = a5[ 7:0]
sh  a5,20(a4)   # Memory(a4+20)[15:0] = a5[15:0]
----

=== LWGP, SWGP, LWTP, SWTP

These reuse the encodings for `FLD/FSD`.

`LWGP,SWGP` give a larger offset range than the standard `LW, SW` instructions by making the base register explicitly `gp`, allowing an 18-bit/256KB range of word aligned offsets, instead of a 12-bit/4KB range of byte aligned offsets.

[NOTE]

   Restrictions in the GCC toolchain mean that the full range of `gp` cannot be used for the standard `LW/SW` instructions, in case linker relaxation means that the `gp` relative addresses moves out of range. This will still be the case with `LWGP, SWGP` but the range is so much larger that the impact will be minimal. https://github.com/riscv/riscv-gnu-toolchain/issues/497[See this github issue]. This issue means that with the current RISC-V ISA the full 4KB range cannot be accessed using `gp` using GCC so the benefit is lower than might be expected.

`LWTP,SWTP` give an 18-bit/256KB offset range, which is larger than the standard `LW, SW` instructions by making the base register explicitly `tp`.

[NOTE]

  The intention is to allow the toolchain to use `tp` as a second global pointer, for systems which do not need thread local storage, giving two 256KB address spaces within reach of a single 32-bit load/store word instruction. Any ABI or toolchain implications from allowing this are not covered by this document. `LWTP, SWTP` can also be used to allow a larger range of thread local storage to be accessed with a 32-bit instruction.



[zced-32bit-encodings]
.proposed 32-bit encodings for `LWGP/SWGP/LWTP/SWTP`
[width="100%",options=header]
|=========================================================================================================================
| 31|30|29|28|27     | 26|25   |24  |23|22|21:20      |19:18|17:16|15 | 14:12   | 11:10 |9:7  | 6 : 0 | instruction
 11+|imm[11:2, 17:16]                                2+|imm[15:12]|0   | 011   2+| rd                |0000111| LWGP
  8+|imm[11:5]                3+| rs2                2+|imm[15:12]|0   | 011   2+| imm[4:2, 17:16]   |0100111| SWGP
 11+|imm[11:2, 17:16]                                2+|imm[15:12]|1   | 011   2+| rd                |0000111| LWTP
  8+|imm[11:5]                3+| rs2                2+|imm[15:12]|1   | 011   2+| imm[4:2, 17:16]   |0100111| SWTP
|=========================================================================================================================

[#lwgp_semantics]
.Load/store word GP/TP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| LWGP          | rd=zero_ext(Memory[gp+sign_ext(imm)][31:0]);
| SWGP          | Memory[gp+sign_ext(imm)][31:0])=rs2[31:0];
| LWTP          | rd=zero_ext(Memory[tp+sign_ext(imm)][31:0]);
| SWTP          | Memory[tp+sign_ext(imm)][31:0])=rs2[31:0];
|=======================================================================

Assembly Examples
[source,sourceCode,text]
----
lw s0, 20(gp)
sw s0, 20(gp)
lw s0, 20(tp)
sw s0, 20(tp)
----

== B-extension reuse

Some instructions will be reused from the B-extension. No work has been done on which instructions to choose yet.....


