= RISC-V Zce code-size reduction extension proposal v0.12
Version 0.12
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

This document describes the `Zce` extension to reduce code-size.

== Spec update history

|===================================================================
| version | change
| 0.13    | split LWGP/SWGP into LWGP/SWGP and LWTP/SWTP
| 0.12    | reduce ret_val to 2-bits for POP/POPRET
| 0.11    | Add C.SEXT.W, C.ZEXT.W, MULI, MULIADDW, ADDIADDW, and change the C.[SZ]EXT.* encodings. 
|         | Rename flen PUSH/POP encoding field to fdq to avoid confusion with FLEN.
|===================================================================

== Issues

* there are probably too many instructions listed, so we need to reduce the list
** we don't need `both c.mvp` and also `c.mvas*`
* we need to check the sizes of the immediate fields, so we don't waste encoding space
* `c.mvp` and `c.mvas*` don't have a sensible 32-bit alternative, as no code size would be saved (unless C isn't implemented), so is it ok to convert to a sequence of two 32-bit encodings? If not then we need to allocate pointless 32-bit encodings.
* need to choose a B-extension subset to include

== Zce proposal

Zce is split into subsets. It includes 

* `Zces` sequenced instructions
** 16-bit: `C.POP, C.POPRET, C.PUSH, C.MVA01S07, C.MVA23S07, C.MVP`     
** 32-bit: `POP, POPRET, PUSH, POP.[FDQ], POPRET.[FDQ], PUSH.[FDQ]`
* `Zced` instructions which conflict with the D-extension
** 16-bit: `C.LBU, C.LHU, C.SB, C.SH, C.DECBGEZ`
** 32-bit: `DECBGEZ, LWGP, SWGP, BEQI, BNEI`
* `Zcec` common instructions
** all others

If `Zce` is specified, and `D` is _not_ specified then `Zces_Zced_Zcec` are configured.

If `Zce` is specified, and `D` _is_  specified then `Zces_Zcec` are configured.

If `Zces` is not required then `Zcec` and optionally `Zced` must be specified.

== C-extension subsets

The C-extension already reuses encodings between different architectures. `Zce` extends this concept further. <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>> show how each encoding is allocated for different architectures or for different combinations of extensions.

For example:

* `C.FSD`, `C.SQ`, and `{C.LBU, C.SB}` share opcodes, so for different configurations the encodings represent:
** `C.FSD` for `RV32CD/RV64CD`
** `C.SQ`  for `RV128C`
** `{C.LBU, C.SB}` for `RV32C_Zce, RV64C_Zce`
** illegal encoding for `RV32C, RV64C`, as neither `D` nor `Zce` was specified

The shared encoding column in the tables assigns an arbitrary number to show which encodings are grouped together (I can't find a better way of highlighting groups of cells in the table in adoc format). `Zce` instructions are in *bold*.

[#zce_quad0]
.C-extension quadrant 0
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension
|000       |C.ADDI4SPN| |Zci |✓|✓ |✓  |C

|001       |C.FLD     |1|Zcd |✓|✓ |   |C+D
|001       |C.LQ      |1|Zcq |  |  |✓  |C
|001       |*C.DECBGEZ* |1|*Zced*|✓|✓ |  |C+*Zce*

|010       |C.LW      | |Zci |✓|✓ |✓  |C

|011       |C.FLW     |2|Zcf |✓|   |   |C+F
|011       |C.LD      |2|Zc64/Zc128| |✓|✓|C

|100       |*C.POP*     | |*Zces*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.POPRET*  | |*Zces*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.PUSH*    | |*Zces*|	✓|	✓|	✓|	C+*Zce*

|100       |*C.TBLJAL*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SHSP*    | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SBSP*    | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LHUSP*   | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.LBUSP*   | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.B*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.H*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.SEXT.W*  | |*Zcec*|	 |	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.B*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.H*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.ZEXT.W*  | |*Zcec*|	 |	✓|	✓|	C+*Zce*
|100       |*C.LSBNOT*  | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MUL*     | |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVA01S07*| |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVA23S07*| |*Zcec*|	✓|	✓|	✓|	C+*Zce*
|100       |*C.MVP*	    | |*Zcec*|  ✓|  ✓| 	✓|  C+*Zce*

|101       |C.FSD     |3|Zcd|✓|✓| |C+D
|101       |C.SQ      |3|Zcq| | |✓|D
|101       |*C.SB*      |3|*Zced*|✓|✓| |C+*Zce*
|101       |*C.LBU*     |3|*Zced*|✓|✓ |  |C+*Zce*

|110       |C.SW      | |Zci|✓|✓|✓|C

|111       |C.FSW     |4|Zcf|✓| | |C+F
|111       |C.SD      |4|Zc64/Zc128| |✓|✓|C
|===============================================================================

[#zce_quad1]
.C-extension quadrant 1
[width="100%",options=header]
|===============================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.NOP	| |Zci	|✓	|✓	|✓	|C
|000       |C.ADDI	| |Zci	|✓	|✓	|✓	|C


|001       |C.JAL	        |5|Zc32	        |✓	|	|	|C
|001       |C.ADDIW (rd=0:RSV)  |5|Zc64/Zc128	|	|✓	|✓	|C

|010       |C.LI (rd=0:HINT) | |Zci	|✓	|✓	|✓	|C


|011       |C.ADDI16SP (nzimm=0:RSV)	| | Zci	|✓	|✓	|✓	|C
|011       |C.LUI (nzimm=0: RSV; rd=0:HINT)	| |Zci	|✓	|✓	|✓	|C


|100       |C.SRLI (RV32:NSE, nzuimm[5]=1)        |6|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRLI64 (RV32:HINT)                  |6|Zc128	|	|	|✓	|C
|100       |C.SRAI (RV32:NSE, nzuimm[5]=1)        |7|Zc32/Zc64	|✓	|✓	|	|C
|100       |C.SRAI64 (RV32/64:HINT)               |7|Zc128	|	|	|✓       |C
|100       |C.ANDI                                | |Zci	|✓	|✓	|✓	|C
|100       |C.SUB                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.XOR                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.OR                                  | |Zci	|✓	|✓	|✓	|C
|100       |C.AND                                 | |Zci	|✓	|✓	|✓	|C
|100       |C.SUBW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C
|100       |C.ADDW (RV32:RSV)                     | |Zc64/Zc128	|	|✓	|✓	|C

|101       |C.J	       | |Zci	|✓	|✓	|✓	|C


|110       |C.BEQZ	| |Zci	|✓	|✓	|✓	|C


|111       |C.BNEZ	| |Zci	|✓	|✓	|✓	|C
|===============================================================================

[#zce_quad2]
.C-extension quadrant 2
[width="100%",options=header]
|======================================================================================================
|Enc[15:13]|Instruction|shared encoding group|Ext Subset|RV32|RV64|RV128|Extension

|000       |C.SLLI (rd=0:HINT; RV32 && nzuimm[5]=1:NSE)| 8|Zc32/Zc64	|✓	|✓	|	|C
|000       |C.SLLI64 (RV32/64 or rd=0:HINT)	       | 8|Zc128	        |	|	|✓	|C
|001       |C.FLDSP	                               | 9|Zcd	        |✓	|✓	|	|C+D
|001       |C.LQSP (rd=0:RSV)	                     | 9|Zc128	        |	|	|✓	|C
|001       |*unallocated*	                         | 9|*Zced* 	|✓	|✓	| 	|C+*Zce*
|010       |C.LWSP (rd=0:RSV)	                     |  |Zci	        |✓	|✓	|✓	|C
|011       |C.FLWSP	                               |10|Zcf	        |✓	|	|	|C+F
|011       |C.LDSP (rd=0:HINT)	                   |10|Zc64/Zc128	|	|✓	|✓	|C
|100       |C.JR     (rd=0:RSV)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.MV   (rd=0:HINT)	                   |  |Zci   	|✓	|✓	|✓	|C
|100       |C.EBREAK	                             |  |Zci   	|✓	|✓	|✓	|C
|100       |C.JALR	                               |  |Zci   	|✓	|✓	|✓	|C
|100       |C.ADD (rd=0:HINT)	                     |  |Zci   	|✓	|✓	|✓	|C
|101       |C.FSDSP	                               |11|Zcd	        |✓	|✓	|	|C+D
|101       |C.SQSP	                               |11|Zc128		|       | 	|✓	|C
|101       |*C.SH*	                               |11|*Zced**	|✓	|✓	| 	|C+*Zce*
|101       |*C.LHU*	                               |11|*Zced* 	|✓	|✓	| 	|C+*Zce*
|110       |C.SWSP	                               |  |Zci	        |✓	|✓	|✓	|C
|111       |C.FSWSP	                               |12|Zcf	        |✓	|	|	|C+F
|111       |C.SDSP	                               |12|Zc128	        |	|✓	|✓	|C
|======================================================================================================

== Allocation of new 16-bit encodings

This section gives a short-hand lookup of exactly where the new encodings are allocated to make it easier to review the encoding space. The first column is the group number from <<zce_quad0>>, <<zce_quad1>> and <<zce_quad2>>.

|======================================
|Group|[15:13]|[12:10]|[1:0]|Instruction

| |100    |000    |00   |C.POP, C.POPRET, C.PUSH
| |100    |001    |00   |C.[SZ]EXT.[BH], C.LSBNOT, C.MUL
| |100    |01x    |00   |C.L[BH]USP, C.S[BH]SP
| |100    |100    |00   |C.MVA01S07, C.MVA23S07
| |100    |101    |00   |C.MVP
| |100    |11x    |00   |C.TBLJAL

|1|001    |xxx    |00   |C.DECBGEZ

|3|101    |0xx    |00   |C.SB
|3|101    |1xx    |00   |C.LBU

| |011    |000    |00   |C.NOT
| |011    |001    |00   |C.NEG


|11|101   |0xx    |10   |C.SH
|11|101   |1xx    |10   |C.LHU
|======================================


=== Spare 16-bit encodings

Some spare encodings are noted in the tables below. The remaining unallocated space is listed here:

[#spare encodings]
.spare 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  011       |0   |1  4+|xxxx         5+|00000              2+|01     | *reserved*
17+|These three are RV32 only
3+|  000       |1 10+|  xxxxx                                 2+|10     | *reserved*
3+|  100       |1   |0  9+| xxxx                              2+|01     | *reserved*
3+|  100       |1 2+|11 8+| xxxx                              2+|00     | *reserved*
17+|This conflicts with the D-extension
3+|  001     11+|xxxx                                         2+|10     | *reserved*
|================================================================================================

== `Zces` definition

`Zces` is optional as cores may not want to build the sequencer to issue the instructions.

=== PUSH/POP
[[pushpop16]]
==== C.PUSH, C.POP, C.POPRET

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here].

[NOTE]

  The reserved 16-bit encodings could be used for EABI versions in the future.

[#proposed-16bit-encodings-1]
.PUSH/POP 16-bit encodings
[width="100%",options=header]
|===============================================================================
|15 |14 |13 |12 |11 |10  |9 |8  |7 |6   |5 |4 |3 |2           |1 |0 |instruction
17+|`C.POP` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0  |0 2+|rcount[1:0]|0 |0 2+|00 | spimm[0] 2+| 00  |C.POP
3+|100  |0  |0  |0  |1 2+|xx         |0 |0 3+|xxx           2+| 00  |*reserved*
3+|100  |0  |0  |0 3+|xxx            |0 |0 2+|!=00| x       2+| 00  |*reserved*
17+|`C.POPRET` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0 3+|rcount[2:0]  |ret0|1 3+|spimm[2:0]    2+| 00  |C.POPRET
3+|100  |0  |0  |0   |1 2+|xxx        |x|1 |1 2+|xx         2+| 00  |*reserved*
17+|`C.PUSH` and reserved values of rcount/spimm to save encoding space
3+|100  |0  |0  |0 3+|rcount[2:0]  |1 |0 3+|spimm[2:0]      2+| 00  |C.PUSH
3+|100  |0  |0  |0   |1 2+|xx      |1 |0   |1 2+|xx         2+| 00  |*reserved*
|===============================================================================

  * For `C.POPRET`, `ret_val[0]=ret0` as specified in the encoding, `ret_val[1]=0`. 
  * For `C.POP` `ret_val[1:0]=0`.
  * Some encodings remain *reserved* for the time being so we can add them later if they can be justified
  ** For `C.POP`, `rcount[2]=1` is reserved
  ** For `C.POP`, `spimm > 1` is reserved
  ** For `C.PUSH/C.POPRET`, `rcount[2]=1 && spimm[2]=1` is reserved

[#pushpop_semantics]
.PUSH/POP semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.POP         | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers]
| C.POPRET      | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[POP registers and return]
| C.PUSH        | https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[PUSH registers]
|=======================================================================

[#pushpop-32bit]
.PUSH/POP assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.POP       | pop    <args>         | <args> map to a 16-bit encoding | Zce
|C.POPRET    | popret <args>         | <args> map to a 16-bit encoding | Zce
|C.PUSH      | push   <args>         | <args> map to a 16-bit encoding | Zce
|======================================================================================================

Assembly examples are https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc#assembly-examples[here].

[[pushpop32]]
==== PUSH, POP, POPRET, PUSH.[FDQ], POP.[FDQ], POPRET.[FDQ]

[NOTE]

  These encodings are in custom-0, as no official encodings have been allocated yet


.push/pop 32-bit encodings
[options="header",width="100%"]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
18+|`PUSH` encodings
4+|00000                     2+|00   2+|mv          2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH
4+|00000                     2+|01   2+|frcount     2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH.F
4+|00000                     2+|10   2+|frcount     2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH.D
4+|00000                     2+|11   2+|frcount     2+|rcount     |ra | 001   4+| spimm             |0001011| PUSH.Q
18+|`POP` encodings
4+|00000                     2+|00   |0|ret_val     2+|rcount     |ra | 010   4+| spimm             |0001011| POP
4+|00000                     2+|01   2+|frcount     2+|rcount     |ra | 010   4+| spimm             |0001011| POP.F
4+|00000                     2+|10   2+|frcount     2+|rcount     |ra | 010   4+| spimm             |0001011| POP.D
4+|00000                     2+|11   2+|frcount     2+|rcount     |ra | 010   4+| spimm             |0001011| POP.Q
18+|`POPRET` encodings
4+|00000                     2+|00   |0|ret_val     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET
4+|00000                     2+|01   2+|frcount     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET.F
4+|00000                     2+|10   2+|frcount     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET.D
4+|00000                     2+|11   2+|frcount     2+|rcount     |1  | 011   4+| spimm             |0001011| POPRET.Q
|=========================================================================================================================

[NOTE]
  bits [26:25] are the `fdq` field
  `ra=1` for all `popret` encodings, it is not specified in the encoding

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/riscv_push_pop_extension_RV32_RV64_UABI.adoc[here] and the 16-bit encoding is in <<pushpop16>>.


=== C.MVA01S07, C.MVA23S07

Register moves are the most common in GCC output in both the benchmark suite and the Debian distro. These two instructions combine two very common pairs of moves into single 16-bit encodings:

* move from two `s[0-7]` registers into `a0` and `a1`.
* move from two `s[0-7]` registers into `a2` and `a3`.

[NOTE]

  The syntax takes ABI names not `x` register names, so it is unusual. However this allows much more frequent usage without increasing the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional (`Zces`) as they require 2 register file write ports, or are sequenced.

[#proposed-16bit-encodings-4]
.`C.MV01S07, C.MV23S07` 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     2+|10     3+| 000      3+|sreg1      3+|sreg2    2+| 00    | C.MVA01S07
3+|  100     2+|10     3+| 001      3+|sreg1      3+|sreg2    2+| 00    | C.MVA23S07
|================================================================================================

[#mvs07_semantics]
.`C.MV01S07, C.MV23S07` semantics
[width="100%",options=header]
|=======================================================================
|instruction                | definition
| C.MVA01S07 sreg1, sreg2   | mv a0, s[sreg1];  mv a1, s[sreg2]
| C.MVA23S07 sreg1, sreg2   | mv a2, s[sreg1];  mv a3, s[sreg2]
|=======================================================================

[#mvs07_syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.MVAS01S07 | mv(a0,a1),(sreg1,sreg2)| none                               | N/A
|C.MVAS23S07 | mv(a2,a3),(sreg1,sreg2)| none                               | N/A
|======================================================================================================

Assembly examples.
[source,sourceCode,text]
----
# c.mva01s: sreg1 = 0; sreg2 = 0;
mv (a0, a1), (s0, s0) ; # mv a0, s0; mv a1, s0

# c.mva23s: sreg1 = 1; sreg2 = 3;
mv (a2, a3), (s1, s3) ; # mv a2, s1; mv a3, s3
----


=== C.MVP

The generic move uses standard x register numbers, and so it more standard than `C.MVA*S07`, however it takes a lot more encoding space. Both register pairs must be even/odd pairs (`rdp[0]=0, rsp[0]=0`) to reduce the encoding space requirement.

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

[NOTE]

  These are optional as they require 2 register file write ports, or are sequenced.

[#mvp-encoding]
.generic double move 16-bit encoding
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100     3+|101    4+| rdp[4:1] 4+|  rsp[4:1]       2+| 00    | C.MVP
|================================================================================================

[#mvp-semantics]
.generic double move semantics
[width="100%",options=header]
|=======================================================================
|instruction            | definition
| C.MVP rdp, rsp        | mv rdp, rsp;  mv rdp+1, rsp+1
|=======================================================================

[#mvp-syntax]
.`C.MV01S07, C.MV23S07` assembly syntax
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax          | requirements for 16-bit encoding   | 32-bit extension
|C.MVP       | mv(rdp,rsp),(rdp+1,rsp+1)| none                               | N/A
|======================================================================================================

[NOTE]

  Currently there are no 32-bit equivalent instructions, is it enough to expand to *two* 32-bit instructions?

Assembly examples.
[source,sourceCode,text]
----
# c.mvp: sreg1 = 0; sreg2 = 0;
mv (x2, x3), (x18, x19) ; # mv x2, x2; mv x18, x19
----


== `Zcec` definition

=== Table Jump

[[tablejump16]]
==== C.TBLJAL

The specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here].

The 32-bit encoding is in <<tablejump32>>.

[#tbljal-16encoding]
.C.TBLJAL 16-bit encoding
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  100       | 1  | 1     9+|index9                             2+| 00 | C.TBLJAL
|=============================================================================================

[[tablejump32]]
==== TBLJAL

[NOTE]

  This encoding is in custom-0, as no official encoding has been allocated yet

The 16-bit encoding is in <<tablejump16>> and the specification is https://github.com/riscv/riscv-code-size-reduction/blob/master/ISA%20proposals/Huawei/table%20jump.adoc[here].

[zcec-32bit-encodings-table-jump]
.*temporary* TBLJAL 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
8+|00000                             4+|index13[12:5]                 | 000   4+| index13[4:0]      |0001011| TBLJAL
|=========================================================================================================================

=== C.[SZ]EXT.[BH], C.LSBNOT, C.MUL

These instructions are 16-bit versions of existing 32-bit instructions.

[#dyadic-16encodings]
.simple instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|Single source/dest with room for 3 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 000     2+| 00  | C.ZEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 001     2+| 00  | C.ZEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 010     2+| 00  | C.ZEXT.W
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 011     2+| 00  | C.SEXT.B
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 100     2+| 00  | C.SEXT.H
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 101     2+| 00  | C.SEXT.W
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 0  3+| 110     2+| 00  | C.LSBNOT
3+|  100       | 0  | 0  | 1 3+| xxx      | 0  | 0  3+| 111     2+| 00  | *reserved*
17+|Dyadic with room for 2 more encodings
3+|  100       | 0  | 0  | 1 3+| rs1'/rd' | 0  | 1  3+| rs2'    2+| 00  | C.MUL
3+|  100       | 0  | 0  | 1 3+| xxx      | 1  | x  3+| xxx     2+| 00  | *reserved*
|=============================================================================================

[#monsemantics]
.simple instruction semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.ZEXT.B      | rd' = zero_ext(rd'[ 7:0])
| C.ZEXT.H      | rd' = zero_ext(rd'[15:0])
| C.SEXT.B      | rd' = sign_ext(rd'[ 7:0])
| C.SEXT.H      | rd' = sign_ext(rd'[15:0])
| C.LSBNOT      | rd' = rd' XOR 1
| C.MUL         | rd' = rd' * rs2'
2+|RV64/RV128 only
| C.ZEXT.W      | rd' = zero_ext(rd'[31:0])
| C.SEXT.W      | rd' = sign_ext(rd'[31:0])
|=======================================================================

[#mon-32bit]
.simple instruction 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.ZEXT.B    | zext.b rd             | all registers x8-x15, rd==rs1      | I-extension
|C.ZEXT.H    | zext.h rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.B    | sext.b rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.H    | sext.h rd             | all registers x8-x15, rd==rs1      | B-extension
|C.LSBNOT    | lsbnot rd             | all registers x8-x15, rd==rs1      | I-extension
|C.MUL       | mul    rd, rs1, rs2   | all registers x8-x15, rd==rs1      | I-extension
4+|RV64/RV128 only
|C.ZEXT.W    | zext.w rd             | all registers x8-x15, rd==rs1      | B-extension
|C.SEXT.W    | sext.w rd             | all registers x8-x15, rd==rs1      | B-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
zext.b a5;  # a5 = zero_ext(a5[7:0])
zext.h a5;  # a5 = zero_ext(a5[15:0])
sext.b a5;  # a5 = sign_ext(a5[7:0])
sext.h a5;  # a5 = sign_ext(a5[15:0])

lsbnot a5;      # a5 = a5 XOR 1

mul a5, a5, a6; # a5 = a5 * a6

#RV64/RV128 only

zext.w a5; # a5 = zero_ext(a5[31:0])
sext.w a5; # a5 = sign_ext(a5[31:0])

----


=== C.NOT, C.NEG

These instructions are 16-bit versions of existing 32-bit instructions.

[#monadic-16encodings]
.B-extension monadic instructions 16-bit encodings
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|These are taken from the B-extension draft specification
3+|  011       |0   | 0  | 0 3+| rs1'/rd'  5+| 00000            2+| 01  | C.NOT
3+|  011       |0   | 0  | 1 3+| rs1'/rd'  5+| 00000            2+| 01  | C.NEG
|=============================================================================================

[#monadic-semantics]
.B-extension monadic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.NOT         | rd' = ~rd' / rd' = rd' XOR -1
| C.NEG         | rd' = -rd'
|=======================================================================

[#monadic-32bit]
.B-extension monadic instructions 32-bit equivalent instructions/pseudo-instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.NOT       | not    rd, rs1        | all registers x8-x15, rd==rs1      | I-extension
|C.NEG       | sub    rd, 0, rs2     | all registers x8-x15, rd==rs2      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
not a5          # a5 = ~a5 bitwise inversion
neg a5          # a5 = -a5 two's complement inversion
----


=== C.LBUSP, C.LHUSP, C.SBSP, C.SHSP

[#ldstbhsprel-16encodings]
.load/store half/byte SP relative 16-bit encodings
[width="100%",options=header]
|================================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
17+|source/dest with one other source operand, stack pointer relative
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:0]    2+|00 2+|00 | C.LBUSP
3+|  100       | 0  | 1  |uimm[3] 3+|     rd' 3+|uimm[2:1，4] 2+|01 2+|00 | C.LHUSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:0]    2+|10 2+|00 | C.SBSP
3+|  100       | 0  | 1  |uimm[3] 3+|    rs2' 3+|uimm[2:1，4] 2+|11 2+|00 | C.SHSP
|================================================================================================

[#ldstbhsprel-semantics]
.load/store byte/half SP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][ 7:0])
| C.LHUSP       | rd' = zero_ext(Memory[sp + zero_ext(uimm)][15:0])
| C.SBSP        | Memory[sp + zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SHSP        | Memory[sp + zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh_sprel_32bit]
.load/store byte/half SP relative assembly syntax and 32-bit equivalent instructions
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBUSP     | lbu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.LHUSP     | lhu    rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SBSP      | sb     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|C.SHSP      | sh     rd, imm(sp)    | rd is x8-x15, imm is in range      | I-extension
|======================================================================================================

Assembly Examples

[source,sourceCode,text]
----
lbu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[ 7:0])
lhu a5,20(sp)   # a5 = zero_ext(Memory(sp+20)[15:0])
sb  a5,20(sp)   # Memory(sp+20)[ 7:0] = a5[ 7:0]   
sh  a5,20(sp)   # Memory(sp+20)[15:0] = a5[15:0]   
----

== `Zced` definition

The D-extension takes priority over these encodings.

=== Decrement and branch

[[decbr16]]
==== C.DECBGEZ

This instruction is a combined decrement and branch, used for inferring loops with an optionally scaled loop counter.

[#proposed-16bit-encodings-dec_br]
.proposed 16-bit encodings for dec-and-branch
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  001          3+|uimm[6:4] 3+| rd'  3+|uimm[3:1] 2+|scale 2+| 00 | C.DECBGEZ
|=============================================================================================

[#deccmpbrsemantics]
.decrement, compare and branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.DECBGEZ     | rd' = rd' - (1<<scale); bge rd', zero, -zero_ext(uimm);
|=======================================================================

[#v1.0-32bit]
.32-bit equivalent instructions for decrement, compare and branch semantics
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax        | requirements for 16-bit encoding   | 32-bit extension
|C.DECBGEZ   | decbgez, rd, imm, offset | rd is x8-x15, imm is [1248], offset is in range   | Zce
|======================================================================================================

==== DECBGEZ

This reuses the encoding for `FDIV.D`.

The 16-bit encoding and specification is in <<decbr16>>.

[decbgez-32bit-encodings]
.proposed 32-bit encodings for arithmetic instructions
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
5+|0001101                   6+|imm[9:0]                              |scale  4+| rd                |1010011| DECBGEZ
|=========================================================================================================================

[#decbgezsemantics32]
.decrement, compare and branch 32-bit semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| DECBGEZ       | rd = rd - (1<<scale); bge rd, zero, sign_ext(imm);
|=======================================================================


=== C.LBU, C.LHU, C.SB, C.SH

The D-extension takes priority over these encodings

[#ldstbh]
.proposed 16-bit encodings for load/store byte/half
[width="100%",options=header]
|=============================================================================================
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         
3+|  101       |1 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.LBU
3+|  101       |1 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.LHU
3+|  101       |0 2+|uimm[0,3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 00 | C.SB
3+|  101       |0 2+|uimm[4:3] 3+| rs1' 2+|uimm[2:1] 3+|rs2'  2+| 10 | C.SH
|=============================================================================================

[#ldstbhsemantics]
.Load/store byte/half semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| C.LBU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][ 7:0])
| C.LHU         | rd' = zero_ext(Memory[rs1'+zero_ext(uimm)][15:0])
| C.SB          | rd' = Memory[rs1'+zero_ext(uimm)][ 7:0] = rs2'[ 7:0]
| C.SH          | rd' = Memory[rs1'+zero_ext(uimm)][15:0] = rs2'[15:0]
|=======================================================================

[#ldstbh-32bit]
.Load/store byte-half 32-bit equivalent instructions with a direct equivalent
[width="100%",options=header]
|======================================================================================================
|instruction | assembly syntax       | requirements for 16-bit encoding   | 32-bit extension
|C.LBU       | lbu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.LHU       | lhu    rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SB        | sb     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|C.SH        | sh     rd, imm(rs1)   | all regs x8-x15, imm in range      | I-extension
|======================================================================================================

[source,sourceCode,text]
----
lbu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[ 7:0])
lhu a5,20(a4)   # a5 = zero_ext(Memory(a4+20)[15:0])
sb  a5,20(a4)   # Memory(a4+20)[ 7:0] = a5[ 7:0]
sh  a5,20(a4)   # Memory(a4+20)[15:0] = a5[15:0]
----

=== MULI, MULIADD, ADDIADD

See https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from the B-extension].
Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_muladd_extension.rst[this document], which is implemented on silicon.

[zcec-32bit-encodings-arithmetic]
.arithmetic instructions 32-bit encodings
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
18+| *https://github.com/clairexen/riscv-fanfic/blob/master/riscv-rcfmt/riscv-rcfmt.md[Clare's proposal from the B-extension]*
8+|imm[11:0]                                          |00 2+|rs1'   2+| 11100         3+| rd'       |0011011| MULI
8+|imm[11:0]                                          |10 2+|rs1'   2+| 11100         3+| rd'       |0011011| MULIW
7+|imm[8:0]                            |rs2'          |00 2+|rs1'   2+| 11100         3+| rd'       |0011111| MULIADD
7+|imm[8:0]                            |rs2'          |10 2+|rs1'   2+| 11100         3+| rd'       |0011111| MULIADDW
7+|imm[8:0]                            |rs2'          |00 2+|rs1'   2+| 11101         3+| rd'       |0011111| ADDIADD
7+|imm[8:0]                            |rs2'          |10 2+|rs1'   2+| 11101         3+| rd'       |0011111| ADDIADDW
|=========================================================================================================================

[#arithmetic_semantics]
.Arithmetic semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
|MULI           |rd' = rs1' * sign_ext(imm)
|MULIADD        |rd' = rs1' + rs2' * sign_ext(imm)
|ADDIADD        |rd' = rs1' + rs2' + sign_ext(imm)
2+|RV64/RV128 only
|MULIW          |rd' = sign_ext(rs1'[31:0] * sign_ext(imm))
|MULIADDW       |rd' = sign_ext(rs1'[31:0] + rs2' * sign_ext(imm))
|ADDIADDW       |rd' = sign_ext(rs1'[31:0] + rs2' + sign_ext(imm))
|=======================================================================

=== BEQI, BNEI

These reuse the encodings for `FMADD.D/FMSUB.D`.

The encodings allow a comparison of a register and an immediate value. `BEQI` in particular is very useful for _switch_ statements. 

Also see https://github.com/riscv/riscv-code-size-reduction/blob/master/existing_extensions/Huawei%20Custom%20Extension/riscv_condbr_imm_extension.rst[this document], which is implemented on silicon.

[zced-32bit-encodings]
.proposed 32-bit encodings for `Zced`
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
6+| cmpimm[7:0]                   2+|  offset[9:6]  3+| rs1           | 001   4+| offset[5:1]       |1000011| BEQI
6+| cmpimm[7:0]                   2+|  offset[9:6]  3+| rs1           | 010   4+| offset[5:1]       |1000111| BNEI
|=========================================================================================================================

[#compare-immediate branch_semantics]
.Compare immediate branch semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| BEQI          | if (rs1==sign_ext(cmpimm)) target_pc=PC+offset; else target_pc=PC+4;
| BNEI          | if (rs1!=sign_ext(cmpimm)) target_pc=PC+offset; else target_pc=PC+4;
|=======================================================================

=== LWGP, SWGP, LWTP, SWTP

These reuse the encodings for `FLD/FSD`.

`LWGP,SWGP` give a larger offset range than the standard `LW, SW` instructions by making the base register explicitly `gp`, allowing an 18-bit/256KB range of word aligned offsets, instead of a 12-bit/4KB range of byte aligned offsets.

[NOTE]

   Restrictions in the GCC toolchain mean that the full range of `gp` cannot be used for the standard `LW/SW` instructions, in case linker relaxation means that the `gp` relative addresses moves out of range. This will still be the case with `LWGP, SWGP` but the range is so much larger that the impact will be minimal. https://github.com/riscv/riscv-gnu-toolchain/issues/497[See this github issue]. This issue means that with the current RISC-V ISA the full 4KB range cannot be accessed using `gp` using GCC so the benefit is lower than might be expected.

`LWTP,SWTP` give an 18-bit/256KB offset range, which is larger than the standard `LW, SW` instructions by making the base register explicitly `tp`.

[NOTE]

  The intention is to allow the toolchain to use `tp` as a second global pointer, for systems which do not need thread local storage, giving two 256KB address spaces within reach of a single 32-bit load/store word instruction. Any ABI or toolchain implications from allowing this are not covered by this document. `LWTP, SWTP` can also be used to allow a larger range of thread local storage to be accessed with a 32-bit instruction.



[zced-32bit-encodings]
.proposed 32-bit encodings for `LWGP/SWGP/LWTP/SWTP`
[width="100%",options=header]
|=========================================================================================================================
| 31 | 30:29   |28|27| 26:25   |24  |23|22:20         |19:18|17:16|15 | 14:12   | 11:10 |9  | 8 | 7 | 6 : 0 | instruction
 8+|imm[11:2, 17:16]                                2+|imm[15:12]|0   | 011   4+| rd                |0000111| LWGP
 5+|imm[11:5]                3+| rs2                2+|imm[15:12]|0   | 011   4+| imm[4:2, 17:16]   |0100111| SWGP
 8+|imm[11:2, 17:16]                                2+|imm[15:12]|1   | 011   4+| rd                |0000111| LWTP
 5+|imm[11:5]                3+| rs2                2+|imm[15:12]|1   | 011   4+| imm[4:2, 17:16]   |0100111| SWTP
|=========================================================================================================================

[#lwgp_semantics]
.Load/store word GP/TP relative semantics
[width="100%",options=header]
|=======================================================================
|instruction    | definition
| LWGP          | rd=zero_ext(Memory[gp+sign_ext(imm)][31:0]);
| SWGP          | Memory[gp+sign_ext(imm)][31:0])=rs2[31:0];
| LWTP          | rd=zero_ext(Memory[tp+sign_ext(imm)][31:0]);
| SWTP          | Memory[tp+sign_ext(imm)][31:0])=rs2[31:0];
|=======================================================================


== B-extension reuse

Some instructions will be reused from the B-extension. No work has been done on which instructions to choose yet.....


