*************************
RISC-V Push/Pop Extension
*************************

This document describes 32-bit and 16-bit encodings for ``[C.]PUSH[.E]``, ``[C.]POP[.E]`` and ``[C.]POPRET[.E]`` instructions for RV32 and RV64, architectures, I and E variants.

Rationale
=========

``[C.]PUSH[.E]/[C.]POP[.E]/[C.]POPRET[.E]`` are designed to replace the most commonly called functions generated by the compiler using *–m-save-restore*. 
When the *–msave-restore* option is used the compiler replaces the sequence of stores plus ``sp`` decrement operation required 
to spill/push registers to the stack with a call to a shared co-routine that performs this operation. In addition the equivalent 
fill/pop sequence is replaced with a jump to a shared co-routine (which then performs the return to the caller of the function). 
The code savings can be significant (provided that the co-routine jump/calls can be encoded in a single 32-bit instruction) but 
the run-time overhead is high as an additional 3 jumps are required for each push/pop sequence; in addition the shared save/restore 
routines include redundant memory operations when the number of registers to spill is not a multiple of 4.

The most useful forms of these instructions are the 16-bit encodings, as these give the largest code size reduction, whilst covering the vast 
majority of useful cases.

16-bit encodings
================

``C.PUSH[.E]`` instruction 
--------------------------

``C.PUSH[.E]`` which allows most spill sequences to only take 16-bits of code space instead of 32-bits for the call to the save routine (or in some cases 
64-bits if the target function is too far away).

``C.POP[.E]`` instruction
-------------------------

``C.POP[.E]`` which allows most fill sequences to be performed with two 16-bit instructions (``C.POP+RET`` ) which matches the cost of the co-routine jump 
(for jumps <1Mbyte) but with significantly better performance.

``C.POPRET[.E]`` instructions
-----------------------------

``C.POPRET[.E]`` which allows both the ``C.POP[.E]`` and ``RET`` to be performed in a single instruction saving 16-bits of code with respect to a 
``C.POP[.E]+RET`` or a jump to a restore co-routine.  

Opcode Assignment
-----------------

.. _pushpop16_encoding:
.. table:: ``C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]`` 16-bit instruction encoding

  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6  | 5  | 4 | 3 | 2 | 1 | 0 |instruction         |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  | *These replace reserved encodings, PUSH/POP with support for UABI and EABI*                |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  |  100         |  1 |  0 |  rcount        | 0  | 0  |    spimm  | 00    | C.POP              |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  |  100         |  1 |  0 |  rcount        | 0  | 1  |    spimm  | 00    | C.POPRET           |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  |  100         |  1 |  0 |  rcount        | 1  | 0  |    spimm  | 00    | C.PUSH             |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  |  100         |  1 |  1 |  rcount        | 0  | 0  |    spimm  | 00    | C.POP.E            |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  |  100         |  1 |  1 |  rcount        | 0  | 1  |    spimm  | 00    | C.POPRET.E         |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+
  |  100         |  1 |  1 |  rcount        | 1  | 0  |    spimm  | 00    | C.PUSH.E           |
  +----+----+----+----+----+----+---+---+---+----+----+---+---+---+---+---+--------------------+

:ref:`pushpop16_encoding`

Notes

 - [11] is ``eabi`` which distinguishes between the ``C.POP`` (UABI) and ``C.POP.E`` (EABI) versions
 - [15:13] and [1:0] identify the encoding within the 16-bit encoding space.
 - The ``spimm`` field  is an unsigned immediate that indicates the number of additional *n*-byte blocks to adjust the stack 
   pointer by. See :ref:`spimm` and :ref:`regcount_table1` 
 - RV32I, RV64I can use either ABI (UABI or EABI), but it is optional to implement the ``.E`` variants
 - RV32E UABI, RV64E UABI are not supported configurations, these should only use the ``.E`` variants
 - RV64E is not currently in the RISC-V standard, but may be included in the future so it is fully included in this specification
 - For UABI documentation see Chapter 20 of `The RISC-V ISA specification <http://riscv.org/specifications/isa-spec-pdf>`_ 
 - For the EABI, see this `proposal <https://github.com/riscv/riscv-eabi-spec/blob/master/EABI.adoc>`_

.. _spimm:
.. table:: how to calculate *spimm* from the total stack adjustment and the number of register "holes" to skip to achieve the stack alignment

  ============= ========= ======================================== ============================
  arch+ABI      spimm *n* total stack adjustment for *r* registers register holes to skip
  ============= ========= ======================================== ============================
  RV32[IE] EABI 8         adjust =  8*((r+1)/2+spimm)              holes = r mod 2
  RV32I UABI    16        adjust = 16*((r+3)/4+spimm)              holes = 3-((r+3) mod 4)
  RV64I UABI    16        adjust = 16*((r+1)/2+spimm)              holes = r mod 2
  RV64[IE] EABI 16        adjust = 16*((r+1)/2+spimm)              holes = r mod 2
  ============= ========= ======================================== ============================
  
The purpose of ``spimm`` is to allow a function to allocate additional space on the stack for automatic variables without having to perform 
an additional stack adjustment (and therefore save more code size).



The encodings contain no explicit register index fields as the memory accesses and pointer increments are all based on the stack pointer register as 
defined in the standard RISC-V ABIs ``sp`` and the registers to be loaded/stored are specified using the ``rcount`` field (see :ref:`regcount_table1`)

The behaviour of each value of ``rcount``, ``eabi`` and ``spimm`` is shown in :ref:`regcount_table1`. 

.. _regcount_table1:
.. table:: Register count mapping for ``C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]``

  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |eabi|rcount| ABI names            | Register numbers         |Stack pointer adjustment       |reg holes to skip          |
  +    +      +                      +                          +                               +                           +
  |    |      |                      |                          |x=spimm -for PUSH, +for POP    |                           |
  +    +      +                      +                          +-------+-------+-------+-------+-----+-----+-----+---------+
  |    |      |                      |                          |RV32I  |RV64I  |RV32E  |RV64E  |RV32I|RV64I|RV32E|RV64E    |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  | *UABI only, may give the wrong result if the EABI is in use*                                                            |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |0   |0     |ra                    |x1                        |16(1+x)|16(1+x)|*reserved,*    | 3   | 1   |*reserved,*    |
  +----+------+----------------------+--------------------------+       +       +*illegal*      +-----+-----+*illegal*      +
  |0   |1     |ra, s0                |x1, x8                    |       |       |*instruction*  | 2   | 0   |*instruction*  |
  +----+------+----------------------+--------------------------+       +-------+*exception*    +-----+-----+*exception*    +
  |0   |2     |ra, s0-s1             |x1, x8-x9                 |       |16(2+x)|               | 1   | 1   |               |
  +----+------+----------------------+--------------------------+       +       +               +-----+-----+               +
  |0   |3     |ra, s0-s2             |x1, x8-x9, x18            |       |       |               | 0   | 0   |               |
  +----+------+----------------------+--------------------------+-------+-------+               +-----+-----+               +
  |0   |4     |ra, s0-s3             |x1, x8-x9, x18-x19        |16(2+x)|16(3+x)|               | 3   | 1   |               |
  +----+------+----------------------+--------------------------+       +       +               +-----+-----+               +
  |0   |5     |ra, s0-s4             |x1, x8-x9, x18-x20        |       |       |               | 2   | 0   |               |
  +----+------+----------------------+--------------------------+       +-------+               +-----+-----+               +
  |0   |6     |ra, s0-s5             |x1, x8-x9, x18-x21        |       |16(4+x)|               | 1   | 1   |               |
  +----+------+----------------------+--------------------------+       +       +               +-----+-----+               +
  |0   |7     |ra, s0-s6             |x1, x8-x9, x18-x22        |       |       |               | 0   | 0   |               |
  +----+------+----------------------+--------------------------+-------+-------+               +-----+-----+               +
  |0   |8     |ra, s0-s7             |x1, x8-x9, x18-x23        |16(3+x)|16(5+x)|               | 3   | 1   |               |
  +----+------+----------------------+--------------------------+       +       +               +-----+-----+               +
  |0   |9     |ra, s0-s8             |x1, x8-x9, x18-x24        |       |       |               | 2   | 0   |               |
  +----+------+----------------------+--------------------------+       +-------+               +-----+-----+               +
  |0   |10    |ra, s0-s9             |x1, x8-x9, x18-x25        |       |16(6+x)|               | 1   | 1   |               |
  +----+------+----------------------+--------------------------+       +       +               +-----+-----+               +
  |0   |11    |ra, s0-s10            |x1, x8-x9, x18-x26        |       |       |               | 0   | 0   |               |
  +----+------+----------------------+--------------------------+-------+-------+               +-----+-----+               +
  |0   |12    |ra, s0-s11            |x1, x8-x9, x18-x27        |16(4+x)|16(7+x)|               | 3   | 1   |               |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |0   |13-14 |*reserved, illegal instruction exception*                                                                    |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  | *Save all caller save registers and allocate stack space for entry into an interrupt handler*                           |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |0   |15    |ra,t0-t2, a0-a7, t3-t6|x1, x5-7, x10-17, x28-x31 |16(4+x)|16(8+x)|               | 0   | 0   |               |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |  *EABI only, may give the wrong result if the UABI is in use*                                                           |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |1   |0     |ra                    |x1                        | 8(1+x)|16(1+x)| 8(1+x)|16(1+x)| 1                         |
  +----+------+----------------------+--------------------------+       +       +       +       +-----+-----+-----+---------+
  |1   |1     |ra, s0                |x1, x8                    |       |       |       |       | 0                         |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |1   |2     |ra, s0-s1             |x1, x8-x9                 | 8(2+x)|16(2+x)| 8(2+x)|16(2+x)| 1                         |
  +----+------+----------------------+--------------------------+       +       +       +       +-----+-----+-----+---------+
  |1   |3     |ra, s0-s2             |x1, x8-x9, x14            |       |       |       |       | 0                         |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |1   |4     |ra, s0-s3             |x1, x8-x9, x14, x6        | 8(3+x)|16(3+x)| 8(3+x)|16(3+x)| 1                         |
  +----+------+----------------------+--------------------------+       +       +       +       +-----+-----+-----+---------+
  |1   |5     |ra, s0-s4             |x1, x8-x9, x14, x6-x7     |       |       |       |       | 0                         |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |1   |6-14  |*reserved, illegal instruction exception*                                                                    |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  | *Restore all caller save registers and deallocate stack space for exit from an interrupt handler*                       |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+
  |0   |15    |ra, t0, a0-3, t1      |x1, x5, x10-x13, x15      | 8(4+x)|16(4+x)|               | 1                         |
  +----+------+----------------------+--------------------------+-------+-------+-------+-------+-----+-----+-----+---------+

.. note::

  ``rcount=15`` is to save/restore the caller registers for the interrupt handler

``C.PUSH[.E]`` Operation
------------------------

A ``C.PUSH[.E]`` instruction writes the set of registers selected by *rcount* to memory, the registers are written to the memory immediately below the 
current stack pointer. The last register in the list stored to the lowest memory location to be written by the ``C.PUSH[.E]``

.. code-block:: text

  sp-(XLEN/8)*r

where *r* is the number registers to store (the second column from :ref:`regcount_table1`)

The selected registers are written to contiguous incrementing (XLEN/8)-byte words starting with the register in the reverse of the order 
shown in :ref:`regcount_table1` above (ra is always stored last).

Once all stores have completed the stack pointer register ``sp`` is decremented by the stack adjustment value from :ref:`spimm` and
:ref:`regcount_table1`. 

Note that *spimm* 
allows up to an additional bytes of stack to be allocated for automatic variables without having to issue additional stack manipulation 
instructions.

Also note that the stores can happen in any order, and may also be combined into wider stores as they access a continuous block of memory. 

Suggested C.PUSH[.E] UOP sequences
----------------------------------

The exact implementation will vary, this is one possible set of sequences of UOPs (micro-ops) which can be used to implement ``C.PUSH[.E]``

The ``sp`` adjustment is made first to allocate space before storing to memory, so that if the sequence is interrupted/resumed then the 
stack memory has already been reserved. Therefore the interrupt handler is able to allocate more stack space without affecting the interrupted instruction.
It also is possible to increment the stack pointer afterwards instead, and adjust the store addresses accordingly.

In the tables:

  -  ``N`` is the stack pointer adjustment value from :ref:`regcount_table1`. 
  -  ``M`` is ``XLEN/8`` i.e. 4 for RV32, 8 for RV84

.. table:: UOPs for ``C.PUSH`` if ``rcount<=12``

  ========================================= ======================================
  C.PUSH UOP                                Execute if
  ========================================= ======================================
  addi x2, x2,  -N                          1 
  sw x27,  (-13*M+N)(x2)                    rcount==12
  sw x26,  (-12*M+N)(x2)                    rcount<=12 && rcount>=11
  sw x25,  (-11*M+N)(x2)                    rcount<=12 && rcount>=10
  sw x24,  (-10*M+N)(x2)                    rcount<=12 && rcount>=9
  sw x23,  ( -9*M+N)(x2)                    rcount<=12 && rcount>=8
  sw x22,  ( -8*M+N)(x2)                    rcount<=12 && rcount>=7
  sw x21,  ( -7*M+N)(x2)                    rcount<=12 && rcount>=6
  sw x20,  ( -6*M+N)(x2)                    rcount<=12 && rcount>=5
  sw x19,  ( -5*M+N)(x2)                    rcount<=12 && rcount>=4
  sw x18,  ( -4*M+N)(x2)                    rcount<=12 && rcount>=3
  sw x9,   ( -3*M+N)(x2)                    rcount<=12 && rcount>=2
  sw x8,   ( -2*M+N)(x2)                    rcount<=12 && rcount>=1
  sw x1,   ( -1*M+N)(x2)                    1 
  ========================================= ======================================

.. table:: UOPs for ``C.PUSH`` if ``rcount==15``

  ========================================= ======================================
  C.PUSH UOP                                Execute if
  ========================================= ======================================
  addi x2, x2,  -N                          1
  sw x31,  (-16*M+N)(x2)                    rcount==15
  sw x30,  (-15*M+N)(x2)                    rcount==15
  sw x29,  (-14*M+N)(x2)                    rcount==15
  sw x28,  (-13*M+N)(x2)                    rcount==15
  sw x17,  (-12*M+N)(x2)                    rcount==15
  sw x16,  (-11*M+N)(x2)                    rcount==15
  sw x15,  (-10*M+N)(x2)                    rcount==15
  sw x14,  ( -9*M+N)(x2)                    rcount==15
  sw x13,  ( -8*M+N)(x2)                    rcount==15
  sw x12,  ( -7*M+N)(x2)                    rcount==15
  sw x11,  ( -6*M+N)(x2)                    rcount==15
  sw x10,  ( -5*M+N)(x2)                    rcount==15
  sw x7,   ( -4*M+N)(x2)                    rcount==15
  sw x6,   ( -3*M+N)(x2)                    rcount==15
  sw x5,   ( -2*M+N)(x2)                    rcount==15
  sw x1,   ( -1*M+N)(x2)                    1
  ========================================= ======================================

.. table:: UOPs for ``C.PUSH.E`` if ``rcount<=5``

  ========================================= ======================================
  C.PUSH.E UOP                              Execute if
  ========================================= ======================================
  addi x2, x2,  -N                          1
  sw x7,   (-6*M+N)(x2)                     rcount==5
  sw x6,   (-5*M+N)(x2)                     rcount<=5 && rcount>=4
  sw x14,  (-4*M+N)(x2)                     rcount<=5 && rcount>=3
  sw x9,   (-3*M+N)(x2)                     rcount<=5 && rcount>=2
  sw x8,   (-2*M+N)(x2)                     rcount<=5 && rcount>=1
  sw x1,   (-1*M+N)(x2)                     1
  ========================================= ======================================

.. table:: UOPs for ``C.PUSH.E`` if ``rcount==15``

  ========================================= ======================================
  C.PUSH.E UOP                              Execute if
  ========================================= ======================================
  addi x2, x2,  -N                          1
  sw x15,  (-7*M+N)(x2)                     rcount==15
  sw x13,  (-6*M+N)(x2)                     rcount==15
  sw x12,  (-5*M+N)(x2)                     rcount==15
  sw x11,  (-4*M+N)(x2)                     rcount==15
  sw x10,  (-3*M+N)(x2)                     rcount==15
  sw x5,   (-2*M+N)(x2)                     rcount==15
  sw x1,   (-1*M+N)(x2)                     1
  ========================================= ======================================

``C.POP[.E]/C.POPRET[.E]`` Operation
------------------------------------

A ``C.POP[.E]/C.POPRET[.E]`` instruction loads the set of registers selected by *rcount* from the memory. 
The loads start at the lowest memory location to be read by the ``C.POP[.E]/C.POPRET[.E]``. To get to that location
the stack pointer is first incremented by the scaled value of ``spimm`` from :ref:`spimm`, and then incremented
by the number of holes required to mantain the stack alignment (see :ref:`spimm` and
:ref:`regcount_table1`).

The selected registers are loaded from contiguous incrementing (XLEN/8)-byte words in the reverse of the order shown in :ref:`regcount_table1`
above (ra is always loaded last).

See :ref:`spimm` for stack increment calculations for all architectures.

Once all loads have completed the stack pointer register ``sp`` is incremented by the stack adjustment value from :ref:`spimm` and
:ref:`regcount_table1`, placing it immediately above the block of memory read by the ``C.POP[.E]/C.POPRET[.E]`` instruction. 

``C.POPRET[.E]`` executes a ``RET`` as the final step in the sequence

Note that the loads can happen in any order, and may also be combined into wider loads as they access a continuous block of memory. 

Suggested C.POP[.E]/C.POPRET[.E] UOP sequences
----------------------------------------------

The exact implementation will vary, this is one possible set of sequences of UOPs (micro-ops) which can be used to implement ``C.POP[.E]/C.POPRET[.E]``

The ``sp`` adjustment is made last to deallocate space after loading from memory, so that if the sequence is interrupted/resumed then the 
stack memory is still reserved so that the interrupt handler is able to allocate stack space and write to the stack without affecting the interrupted instruction.
It is possible to increment the stack pointer afterwards instead, and adjust the load addresses accordingly.

In the tables:

  -  ``N`` is the stack pointer adjustment value from :ref:`regcount_table1`. 
  -  ``M`` is ``XLEN/8`` i.e. 4 for RV32, 8 for RV84

``ra`` is loaded early for performance because the value is needed by ``ret``. This may complicate burst reads from memory so may not be a performance advantage.

.. table::  UOPs for ``C.POP/C.POPRET`` if ``rcount<=12``

  ========================================= ======================================
  C.POP/C.POPRET UOP                        Execute if
  ========================================= ======================================
  lw x1,   (-1*M+N)(x2)                     1
  lw x27,  (-13*M+N)(x2)                    rcount==12
  lw x26,  (-12*M+N)(x2)                    rcount<=12 && rcount>=11
  lw x25,  (-11*M+N)(x2)                    rcount<=12 && rcount>=10
  lw x24,  (-10*M+N)(x2)                    rcount<=12 && rcount>=9
  lw x23,  (-9*M+N)(x2)                     rcount<=12 && rcount>=8
  lw x22,  (-8*M+N)(x2)                     rcount<=12 && rcount>=7
  lw x21,  (-7*M+N)(x2)                     rcount<=12 && rcount>=6
  lw x20,  (-6*M+N)(x2)                     rcount<=12 && rcount>=5
  lw x19,  (-5*M+N)(x2)                     rcount<=12 && rcount>=4
  lw x18,  (-4*M+N)(x2)                     rcount<=12 && rcount>=3
  lw x9,   (-3*M+N)(x2)                     rcount<=12 && rcount>=2
  lw x8,   (-2*M+N)(x2)                     rcount<=12 && rcount>=1
  addi x2, x2,  N                           1
  ret                                       C.POPRET
  ========================================= ======================================

.. table:: UOPs for ``C.POP/C.POPRET`` if ``rcount==15``

  ========================================= ======================================
  C.POP/C.POPRET UOP                        Execute if
  ========================================= ======================================
  lw x1,   (-1*+N)(x2)                      1
  lw x31,  (-16*+N)(x2)                     rcount==15
  lw x30,  (-15*+N)(x2)                     rcount==15
  lw x29,  (-14*+N)(x2)                     rcount==15
  lw x28,  (-13*+N)(x2)                     rcount==15
  lw x17,  (-12*+N)(x2)                     rcount==15
  lw x16,  (-11*+N)(x2)                     rcount==15
  lw x15,  (-10*+N)(x2)                     rcount==15
  lw x14,  (-9*+N)(x2)                      rcount==15
  lw x13,  (-8*+N)(x2)                      rcount==15
  lw x12,  (-7*+N)(x2)                      rcount==15
  lw x11,  (-6*+N)(x2)                      rcount==15
  lw x10,  (-5*+N)(x2)                      rcount==15
  lw x7,   (-4*+N)(x2)                      rcount==15
  lw x6,   (-3*+N)(x2)                      rcount==15
  lw x5,   (-2*+N)(x2)                      rcount==15
  addi x2, x2,  N                           1
  ret                                       C.POPRET
  ========================================= ======================================

.. table:: UOPs for ``C.POP.E/C.POPRET.E`` if ``rcount<=5``

  ========================================= ======================================
  C.POP.E/C.POPRET.E UOP                    Execute if
  ========================================= ======================================
  lw x1,   (-1*M+N)(x2)                     1
  lw x7,   (-6*M+N)(x2)                     rcount==5
  lw x6,   (-5*M+N)(x2)                     rcount<=5 && rcount>=4
  lw x14,  (-4*M+N)(x2)                     rcount<=5 && rcount>=3
  lw x9,   (-3*M+N)(x2)                     rcount<=5 && rcount>=2
  lw x8,   (-2*M+N)(x2)                     rcount<=5 && rcount>=1
  addi x2, x2,  N                           1
  ret                                       C.POPRET.E
  ========================================= ======================================

.. table:: RV32 UOPs for ``C.POP.E/C.POPRET.E`` if ``rcount==15``

  ========================================= ======================================
  C.POP.E/C.POPRET.E RV32 UOP               Execute if
  ========================================= ======================================
  lw x1,   (-1*M+N)(x2)                     1
  lw x15,  (-7*M+N)(x2)                     rcount==15
  lw x13,  (-6*M+N)(x2)                     rcount==15
  lw x12,  (-5*M+N)(x2)                     rcount==15
  lw x11,  (-4*M+N)(x2)                     rcount==15
  lw x10,  (-3*M+N)(x2)                     rcount==15
  lw x5,   (-2*M+N)(x2)                     rcount==15
  addi x2, x2,  N                           1
  ret                                       C.POPRET.E
  ========================================= ======================================

Exceptions
----------

If ``eabi`` is zero and ``sp`` is not 16 byte aligned when a ``C.PUSH/C.POP/C.POPRET`` instruction is executed a memory alignment exception will be generated 
(Store Access Fault for ``C.PUSH``, Load Access Fault for ``C.POP/C.POPRET``).

If ``eabi`` is one and ``sp`` is not 8 byte aligned (RV32) or 16 byte aligned (RV64) when a ``C.PUSH.E/C.POP.E/C.POPRET.E`` instruction 
is executed a memory alignment exception will be generated (Store Access Fault for ``C.PUSH.E``, Load Access Fault for ``C.POP.E/C.POPRET.E``).

Illegal instructions are taken for illegal ``rcount`` values (see :ref:`regcount_table1`).

If ``eabi`` is zero on an RV32E/RV64E architecture take an illegal instruction exception.

Assembler Syntax
----------------

The ``C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]`` instructions are represented in assembler as the mnemonic followed by a braced and comma separated list of registers, 
followed by the total size of the stack adjustment expressed in bytes. 
The stack adjustment should include an appropriate sign bit and the space needed to accommodate the registers in the register list. 
Register ranges are also permitted and indicated using a hyphen (-). 
The register list may only contain registers supported by ``C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]`` instructions but these 
can be listed in any order and 
use the ABI or "x plus index register" representation. 

The mnemonics ``C.PUSH/C.POP/C.POPRET`` indicate the UABI i.e. ``eabi=0``

The mnemonics ``C.PUSH.E``/``C.POP.E``/``C.POPRET.E`` indicate the EABI i.e. ``eabi=1``

For ``RV32I/RV64I`` the correct menumonic must be chosen to select the ABI.

For ``RV32E/RV64E`` the mneumonics ``C.PUSH.E``/``C.POP.E``/``C.POPRET.E`` must be used.

To be legal the stack adjustment must:

1. Be negative for a ``C.PUSH[.E]`` and positive for a ``C.POP[.E]``/``C.POPRET[.E]``
2. Match the value range in :ref:`regcount_table1` for the current architecture and ABI   

To use the 16-bit encoding of ``C.PUSH[.E]/C.POP[.E]/C.POPRET[.E]`` then the registers specified in the encoding must match one of the sets of entries in :ref:`regcount_table1` 
above, and the stack adjustment must be legal. Otherwise the assembler will attempt to use the 32-bit encoding, if it is implemented and is suitable. If not then this will cause an 
an ``illegal operands`` error from the assembler.
 
RV32I UABI Examples
-------------------

.. _push_example_figure:
.. figure:: images/push_1to5_regs_170pc_zoom.png
  
  push 1 to 5 registers, stores can happen in any order, note 3 register holes in the stack pointer decrement

.. _pop_example_figure:
.. figure:: images/pop_1to5_regs_170pc_zoom.png
  
  pop 1 to 5 registers, loads can happen in any order, note 3 register holes in the stack pointer increment

RV32I Assembler Examples
------------------------

C.PUSH RV32I UABI
-----------------

.. code-block:: text

 c.push  {ra, s0-s4}, -64

Encoding: rcount=5,  spimm=2 eabi=0 (16-byte aligned)

Micro operation sequence: 

.. code-block:: text

  addi sp, sp, -64;
  sw  s4, 40(sp); sw  s3, 44(sp);
  sw  s2, 48(sp); sw  s1, 52(sp);
  sw  s0, 56(sp); sw  ra, 60(sp);

C.PUSH.E RV32I EABI
-------------------

.. code-block:: text

 c.push.e {ra, s0-s4}, -64

Encoding: rcount=5, spimm=5 eabi=1 (8-byte aligned, so spimm is larger than the UABI version)

Micro operation sequence: 

.. code-block:: text

  addi sp, sp, -64;
  sw  s4, 40(sp); sw  s3, 44(sp);
  sw  s2, 48(sp); sw  s1, 52(sp);
  sw  s0, 56(sp); sw  ra, 60(sp);

C.POP RV32I UABI
----------------

.. code-block:: text

  c.pop   {x1, x8-x9, x18-x25}, 160

Encoding: rcount=10, spimm=7 eabi=0 (16-byte aligned, maximum value of spimm for the 16-bit encoding)

Micro operation sequence:

.. code-block:: text

  lw   x1, 156(sp);
  lw  x25, 116(sp);  lw  x24, 120(sp);
  lw  x23, 124(sp);  lw  x22, 128(sp)
  lw  x21, 132(sp);  lw  x20, 136(sp);
  lw  x19, 140(sp);  lw  x18, 144(sp)
  lw   x9, 148(sp);  lw   x8, 152(sp);
  addi sp, sp, 160

C.POPRET RV32I UABI
-------------------

.. code-block:: text

  c.popret   {x1, x8-x9, x18-x19}, 32

Encoding: rcount=4,  spimm=0 eabi=0 (16-byte aligned)

Micro operation sequence:

.. code-block:: text

  lw   x1, 28(sp);
  lw  x19, 12(sp);  lw  x18, 16(sp);
  lw   x9, 20(sp);  lw   x8, 24(sp);
  addi sp, sp, 32; ret

C.POPRET.E RV32I EABI
---------------------

.. code-block:: text

  c.popret.e  {x1, x8-x9, x14, x6}, 32

Encoding: rcount=4,  spimm=1 eabi=1 (8-byte aligned)

Micro operation sequence:

.. code-block:: text

  lw   x1, 28(sp);
  lw   x6, 12(sp);  lw  x14, 16(sp);
  lw   x9, 20(sp);  lw   x8, 24(sp);
  addi sp, sp, 32; ret

Varargs Support
===============

Functions using varargs also spill the argument registers to the stack, which requires a ``SWM`` custom instruction (store-word-multiple).

.. code_block::

  int printf(const char *__restrict, ...);

HCC produces this prologue:

.. code-block:: text

  16: addi sp,sp,-64 
  16: sw   ra,28(sp)
  16: sw   s0,24(sp)
  
  16: sw   a7,60(sp)
  16: sw   a6,56(sp)
  16: sw   a5,52(sp)
  16: sw   a4,48(sp)
  16: sw   a3,44(sp)
  16: sw   a2,40(sp)
  16: sw   a1,36(sp)

This can be optimised to be:

.. code-block:: text
  
  16: addi sp,sp,-32
  16: push {ra, s0},-32
  16: addi sp,sp,(-32+36)
  16: swm  {a1-a7},sp
  16: addi sp,sp,-36 

saving 3x16-bit encodings, but the stack pointer adjustments are awkward because ``SWM`` doesn't have an immediate offset

HCC produces this epilogue

.. code-block:: text

  16: lw   ra,28(sp)
  16: lw   s0,24(sp)
  16: addi sp,sp,64
  16: ret

which could become:

.. code-block:: text

  16: addi sp,sp,32
  16: popret {ra,s0},32

saving 2x16-bit encodings.

So in total 14 instructions can be reduced to 9.

32-bit encodings
================

The 32-bit versions of the instructions allow greater flexibility in specifying the list of registers by allowing floating point registers to be saved/restored. 
Therefore the register list also allows floating point registers to be included. They can included in any order, but will always be accessed in the same order by the instruction.
They also allow a larger range of *spimm* values.
Otherwise the semantics are identical to the 16-bit versions
and so the specification is not repeated here. The instructions are called ``PUSH[.E]``/``POP[.E]``/``POPRET[.E]``

These instructions will *not* cover all possible push/pop scenarios, they are designed to cover the common cases without using excessive encoding space.


.. note::

  This specification does not include the case in RV32D where an odd number of ``X`` registers are stored followed by one or more ``F`` registers. This *may*
  require an adjustment in address between the ``X`` and ``F`` registers to maintain the stack alignment, and the tables showing the overall
  stack adjustment *may not* be correct as every ``F`` register is twice as wide as the ``X`` registers

.. note::
  Maybe avoid pushing/popping ``ra`` for tail calls
 
.. note:: 
  A C-function using varargs will also spill the argument registers to the stack. They can be achieved by a store-multiple command after the PUSH instruction
  and vararg support is not directly implemented by PUSH




Opcode Assignment
-----------------

.. _pushpop32_encoding:
.. table:: ``PUSH``/``POP``/``POPRET`` 32-bit instruction encoding

  +------+---+-------+------+-------+-----+-----+-------+----------+
  |31:28 |27 |26:24  |23:20 |19:15  |14:12|11:7 |6:0    |name      |
  +------+---+-------+------+-------+-----+-----+-------+----------+
  |xxxxxx| 0 |frcount|rcount|spimm  |xxx  |xxxxx|xxxxxxx|PUSH      |
  +------+---+-------+------+-------+-----+-----+-------+----------+
  |xxxxxx| 0 |frcount|rcount|spimm  |xxx  |xxxxx|xxxxxxx|POP       |
  +------+---+-------+------+-------+-----+-----+-------+----------+
  |xxxxxx| 0 |frcount|rcount|spimm  |xxx  |xxxxx|xxxxxxx|POPRET    |
  +------+---+-------+------+-------+-----+-----+-------+----------+
  |xxxxxx| 1 |frcount|rcount|spimm  |xxx  |xxxxx|xxxxxxx|PUSH.E    |
  +------+---+-------+------+-------+-----+-----+-------+----------+
  |xxxxxx| 1 |frcount|rcount|spimm  |xxx  |xxxxx|xxxxxxx|POP.E     |
  +------+---+-------+------+-------+-----+-----+-------+----------+
  |xxxxxx| 1 |frcount|rcount|spimm  |xxx  |xxxxx|xxxxxxx|POPRET.E  |
  +------+---+-------+------+-------+-----+-----+-------+----------+

- bit [27] is ``eabi`` which specifies which ABI is in use

The ``x`` registers are specified by :ref:`regcount_table1`, there is no difference in the specification except that ``spimm`` has a larger range.
The addition field ``frcount`` allows callee save ``f`` registers to be saved/restored as well. The ``f`` registers are always appended to the list 
of integer registers.

.. _pushpop32_frcount:
.. table:: ``PUSH``/``POP``/``POPRET`` *frcount* values

  +--------+-------------------------+-----------------------------+
  |frcount | ABI names               |	Register numbers           |
  +        +                         +-----------------------------+
  |        |                         |  all non-Zfinx architectures|
  +--------+-------------------------+-----------------------------+
  | 0      |none                     |N/A                          |
  +--------+-------------------------+-----------------------------+
  | 1      |fs0                      |f8                           |
  +--------+-------------------------+-----------------------------+
  | 2      |fs0-fs1                  |f8-f9                        |
  +--------+-------------------------+-----------------------------+
  | 3      |fs0-fs2                  |f8-f9, f18                   |
  +--------+-------------------------+-----------------------------+
  | 4      |fs0-fs3                  |f8-f9, f18-f19               |
  +--------+-------------------------+-----------------------------+
  | 5      |fs0-fs4                  |f8-f9, f18-f20               |
  +--------+-------------------------+-----------------------------+
  | 6      |fs0-fs5                  |f8-f9, f18-f21               |
  +--------+-------------------------+-----------------------------+
  | 7      |fs0-fs6                  |f8-f9, f18-f22               |
  +--------+-------------------------+-----------------------------+
  | 8      |fs0-fs7                  |f8-f9, f18-f23               |
  +--------+-------------------------+-----------------------------+
  | 9      |fs0-fs8                  |f8-f9, f18-f24               |
  +--------+-------------------------+-----------------------------+
  | 10     |fs0-fs9                  |f8-f9, f18-f25               |
  +--------+-------------------------+-----------------------------+
  | 11     |fs0-fs10                 |f8-f9, f18-f26               |
  +--------+-------------------------+-----------------------------+
  | 12     |fs0-fs11                 |f8-f9, f18-f27               |
  +--------+-------------------------+-----------------------------+
  | 13-14  |*reserved*                                             |
  +--------+-------------------------+-----------------------------+
  | 15     |ft0-7, fa0-7, ft8-11     |f0-f7, f10-f17, f28-f31      |
  +--------+-------------------------+-----------------------------+

.. note::

  ``frcount=15`` is to save/restore the caller registers for the interrupt handler. There are different rules for the instruction if ``rcount`` or ``frcount`` are 15

The total stack adjustment is based upon the total number of registers accessed, not just the ``x`` registers.

Specification if rcount < 15
----------------------------

The order of registers load/stored is:

- ra

- if (``rcount`` > 0) s0-s ``rcount``

- if (``frcount`` != 0 && ``frcount`` < 13) fs0-fs ``frcount``

This is the same as the 16-bit encoding, except that the register list may be extended with ``fs0-fs11``.
The final stack pointer offset is the same as for the 16-bit encoding, but with a larger range see :ref:`regcount_table2_eab_0`

Therefore the 16-bit encoding allows up to 13 registers to be saved/restored. The 32-bit encoding also allows up to 12 additional registers
giving a maximum of 25.

If ``frcount`` >0 and the F extension is not implemented, without ``Zfinx`` , then take an illegal instruction exception.

if ``frcount`` >12 then take an illegal instruction exception.  

The other illegal instruction checks are identical to those for the 16-bit encodings.

Specification if rcount == 15
-----------------------------

The order of registers load/stored is:

- ra

- all ``X`` caller save registers 

- if (``frcount`` == 15) all ``F`` caller save registers

This is the same as the 16-bit encoding with ``rcount=15``, except that the register list may be extended with the ``F`` caller registers.
The final stack pointer offset is the same as for the 16-bit encoding, but with a larger range see :ref:`regcount_table2_eab_0`

  - ``PUSH/POP/POPRET``:       the 16-bit encoding allows 16 ``X`` registers to be saved/restored. The 32-bit encoding also allows an additional 20 ``F`` registers giving a maximum of 36.
  - ``PUSH.E/POP.E/POPRET.E``: the 16-bit encoding allows  7 ``X`` registers to be saved/restored. The 32-bit encoding also allows an additional 20 ``F`` registers giving a maximum of 27.

If ``frcount`` !=0 && ``frcount`` !=15  then take an illegal instruction exception.

If ``frcount`` ==15 and the F extension is not implemented, without ``Zfinx``, then take an illegal instruction exception.

The other illegal instruction checks are identical to those for the 16-bit encodings.

.. _regcount_table2_eab_0:
.. table:: Register count mapping for ``C.PUSH/C.POP/C.POPRET``

  +------+-------+--------+-----+-----+
  |total |SP adjustment   |reg holes  |
  |# regs|x=spimm,        |to skip    |
  +      +                +           +
  |      |-for PUSH,      |           |
  |      |+for POP/POPRET |           |
  +      +-------+--------+-----+-----+
  |      |RV32I  |RV64I   |RV32I|RV64I|
  +------+-------+--------+-----+-----+
  |*eabi = 0*                         |
  +------+-------+--------+-----+-----+
  |1     |16(1+x)|16(1+x) | 3   | 1   |
  +------+       +        +-----+-----+
  |2     |       |        | 2   | 0   |
  +------+       +--------+-----+-----+
  |3     |       |16(2+x) | 1   | 1   |
  +------+       +        +-----+-----+
  |4     |       |        | 0   | 0   |
  +------+-------+--------+-----+-----+
  |5     |16(2+x)|16(3+x) | 3   | 1   |
  +------+       +        +-----+-----+
  |6     |       |        | 2   | 0   |
  +------+       +--------+-----+-----+
  |7     |       |16(4+x) | 1   | 1   |
  +------+       +        +-----+-----+
  |8     |       |        | 0   | 0   |
  +------+-------+--------+-----+-----+
  |9     |16(3+x)|16(5+x) | 3   | 1   |
  +------+       +        +-----+-----+
  |10    |       |        | 2   | 0   |
  +------+       +--------+-----+-----+
  |11    |       |16(6+x) | 1   | 1   |
  +------+       +        +-----+-----+
  |12    |       |        | 0   | 0   |
  +------+-------+--------+-----+-----+
  |13    |16(4+x)|16(7+x) | 3   | 1   |
  +------+       +        +-----+-----+
  |14    |       |        | 2   | 0   |
  +------+       +--------+-----+-----+
  |15    |       |16(8+x) | 1   | 1   |
  +------+       +        +-----+-----+
  |16    |       |        | 0   | 0   |
  +------+-------+--------+-----+-----+
  |17    |16(5+x)|16(9+x) | 3   | 1   |
  +------+       +        +-----+-----+
  |18    |       |        | 2   | 0   |
  +------+       +--------+-----+-----+
  |19    |       |16(10+x)| 1   | 1   |
  +------+       +        +-----+-----+
  |20    |       |        | 0   | 0   |
  +------+-------+--------+-----+-----+
  |21    |16(6+x)|16(11+x)| 3   | 1   |
  +------+       +        +-----+-----+
  |22    |       |        | 2   | 0   |
  +------+       +--------+-----+-----+
  |23    |       |16(12+x)| 1   | 1   |
  +------+       +        +-----+-----+
  |24    |       |        | 0   | 0   |
  +------+-------+--------+-----+-----+
  |25    |16(7+x)|16(13+x)| 3   | 1   |
  +------+-------+--------+-----+-----+
  |25-35 | *reserved*                 |
  +------+-------+--------+-----+-----+
  |36    |16(9+x)|16(18+x)| 0   | 0   |
  +------+-------+--------+-----+-----+

.. _regcount_table2_eab_1:
.. table:: Register count mapping for ``C.PUSH.E/C.POPE/C.POPRETE``

  +------+-------+--------+-------+--------+-----+-----+-----+-----+
  |total |Stack pointer adjustment         |reg holes to skip      |
  +      +                                 +                       +
  |# regs|x=spimm -for PUSH, +for POP      |                       |
  +      +-------+--------+-------+--------+-----+-----+-----+-----+
  |      |RV32I  |RV64I   |RV32E  |RV64E   |                       |
  +------+-------+--------+-------+--------+-----+-----+-----+-----+
  |*eabi = 1*                                                      |
  +------+-------+--------+-------+--------+-----+-----+-----+-----+
  |1     | 8(1+x)|16(1+x) | 8(1+x)|16(1+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |2     |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |3     | 8(2+x)|16(2+x) | 8(2+x)|16(2+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |4     |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |5     | 8(3+x)|16(3+x) | 8(3+x)|16(3+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |6     |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |7     | 8(4+x)|16(4+x) | 8(4+x)|16(4+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |8     |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |9     | 8(5+x)|16(5+x) | 8(5+x)|16(5+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |10    |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |11    | 8(6+x)|16(6+x) | 8(6+x)|16(6+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |12    |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |13    | 8(7+x)|16(7+x) | 8(7+x)|16(7+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |14    |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |15    | 8(8+x)|16(8+x) | 8(8+x)|16(8+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |16    |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |17    | 8(9+x)|16(9+x) | 8(9+x)|16(9+x) | 1                     |
  +------+       +        +       +        +-----------------------+
  |18    |       |        |       |        | 0                     |
  +------+-------+--------+-------+--------+-----------------------+
  |18-26 | *reserved*                                              |
  +------+-------+--------+-------+--------+-----------------------+
  |27    |8(14+x)|16(14+x)|8(14+x)|16(14+x)| 1                     |
  +------+-------+--------+-------+--------+-----+-----+-----+-----+

Assembler Examples
------------------

PUSH RV32I UABI
---------------

.. code-block:: text

 push  {ra, s0-s4, fs0}, -64

Encoding: rcount=5, frcount=1, spimm=2, eabi=0 (16-byte aligned, C.PUSH doesn't support f registers)

Micro operation sequence: 

.. code-block:: text

  addi sp, sp, -64;
  fsw fs0, 36(sp)
  sw  s4, 40(sp); sw  s3, 44(sp);
  sw  s2, 48(sp); sw  s1, 52(sp);
  sw  s0, 56(sp); sw  ra, 60(sp);

PUSH.E RV32I EABI
-----------------

.. code-block:: text

 pushe  {ra, s0-s4, fs0}, -64

Encoding: rcount=5, frcount=1, spimm=4 eabi=1 (8-byte aligned, so spimm is larger than the UABI version)

Micro operation sequence: 

.. code-block:: text

  addi sp, sp, -64;
  fsw fs0, 36(sp)
  sw  s4, 40(sp); sw  s3, 44(sp);
  sw  s2, 48(sp); sw  s1, 52(sp);
  sw  s0, 56(sp); sw  ra, 60(sp);

POP RV32I UABI
--------------

.. code-block:: text

  pop   {x1, x8-x9, x18-x25}, 256

Encoding: rcount=10, frcount=0, spimm=13 eabi=0 (16-byte aligned, spimm out of range for C.POP)

Micro operation sequence:

.. code-block:: text

  lw   x1, 252(sp);
  lw  x25, 212(sp);  lw  x24, 216(sp);
  lw  x23, 220(sp);  lw  x22, 224(sp)
  lw  x21, 228(sp);  lw  x20, 232(sp);
  lw  x19, 236(sp);  lw  x18, 240(sp)
  lw   x9, 244(sp);  lw   x8, 248(sp);
  addi sp, sp, 256

POPRET RV32I UABI
-------------------

.. code-block:: text

  popret   {x1, x8-x9, x18-x19, f8-f9}, 32

Encoding: rcount=4, frcount=2, spimm=0, eabi=0 (16-byte aligned)

Micro operation sequence:

.. code-block:: text

  lw   x1, 28(sp);
  flw  f9,  4(s0);  flw  f8,  8(sp);
  lw  x19, 12(sp);  lw  x18, 16(sp);
  lw   x9, 20(sp);  lw   x8, 24(sp);
  addi sp, sp, 32; ret

POPRET RV32I EABI
-------------------

.. code-block:: text

  poprete  {x1, x8-x9, x14, x6, f8-f9}, 32

Encoding: rcount=4, frcount=2, spimm=0 eabi=1 (8-byte aligned)

Micro operation sequence:

.. code-block:: text

  lw   x1, 28(sp);
  flw  f9,  4(s0);  flw  f8,  8(sp);
  lw   x6, 12(sp);  lw  x14, 16(sp);
  lw   x9, 20(sp);  lw   x8, 24(sp);
  addi sp, sp, 32; ret
