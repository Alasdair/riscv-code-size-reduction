<<<
[#insns-cm_jalt,reftext="Jump via table with optional link"]
=== cm.jalt

Synopsis::
jump via table with optional link

Mnemonic::
cm.jalt _index_

Encoding (RV32, RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  2, name: 0x2,      attr: ['C2'] },
    { bits:  8, name: 'index',  attr: [] },
    { bits:  3, name: 0x0,      attr: [] },
    { bits:  3, name: 0x5,      attr: ['FUNCT3'] },
],config:{bits:16}}
....

Assembly Syntax::

[source,sail]
--
cm.jalt index
--

Description::

_cm.jalt_ reads an entry from the jump vector table in memory and jumps to the address that was read. If the LSB of the table entry is 0 then link to ra, otherwise don't link.

_cm.jalt_ is reserved if executing from a mode with higher privilege than user mode where the current XLEN does not match UXLEN.

For further information see <<insns-tablejump>>.

Prerequisites::
None

32-bit equivalent::
No direct equivalent encoding exists.

<<<

[#insns-cm_jalt-SAIL,reftext="cm.jalt SAIL code"]
Operation::

[source,sail]
--
//This is not SAIL, it's pseudo-code. The SAIL hasn't been written yet.

if (mode==M  && MXLEN !=UXLEN) reserved();
if (mode==S  && SXLEN !=UXLEN) reserved();
if (mode==HS && HSXLEN!=UXLEN) reserved();
if (mode==VS && VSXLEN!=UXLEN) reserved();

# target_address is temporary internal state, it doesn't represent a real register
# InstMemory is byte indexed

switch(XLEN) {
  32:  table_address[XLEN-1:0] = JVT.base + (index<<2);
  64:  table_address[XLEN-1:0] = JVT.base + (index<<3);
}

//fetch from the jump table
target_address[XLEN-1:0] = InstMemory[table_address][XLEN-1:0];

//jump to the target address, check the LSB to see whether to link
if (target_address[0]==1'b0)
  jalr target_address[XLEN-1:0]&~0x1;
else
  jr   target_address[XLEN-1:0]&~0x1;

--

include::Zcmt_footer.adoc[]

